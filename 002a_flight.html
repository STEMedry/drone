<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- Meta viewport to improve touch responsiveness on iOS -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Quadcopter Flight Simulation</title>
    <style>
      /* Prevent zooming/scrolling on touch devices and disable text selection */
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        touch-action: none;
        -ms-touch-action: none;
        user-select: none;
        -webkit-user-select: none;
      }
      canvas {
        display: block;
      }
      /* Title styling at the top middle */
      #title {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 32px;
        font-weight: bold;
        text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
        z-index: 100;
      }
      /* Language Toggle Button (Top Right Corner) */
      #langToggle {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 110;
        padding: 8px 12px;
        font-size: 16px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        background-color: #4caf50;
        color: white;
      }
      /* General Message (for RTH & landing messages) */
      #message {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        font-size: 24px;
        border-radius: 5px;
        z-index: 110;
        display: none;
      }
      /* Blinking animation for the message */
      @keyframes blinking {
        0%   { opacity: 1; }
        50%  { opacity: 0; }
        100% { opacity: 1; }
      }
      .blinking {
        animation: blinking 1s infinite;
      }
      /* Controls Container (bottom center) */
      #controls {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        background: rgba(255, 255, 255, 0.8);
        padding: 20px;
        border-radius: 5px;
        width: 1000px;
        height: 220px;
      }
      /* Info box for Altitude & Distance (red and bold) */
      #info {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 18px;
        color: red;
        font-weight: bold;
      }
      #btn-reset {
        position: absolute;
        bottom: 10px;
        right: 480px;
        width: 80px;
        height: 40px;
        padding: 10px;
        font-size: 18px;
        font-weight: bold;
        border: none;
        border-radius: 5px;
      }
      /* Container for slider and joysticks */
      #main-controls {
        display: flex;
        align-items: center;
        gap: 100px;
      }
      /* Speed slider container (center) */
      #speedContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        transform: translateY(-60px);
      }
      #speedLabel {
        font-size: 18px;
        font-weight: bold;
      }
      #speedSlider {
        width: 200px;
      }
      /* Enlarge Flight Path Button (same size as Speed) */
      #toggleFlightPath {
        font-size: 18px;
        padding: 10px 20px;
      }
      /* RTH Button styling */
      #rthBtn {
        font-size: 18px;
        padding: 10px 20px;
        margin-top: 5px;
      }
      /* Enlarged Virtual Joystick Styles */
      .joystick-container {
        width: 300px;
        height: 300px;
        position: relative;
        touch-action: none;
        -ms-touch-action: none;
      }
      .joystick-base {
        width: 200px;
        height: 200px;
        background: rgba(76, 175, 80, 0.5);
        border: 2px solid #aaa;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        top: 40%;
        transform: translate(-50%, -50%);
      }
      .joystick-thumb {
        width: 80px;
        height: 80px;
        border: 2px solid #555;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        top: 40%;
        transform: translate(-50%, -50%);
        touch-action: none;
        -ms-touch-action: none;
      }
      /* Deep colours for joystick thumbs */
      #leftJoystick .joystick-thumb {
        background-color: #006400;
      }
      #rightJoystick .joystick-thumb {
        background-color: #FF8C00;
      }
      /* Right joystick base in orange */
      #rightJoystick .joystick-base {
        background: rgba(255, 152, 0, 0.5);
      }
      /* Joystick label styles */
      .joystick-label {
        position: absolute;
        font-size: 16px;
        color: black;
        font-weight: bold;
        pointer-events: none;
      }
      /* Left joystick labels */
      #leftJoystick .label-top {
        top: 0px;
        left: 50%;
        transform: translateX(-50%);
      }
      #leftJoystick .label-bottom {
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
      }
      #leftJoystick .label-left {
        left: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      #leftJoystick .label-right {
        right: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      /* Right joystick labels */
      #rightJoystick .label-top {
        top: 0px;
        left: 50%;
        transform: translateX(-50%);
      }
      #rightJoystick .label-bottom {
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
      }
      #rightJoystick .label-left {
        left: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      #rightJoystick .label-right {
        right: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      /* Top View Container and Controls */
      #topViewContainer {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 30;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      /* The top view renderer now acts as a container for the arrow buttons */
      #topViewRenderer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        transform: rotate(180deg);
        background: none;
        position: relative;
      }
      /* Arrow buttons positioned inside the top view renderer */
      .arrow-btn {
        position: absolute;
        background: rgba(200, 200, 200, 0.7);
        border: 1px solid #666;
        border-radius: 3px;
        font-size: 18px;
        padding: 5px;
        cursor: pointer;
      }
      /* Position the arrow buttons within the container */
      #topArrowUp {
        top: 5px;
        left: 50%;
        transform: translateX(-50%);
      }
      #topArrowDown {
        bottom: 5px;
        left: 50%;
        transform: translateX(-50%);
      }
      /* Left arrow moves the target to the left and Right arrow moves the target to the right. */
      #topArrowLeft {
        left: 5px;
        top: 50%;
        transform: translateY(-50%);
      }
      #topArrowRight {
        right: 5px;
        top: 50%;
        transform: translateY(-50%);
      }
      /* Zoom Controls for Top View with a Home button remain below the renderer */
      #zoomControls {
        margin-top: 5px;
        display: flex;
        gap: 10px;
      }
      /* Hoop Table (2 rows) at the top right */
      #hoopTable {
        position: absolute;
        top: 60px;
        right: 20px;
        z-index: 100;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border: 1px solid #ccc;
        display: grid;
        grid-template-columns: repeat(5, 30px);
        gap: 5px;
      }
      #hoopTable .hoopCell {
        width: 30px;
        height: 30px;
        line-height: 30px;
        text-align: center;
        font-weight: bold;
        background: yellow;
        border: 1px solid #000;
      }
      #hoopTable .hoopCell.passed {
        background: grey;
      }
      /* Button classes */
      .btn-green {
        background-color: #4caf50;
        color: white;
      }
      .btn-red {
        background-color: #f44336;
        color: white;
      }
      .btn-default {
        background-color: #2196f3;
        color: white;
      }
    </style>
  </head>
  <body>
    <!-- Title -->
    <div id="title">Quadcopter Flight Simulation</div>
    <!-- Language Toggle Button -->
    <button id="langToggle" class="btn-green">繁體中文</button>
    <!-- General Message -->
    <div id="message"></div>

    <!-- Top View Container -->
    <div id="topViewContainer">
      <div id="topViewRenderer">
        <!-- Arrow buttons inside the top view renderer -->
        <button id="topArrowUp" class="arrow-btn">▲</button>
        <button id="topArrowDown" class="arrow-btn">▼</button>
        <button id="topArrowLeft" class="arrow-btn">◄</button>
        <button id="topArrowRight" class="arrow-btn">►</button>
      </div>
      <!-- Zoom Controls with "Home" Button below the top view renderer -->
      <div id="zoomControls">
        <button id="zoomIn">Zoom In</button>
        <button id="homeView">Home</button>
        <button id="zoomOut">Zoom Out</button>
      </div>
    </div>

    <!-- Hoop Table -->
    <div id="hoopTable">
      <div class="hoopCell" id="hoopCell-1">1</div>
      <div class="hoopCell" id="hoopCell-2">2</div>
      <div class="hoopCell" id="hoopCell-3">3</div>
      <div class="hoopCell" id="hoopCell-4">4</div>
      <div class="hoopCell" id="hoopCell-5">5</div>
      <div class="hoopCell" id="hoopCell-6">6</div>
      <div class="hoopCell" id="hoopCell-7">7</div>
      <div class="hoopCell" id="hoopCell-8">8</div>
      <div class="hoopCell" id="hoopCell-9">9</div>
      <div class="hoopCell" id="hoopCell-10">10</div>
    </div>

    <!-- Controls Container -->
    <div id="controls">
      <div id="info">Altitude: 0 | Distance: 0</div>
      <div id="main-controls">
        <!-- Left Virtual Joystick (Throttle & Yaw) -->
        <div class="joystick-container" id="leftJoystick">
          <div class="joystick-base"></div>
          <div class="joystick-thumb"></div>
          <span class="joystick-label label-top">Throttle Up</span>
          <span class="joystick-label label-bottom">Throttle Down</span>
          <span class="joystick-label label-left">Yaw Left</span>
          <span class="joystick-label label-right">Yaw Right</span>
        </div>
        <!-- Speed Slider, Flight Path Toggle, and RTH Button -->
        <div id="speedContainer">
          <div id="speedLabel">Speed</div>
          <input type="range" id="speedSlider" min="10" max="100" value="50" step="1" />
          <button id="toggleFlightPath" class="btn-default">Show Flight Path</button>
          <button id="rthBtn" class="btn-default">RTH</button>
        </div>
        <!-- Right Virtual Joystick (Pitch & Roll) -->
        <div class="joystick-container" id="rightJoystick">
          <div class="joystick-base"></div>
          <div class="joystick-thumb"></div>
          <span class="joystick-label label-top">Pitch Forward</span>
          <span class="joystick-label label-bottom">Pitch Backward</span>
          <span class="joystick-label label-left">Roll Left</span>
          <span class="joystick-label label-right">Roll Right</span>
        </div>
      </div>
      <button id="btn-reset" class="btn-red">Reset</button>
    </div>

    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // --- Global Audio Setup ---
      // Pre-create bonusSound and sweetSound so they can be unlocked on iOS and reused.
      const bonusSound = new Audio("bonus.mp3");
      bonusSound.loop = false;
      const sweetSound = new Audio("sweet.mp3");
      sweetSound.loop = false;
      // landAudio and rthAudio are defined later.
      
      // Create flyAudio to play "flysound.mp3" during flight.
      const flyAudio = new Audio("flysound.mp3");
      flyAudio.loop = true;
      flyAudio.volume = 0; // start at a low volume for fade-in
      let flyAudioPlaying = false;
      
      // --- Audio Unlock for iOS ---
      // iOS requires a user gesture to enable sound. Unlock all audios on first touch.
      function unlockAudio() {
        [bonusSound, sweetSound, landAudio, rthAudio, flyAudio].forEach(audio => {
          audio.play().then(() => {
            audio.pause();
            audio.currentTime = 0;
          }).catch(() => {});
        });
        document.removeEventListener("touchstart", unlockAudio);
      }
      document.addEventListener("touchstart", unlockAudio, false);
      
      // Linear interpolation helper.
      function lerp(a, b, t) {
        return a + (b - a) * t;
      }
      
      // Helper function to create a directional sprite.
      function createDirectionSprite(text, color = "black") {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = color;
        ctx.font = "bold 90px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(250, 250, 1);
        return sprite;
      }
      
      // --- Three.js Scene Setup ---
      const scene = new THREE.Scene();
      
      const northSprite = createDirectionSprite("NORTH");
      northSprite.position.set(0, 8, 540);
      scene.add(northSprite);
      
      const eastSprite = createDirectionSprite("EAST");
      eastSprite.position.set(-540, 8, 0);
      scene.add(eastSprite);
      
      const southSprite = createDirectionSprite("SOUTH");
      southSprite.position.set(0, 8, -540);
      scene.add(southSprite);
      
      const westSprite = createDirectionSprite("WEST");
      westSprite.position.set(540, 8, 0);
      scene.add(westSprite);
      
      // Home Marker Creation.
      function drawHomeMarker(ctx, padColor) {
        ctx.clearRect(0, 0, 256, 256);
        ctx.fillStyle = padColor;
        ctx.beginPath();
        ctx.arc(128, 128, 120, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "black";
        ctx.lineWidth = 10;
        ctx.stroke();
        ctx.fillStyle = "black";
        ctx.font = "bold 100px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("H", 128, 128);
      }
      function createHomeMarker() {
        const canvas = document.createElement("canvas");
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext("2d");
        drawHomeMarker(ctx, "white");
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
        const geometry = new THREE.CircleGeometry(5, 32);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.set(0, 0.01, 0);
        mesh.userData = { canvas: canvas, ctx: ctx, texture: texture };
        return mesh;
      }
      
      let missionCompleted = false;
      let rthActive = false;
      
      // --- Audio Setup ---
      let rthAudio = new Audio("rth12.mp3");
      rthAudio.loop = true;
      let landAudio = new Audio("land1.mp3");
      landAudio.loop = false;
      let rthAudioPlaying = false;
      let landAudioPlayed = false;
      
      // --- Flight Path Variables ---
      let flightPathPoints = [];
      let flightPathLine = null;
      
      // --- Virtual Joystick Helper ---
      function attachJoystick(containerId, joystickObj) {
        const container = document.getElementById(containerId);
        const thumb = container.querySelector(".joystick-thumb");
        let dragging = false, pointerId = null, activeTouchId = null;
        let center = { x: 0, y: 0 };
        const maxDist = 40;
        joystickObj.active = false;
        function updateThumb(dx, dy) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
          joystickObj.dx = dx / maxDist;
          joystickObj.dy = dy / maxDist;
          thumb.style.transform = `translate(${dx - 40}px, ${dy - 40}px)`;
        }
        function resetThumb() {
          dragging = false;
          joystickObj.active = false;
          activeTouchId = null;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          thumb.style.transform = "translate(-50%, -50%)";
        }
        function onPointerDown(e) {
          if (e.pointerType === "mouse" && e.button !== 0) return;
          dragging = true;
          joystickObj.active = true;
          pointerId = e.pointerId;
          const rect = container.getBoundingClientRect();
          center.x = rect.left + rect.width / 2;
          center.y = rect.top + rect.height / 2;
          updateThumb(e.clientX - center.x, e.clientY - center.y);
          container.setPointerCapture(e.pointerId);
          e.preventDefault();
        }
        function onPointerMove(e) {
          if (!dragging || e.pointerId !== pointerId) return;
          updateThumb(e.clientX - center.x, e.clientY - center.y);
          e.preventDefault();
        }
        function onPointerUp(e) {
          if (e.pointerId !== pointerId) return;
          resetThumb();
          container.releasePointerCapture(e.pointerId);
          e.preventDefault();
        }
        function onTouchStart(e) {
          if (e.targetTouches.length > 0) {
            dragging = true;
            joystickObj.active = true;
            const touch = e.targetTouches[0];
            activeTouchId = touch.identifier;
            const rect = container.getBoundingClientRect();
            center.x = rect.left + rect.width / 2;
            center.y = rect.top + rect.height / 2;
            updateThumb(touch.clientX - center.x, touch.clientY - center.y);
            e.preventDefault();
          }
        }
        function onTouchMove(e) {
          if (!dragging || activeTouchId === null) return;
          let targetTouch = null;
          for (let i = 0; i < e.touches.length; i++) {
            if (e.touches[i].identifier === activeTouchId) { targetTouch = e.touches[i]; break; }
          }
          if (targetTouch) { updateThumb(targetTouch.clientX - center.x, targetTouch.clientY - center.y); }
          e.preventDefault();
        }
        function onTouchEnd(e) {
          for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === activeTouchId) { resetThumb(); break; }
          }
          e.preventDefault();
        }
        container.addEventListener("touchcancel", onTouchEnd, { passive: false });
        if (window.PointerEvent) {
          container.addEventListener("pointerdown", onPointerDown, { passive: false });
          container.addEventListener("pointermove", onPointerMove, { passive: false });
          container.addEventListener("pointerup", onPointerUp, { passive: false });
          container.addEventListener("pointercancel", onPointerUp, { passive: false });
        }
        container.addEventListener("touchstart", onTouchStart, { passive: false });
        container.addEventListener("touchmove", onTouchMove, { passive: false });
        container.addEventListener("touchend", onTouchEnd, { passive: false });
      }
      
      // --- Joystick Label Active Color Updates ---
      function updateLeftJoystickLabels() {
        const upLabel = document.querySelector("#leftJoystick .label-top");
        const downLabel = document.querySelector("#leftJoystick .label-bottom");
        const leftLabel = document.querySelector("#leftJoystick .label-left");
        const rightLabel = document.querySelector("#leftJoystick .label-right");
        upLabel.style.color = "black";
        downLabel.style.color = "black";
        leftLabel.style.color = "black";
        rightLabel.style.color = "black";
        if (leftJoystickInput.dy < -0.1) { upLabel.style.color = "green"; }
        else if (leftJoystickInput.dy > 0.1) { downLabel.style.color = "green"; }
        if (leftJoystickInput.dx < -0.1) { leftLabel.style.color = "green"; }
        else if (leftJoystickInput.dx > 0.1) { rightLabel.style.color = "green"; }
      }
      function updateRightJoystickLabels() {
        const upLabel = document.querySelector("#rightJoystick .label-top");
        const downLabel = document.querySelector("#rightJoystick .label-bottom");
        const leftLabel = document.querySelector("#rightJoystick .label-left");
        const rightLabel = document.querySelector("#rightJoystick .label-right");
        upLabel.style.color = "black";
        downLabel.style.color = "black";
        leftLabel.style.color = "black";
        rightLabel.style.color = "black";
        if (rightJoystickInput.dy < -0.1) { upLabel.style.color = "orange"; }
        else if (rightJoystickInput.dy > 0.1) { downLabel.style.color = "orange"; }
        if (rightJoystickInput.dx < -0.1) { leftLabel.style.color = "orange"; }
        else if (rightJoystickInput.dx > 0.1) { rightLabel.style.color = "orange"; }
      }
      
      // --- Top View Navigation ---
      let topViewTarget = new THREE.Vector3(0, 0, 0);
      const topViewHeight = 1000;
      const topViewStep = 20;
      document.getElementById("topArrowUp").addEventListener("click", function () {
        topViewTarget.z -= topViewStep;
        topViewCamera.position.set(topViewTarget.x, topViewHeight, topViewTarget.z);
        topViewCamera.lookAt(topViewTarget);
      });
      document.getElementById("topArrowDown").addEventListener("click", function () {
        topViewTarget.z += topViewStep;
        topViewCamera.position.set(topViewTarget.x, topViewHeight, topViewTarget.z);
        topViewCamera.lookAt(topViewTarget);
      });
      document.getElementById("topArrowLeft").addEventListener("click", function () {
        topViewTarget.x -= topViewStep;
        topViewCamera.position.set(topViewTarget.x, topViewHeight, topViewTarget.z);
        topViewCamera.lookAt(topViewTarget);
      });
      document.getElementById("topArrowRight").addEventListener("click", function () {
        topViewTarget.x += topViewStep;
        topViewCamera.position.set(topViewTarget.x, topViewHeight, topViewTarget.z);
        topViewCamera.lookAt(topViewTarget);
      });
      document.getElementById("homeView").addEventListener("click", function () {
        topViewTarget.set(0, 0, 0);
        topViewCamera.position.set(0, topViewHeight, 0);
        topViewCamera.lookAt(topViewTarget);
      });
      
      // --- Global Variables & Translations ---
      let currentExpectedHoop = 1;
      let landedAtHome = false;
      let takenOff = false;
      let allHoopsPassed = false;
      let currentLanguage = "en";
      
      // Reference to the RTH button.
      let rthBtn = document.getElementById("rthBtn");
      
      const translations = {
        en: {
          title: "Quadcopter Flight Simulation",
          allHoopsPassed: "All hoops passed! Now fly back and land on the home point (marked with H).",
          landingMessage: "Congratulations! You landed safely at home.<br><button id='newGameButton' class='btn-default'>New Game</button>",
          reset: "Reset",
          showFlightPath: "Show Flight Path",
          hideFlightPath: "Hide Flight Path",
          throttleUp: "Throttle Up",
          throttleDown: "Throttle Down",
          yawLeft: "Yaw Left",
          yawRight: "Yaw Right",
          pitchForward: "Pitch Forward",
          pitchBackward: "Pitch Backward",
          rollLeft: "Roll Left",
          rollRight: "Roll Right",
          zoomIn: "Zoom In",
          zoomOut: "Zoom Out",
          altitude: "Altitude",
          distance: "Distance"
        },
        zh: {
          title: "四軸無人機飛行模擬",
          allHoopsPassed: "所有環門已通過！請飛回並在以「H」標示的起飛點著陸。",
          landingMessage: "恭喜！您已安全降落在起飛點。<br><button id='newGameButton' class='btn-default'>新遊戲</button>",
          reset: "重置",
          showFlightPath: "顯示飛行路徑",
          hideFlightPath: "隱藏飛行路徑",
          throttleUp: "上升",
          throttleDown: "下降",
          yawLeft: "左轉",
          yawRight: "右轉",
          pitchForward: "前飛",
          pitchBackward: "後飛",
          rollLeft: "左飛",
          rollRight: "右飛",
          zoomIn: "放大",
          zoomOut: "縮小",
          altitude: "高度",
          distance: "距離"
        }
      };
      
      function updateUIText() {
        document.getElementById("title").innerHTML = translations[currentLanguage].title;
        document.getElementById("btn-reset").innerHTML = translations[currentLanguage].reset;
        const flightToggle = document.getElementById("toggleFlightPath");
        if (flightToggle) {
          flightToggle.innerHTML = flightPathActive
            ? translations[currentLanguage].hideFlightPath
            : translations[currentLanguage].showFlightPath;
        }
        document.querySelector("#leftJoystick .label-top").textContent =
          translations[currentLanguage].throttleUp;
        document.querySelector("#leftJoystick .label-bottom").textContent =
          translations[currentLanguage].throttleDown;
        document.querySelector("#leftJoystick .label-left").textContent =
          translations[currentLanguage].yawLeft;
        document.querySelector("#leftJoystick .label-right").textContent =
          translations[currentLanguage].yawRight;
        document.querySelector("#rightJoystick .label-top").textContent =
          translations[currentLanguage].pitchForward;
        document.querySelector("#rightJoystick .label-bottom").textContent =
          translations[currentLanguage].pitchBackward;
        document.querySelector("#rightJoystick .label-left").textContent =
          translations[currentLanguage].rollLeft;
        document.querySelector("#rightJoystick .label-right").textContent =
          translations[currentLanguage].rollRight;
        document.getElementById("zoomIn").innerHTML =
          translations[currentLanguage].zoomIn;
        document.getElementById("zoomOut").innerHTML =
          translations[currentLanguage].zoomOut;
      }
      
      document.getElementById("langToggle").addEventListener("click", function () {
        if (currentLanguage === "en") {
          currentLanguage = "zh";
          this.innerHTML = "English";
        } else {
          currentLanguage = "en";
          this.innerHTML = "繁體中文";
        }
        updateUIText();
      });
      
      // --- Main Renderer Setup ---
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x87ceeb);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // --- Top View Renderer & Orthographic Camera ---
      const topViewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      topViewRenderer.setSize(200, 200);
      topViewRenderer.setClearColor(0x000000, 0);
      const topViewDiv = document.getElementById("topViewRenderer");
      topViewDiv.appendChild(topViewRenderer.domElement);
      const d = 400;
      const topViewCamera = new THREE.OrthographicCamera(-d, d, d, -d, 0.1, 2000);
      topViewCamera.position.set(topViewTarget.x, topViewHeight, topViewTarget.z);
      topViewCamera.lookAt(topViewTarget);
      topViewCamera.zoom = 5;
      topViewCamera.updateProjectionMatrix();
      
      document.getElementById("zoomIn").addEventListener("click", () => {
        topViewCamera.zoom *= 1.1;
        topViewCamera.updateProjectionMatrix();
      });
      document.getElementById("zoomOut").addEventListener("click", () => {
        topViewCamera.zoom /= 1.1;
        topViewCamera.updateProjectionMatrix();
      });
      
      // --- Ground & Grid ---
      const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xededed });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      const grid = new THREE.GridHelper(1000, 50, 0x000000, 0x000000);
      scene.add(grid);
      
      // --- Home Marker ---
      const homeMarker = createHomeMarker();
      scene.add(homeMarker);
      
      // --- Lighting ---
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 200, 100);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.bias = -0.001;
      scene.add(directionalLight);
      
      // --- Drone Setup ---
      const droneGroup = new THREE.Group();
      droneGroup.rotation.order = "YXZ";
      scene.add(droneGroup);
      const drone = {
        position: new THREE.Vector3(0, 0.45, 0),
        yaw: 0,
        pitch: 0,
        roll: 0
      };
      const droneBodyGeometry = new THREE.BoxGeometry(1, 0.3, 1);
      const droneBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
      const droneBody = new THREE.Mesh(droneBodyGeometry, droneBodyMaterial);
      droneGroup.add(droneBody);
      function createDroneLabel(text) {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = "bold 150px Arial";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.center = new THREE.Vector2(0.5, 0.5);
        texture.rotation = Math.PI;
        texture.needsUpdate = true;
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const geometry = new THREE.PlaneGeometry(0.9, 0.3);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.set(0, 0.15 + 0.01, 0);
        return mesh;
      }
      const label = createDroneLabel("EdUHK");
      droneGroup.add(label);
      
      // --- Propellers Setup ---
      const propellerGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.9);
      const propellers = [];
      const frontLeft = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color: 0xff0000 }));
      frontLeft.position.set(-0.50, 0.2, 0.55);
      droneGroup.add(frontLeft);
      propellers.push({ mesh: frontLeft, spinSpeed: +10, defaultAngle: THREE.Math.degToRad(45), currentSpinSpeed: +10 });
      const frontRight = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color: 0xff0000 }));
      frontRight.position.set(0.50, 0.2, 0.55);
      droneGroup.add(frontRight);
      propellers.push({ mesh: frontRight, spinSpeed: -10, defaultAngle: THREE.Math.degToRad(135), currentSpinSpeed: -10 });
      const rearLeft = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color: 0x00ff00 }));
      rearLeft.position.set(-0.50, 0.2, -0.55);
      droneGroup.add(rearLeft);
      propellers.push({ mesh: rearLeft, spinSpeed: -10, defaultAngle: THREE.Math.degToRad(135), currentSpinSpeed: -10 });
      const rearRight = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color: 0x00ff00 }));
      rearRight.position.set(0.50, 0.2, -0.55);
      droneGroup.add(rearRight);
      propellers.push({ mesh: rearRight, spinSpeed: +10, defaultAngle: THREE.Math.degToRad(45), currentSpinSpeed: +10 });
      droneGroup.scale.set(3, 3, 3);
      droneGroup.traverse(child => { if (child instanceof THREE.Mesh) child.castShadow = true; });
      
      // --- Blinking Spots on Propellers ---
      const blinkSphereGeometry = new THREE.SphereGeometry(0.08, 16, 16);
      propellers.forEach((prop, index) => {
        const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const blinkSpot = new THREE.Mesh(blinkSphereGeometry, mat);
        blinkSpot.position.set(0, 0, 0);
        prop.mesh.add(blinkSpot);
        prop.blinkOffset = index * (Math.PI / 2);
        prop.blinkSpot = blinkSpot;
      });
      
      // --- Hoops Setup ---
      const totalHoops = 10;
      const altitudes = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55];
      function createHoopLabel(number) {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "yellow";
        ctx.font = "Bold 120px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(number.toString(), canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(4, 4, 1);
        return sprite;
      }
      function createHoop(number) {
        const mainRadius = 9;
        const tubeRadius = 0.2;
        const radialSegments = 16;
        const tubularSegments = 100;
        const geometry = new THREE.TorusGeometry(mainRadius, tubeRadius, radialSegments, tubularSegments);
        const material = new THREE.MeshLambertMaterial({ color: 0xffa500 });
        const hoopMesh = new THREE.Mesh(geometry, material);
        if (number <= 5) { hoopMesh.rotation.set(0, 0, 0); }
        else { hoopMesh.rotation.set(0, Math.PI / 2, 0); }
        const labelSprite = createHoopLabel(number);
        labelSprite.position.set(0, mainRadius + 2, 0);
        hoopMesh.add(labelSprite);
        return {
          mesh: hoopMesh,
          mainRadius: mainRadius,
          tubeRadius: tubeRadius,
          entered: false,
          passed: false,
          number: number,
          labelSprite: labelSprite
        };
      }
      const hoops = [];
      for (let i = 0; i < totalHoops; i++) {
        const hoop = createHoop(i + 1);
        hoop.mesh.position.set((Math.random() - 0.5) * 160, altitudes[i], (Math.random() - 0.5) * 160);
        scene.add(hoop.mesh);
        hoops.push(hoop);
      }
      
      // --- User Input ---
      let translationSpeed = 50;
      const yawSpeed = 1.0;
      const throttleSpeed = 10;
      const maxTilt = 0.5 * Math.PI / 6;
      // Use a dead zone threshold for joystick throttle input to avoid accidental touches.
      const throttleDeadZone = 0.2;
      const leftJoystickInput = { dx: 0, dy: 0 };
      const rightJoystickInput = { dx: 0, dy: 0 };
      attachJoystick("leftJoystick", leftJoystickInput);
      attachJoystick("rightJoystick", rightJoystickInput);
      const keys = {};
      document.addEventListener("keydown", e => { keys[e.code] = true; });
      document.addEventListener("keyup", e => { keys[e.code] = false; });
      const speedSlider = document.getElementById("speedSlider");
      speedSlider.addEventListener("input", function () { translationSpeed = parseFloat(this.value); });
      
      let flightPathActive = false;
      // Toggle flight path visibility and reset points when toggled.
      const toggleFlightPathBtn = document.getElementById("toggleFlightPath");
      toggleFlightPathBtn.addEventListener("click", function () {
        flightPathActive = !flightPathActive;
        if (flightPathActive) {
          toggleFlightPathBtn.innerHTML = translations[currentLanguage].hideFlightPath;
          flightPathPoints = [];
          if (flightPathLine) { scene.remove(flightPathLine); flightPathLine = null; }
        } else {
          toggleFlightPathBtn.innerHTML = translations[currentLanguage].showFlightPath;
          if (flightPathLine) { scene.remove(flightPathLine); flightPathLine = null; }
        }
      });
      
      // RTH Button event listener: ignore if altitude is less than 1.
      document.getElementById("rthBtn").addEventListener("click", function () {
        if (drone.position.y < 1) { return; }
        // Stop flyAudio immediately.
        if (flyAudioPlaying) {
          flyAudio.pause();
          flyAudio.currentTime = 0;
          flyAudioPlaying = false;
        }
        rthActive = true;
        this.style.backgroundColor = "grey";
        const msgDiv = document.getElementById("message");
        msgDiv.style.display = "block";
        msgDiv.innerHTML = "Return-to-Home in Progress";
        msgDiv.classList.add("blinking");
      });
      
      function syncJoystickWithKeyboard() {
        if (!leftJoystickInput.active) {
          let leftKbDx = 0, leftKbDy = 0;
          if (keys["KeyW"]) leftKbDy = -1;
          if (keys["KeyS"]) leftKbDy = 1;
          if (keys["KeyA"]) leftKbDx = -1;
          if (keys["KeyD"]) leftKbDx = 1;
          leftJoystickInput.dx = leftKbDx;
          leftJoystickInput.dy = leftKbDy;
          const leftThumb = document.querySelector("#leftJoystick .joystick-thumb");
          leftThumb.style.transform = (leftKbDx !== 0 || leftKbDy !== 0)
            ? `translate(${(leftKbDx * 40) - 40}px, ${(leftKbDy * 40) - 40}px)`
            : "translate(-50%, -50%)";
        }
        if (!rightJoystickInput.active) {
          let rightKbDx = 0, rightKbDy = 0;
          if (keys["ArrowUp"]) rightKbDy = -1;
          if (keys["ArrowDown"]) rightKbDy = 1;
          if (keys["ArrowLeft"]) rightKbDx = -1;
          if (keys["ArrowRight"]) rightKbDx = 1;
          rightJoystickInput.dx = rightKbDx;
          rightJoystickInput.dy = rightKbDy;
          const rightThumb = document.querySelector("#rightJoystick .joystick-thumb");
          rightThumb.style.transform = (rightKbDx !== 0 || rightKbDy !== 0)
            ? `translate(${(rightKbDx * 40) - 40}px, ${(rightKbDy * 40) - 40}px)`
            : "translate(-50%, -50%)";
        }
      }
      
      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
      
        // If RTH is active, ensure flyAudio stops.
        if (rthActive && flyAudioPlaying) {
          flyAudio.pause();
          flyAudio.currentTime = 0;
          flyAudioPlaying = false;
        }
      
        if (rthActive) {
          // Disable manual controls during RTH.
          const msgDiv = document.getElementById("message");
          const hDist = new THREE.Vector2(drone.position.x, drone.position.z).length();
          if (hDist > 1) {
            msgDiv.innerHTML = "Return-to-Home in Progress";
            msgDiv.classList.add("blinking");
            if (!rthAudioPlaying) {
              rthAudio.play().catch(err => console.log("RTH audio error", err));
              rthAudioPlaying = true;
            }
            const dir = new THREE.Vector3(-drone.position.x, 0, -drone.position.z).normalize();
            const desiredYaw = Math.atan2(dir.x, dir.z);
            drone.yaw = lerp(drone.yaw, desiredYaw, 0.05);
            drone.position.x += dir.x * 30 * delta;
            drone.position.z += dir.z * 30 * delta;
          } else {
            msgDiv.innerHTML = "Automatic Landing";
            msgDiv.classList.remove("blinking");
            if (rthAudioPlaying) {
              rthAudio.pause();
              rthAudio.currentTime = 0;
              rthAudioPlaying = false;
            }
            // Play land1.mp3 when above the home marker (and only if already in flight).
            if (!landAudioPlayed && Math.abs(drone.position.x) < 2 && Math.abs(drone.position.z) < 2 && takenOff) {
              setTimeout(function() {
                landAudio.play().catch(err => console.log("land audio error", err));
              }, 100);
              landAudioPlayed = true;
            }
            // Automatic descent.
            if (drone.position.y > 0.45) {
              drone.position.y -= 5 * delta;
            }
            drone.yaw = lerp(drone.yaw, 0, 0.05);
            drone.pitch = lerp(drone.pitch, 0, 0.1);
            drone.roll = lerp(drone.roll, 0, 0.1);
            if (drone.position.y <= 0.45 + 0.01) {
              drone.position.y = 0.45;
              landAudio.pause();
              landAudio.currentTime = 0;
              rthActive = false;
              msgDiv.style.display = "none";
              rthBtn.style.backgroundColor = "#2196f3";
              rthAudioPlaying = false;
              landAudioPlayed = false;
            }
          }
        } else {
          syncJoystickWithKeyboard();
          // Use a dead zone: throttle input only if |dy| >= threshold.
          let rawThrottle = (-leftJoystickInput.dy) + ((keys["KeyW"] ? 1 : 0) - (keys["KeyS"] ? 1 : 0));
          let throttleInput = Math.abs(rawThrottle) >= throttleDeadZone ? rawThrottle : 0;
          drone.position.y += throttleInput * throttleSpeed * delta;
          if (drone.position.y < 0.45) drone.position.y = 0.45;
      
          // Set takenOff only if throttle input was significant and altitude > 1.0.
          if (!takenOff && throttleInput !== 0 && drone.position.y > 1.0) {
            takenOff = true;
          }
      
          if (drone.position.y > 0.45) {
            let yawInput = (-leftJoystickInput.dx) + ((keys["KeyA"] ? 1 : 0) - (keys["KeyD"] ? 1 : 0));
            drone.yaw += yawSpeed * yawInput * delta;
            let pitchInput = (-rightJoystickInput.dy) + ((keys["ArrowUp"] ? 1 : 0) - (keys["ArrowDown"] ? 1 : 0));
            let desiredPitch = pitchInput * maxTilt;
            drone.pitch = lerp(drone.pitch, desiredPitch, 0.1);
            let rollInput = rightJoystickInput.dx + ((keys["ArrowRight"] ? 1 : 0) - (keys["ArrowLeft"] ? 1 : 0));
            let desiredRoll = -rollInput * maxTilt;
            drone.roll = lerp(drone.roll, desiredRoll, 0.1);
            const forwardDir = new THREE.Vector3(Math.sin(drone.yaw), 0, Math.cos(drone.yaw));
            const rightDir = new THREE.Vector3(Math.cos(drone.yaw), 0, -Math.sin(drone.yaw));
            const horizontalDisplacement = new THREE.Vector3();
            horizontalDisplacement.add(forwardDir.multiplyScalar(Math.sin(drone.pitch)))
                                   .add(rightDir.multiplyScalar(Math.sin(drone.roll)));
            horizontalDisplacement.multiplyScalar(translationSpeed * delta);
            drone.position.add(horizontalDisplacement);
          } else {
            drone.yaw = 0;
            drone.pitch = 0;
            drone.roll = 0;
          }
      
          if (drone.position.y > 1.0) {
            if (!flyAudioPlaying) {
              flyAudio.play().catch(err => console.log("Error playing flyAudio", err));
              flyAudioPlaying = true;
              flyAudio.volume = 0;
            }
            if (flyAudio.volume < 1.0) {
              flyAudio.volume = Math.min(1.0, flyAudio.volume + delta * 0.5);
            }
          } else {
            if (flyAudioPlaying) {
              flyAudio.pause();
              flyAudio.currentTime = 0;
              flyAudioPlaying = false;
            }
          }
        }
      
        droneGroup.position.copy(drone.position);
        // Apply rotations
        droneGroup.rotation.set(drone.pitch, drone.yaw, -drone.roll);
      
        propellers.forEach(prop => {
          if (drone.position.y > 0.45) { 
            prop.currentSpinSpeed = prop.spinSpeed; 
          } else { 
            prop.currentSpinSpeed = lerp(prop.currentSpinSpeed, 0, 2.0 * delta); 
          }
          prop.mesh.rotation.y += prop.currentSpinSpeed * delta;
          let blinkTime = clock.getElapsedTime() * 5 + prop.blinkOffset;
          prop.blinkSpot.visible = Math.sin(blinkTime) > 0;
        });
      
        hoops.forEach(hoop => {
          const dToHoop = drone.position.distanceTo(hoop.mesh.position);
          if (!hoop.entered && dToHoop < hoop.mainRadius) {
            hoop.entered = true;
          }
          if (hoop.entered && !hoop.passed && dToHoop > hoop.mainRadius * 1.1 && takenOff) {
            if (hoop.number === currentExpectedHoop) {
              hoop.passed = true;
              hoop.mesh.material.color.set(0x00ff00);
              bonusSound.play().catch(err => console.log("Error playing bonusSound:", err));
              currentExpectedHoop++;
              const cell = document.getElementById("hoopCell-" + hoop.number);
              if (cell) cell.classList.add("passed");
              const canvas = hoop.labelSprite.material.map.image;
              const ctx = canvas.getContext("2d");
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.fillStyle = "green";
              ctx.font = "Bold 80px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(hoop.number.toString(), canvas.width / 2, canvas.height / 2);
              hoop.labelSprite.material.map.needsUpdate = true;
            }
            hoop.entered = false;
          }
        });
      
        if (!allHoopsPassed) {
          let passedCount = 0;
          hoops.forEach(hoop => { if (hoop.passed) passedCount++; });
          if (passedCount === totalHoops) {
            allHoopsPassed = true;
            const msgDiv = document.getElementById("message");
            msgDiv.style.display = "block";
            msgDiv.innerHTML = translations[currentLanguage].allHoopsPassed;
          }
        }
      
        // Once mission completed and not yet landed, check for landing:
        if (allHoopsPassed && !landedAtHome) {
          const dX = drone.position.x;
          const dZ = drone.position.z;
          const distToHome = Math.sqrt(dX * dX + dZ * dZ);
          if (distToHome < 10 && drone.position.y < 1 && takenOff) {
            landedAtHome = true;
            const msgDiv = document.getElementById("message");
            msgDiv.innerHTML = translations[currentLanguage].landingMessage;
            document.getElementById("newGameButton").addEventListener("click", () => { resetDrone(); });
            sweetSound.play().catch(err => console.log("Error playing sweetSound:", err));
            if (homeMarker && homeMarker.userData && homeMarker.userData.ctx) {
              drawHomeMarker(homeMarker.userData.ctx, "yellow");
              homeMarker.userData.texture.needsUpdate = true;
            }
          }
        }
      
        // Update camera
        const cameraOffset = new THREE.Vector3(0, 5, -15);
        const quat = new THREE.Quaternion();
        quat.setFromEuler(new THREE.Euler(0, drone.yaw, 0));
        const rotatedOffset = cameraOffset.clone().applyQuaternion(quat);
        camera.position.copy(drone.position.clone().add(rotatedOffset));
        camera.lookAt(drone.position);
      
        const alt = (drone.position.y - 0.45).toFixed(1);
        const dist = Math.sqrt(drone.position.x * drone.position.x + drone.position.z * drone.position.z).toFixed(1);
        document.getElementById("info").textContent =
          translations[currentLanguage].altitude + ": " + alt + " | " +
          translations[currentLanguage].distance + ": " + dist;
      
        // Recover Flight Path drawing in top view.
        if (flightPathActive && takenOff) {
          flightPathPoints.push(drone.position.clone());
          // Limit points to avoid memory growth
          if(flightPathPoints.length > 500) {
            flightPathPoints.shift();
          }
          if (flightPathLine) scene.remove(flightPathLine);
          const geometry = new THREE.BufferGeometry().setFromPoints(flightPathPoints);
          const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
          flightPathLine = new THREE.Line(geometry, material);
          scene.add(flightPathLine);
        }
      
        renderer.render(scene, camera);
        topViewRenderer.render(scene, topViewCamera);
      }
      animate();
      
      function resetDrone() {
        drone.position.set(0, 0.45, 0);
        drone.yaw = 0;
        drone.pitch = 0;
        drone.roll = 0;
        takenOff = false;
        landedAtHome = false;
        allHoopsPassed = false;
        currentExpectedHoop = 1;
        flightPathPoints = [];
        if (flightPathLine) { scene.remove(flightPathLine); flightPathLine = null; }
        leftJoystickInput.dx = 0;
        leftJoystickInput.dy = 0;
        document.querySelector("#leftJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
        rightJoystickInput.dx = 0;
        rightJoystickInput.dy = 0;
        document.querySelector("#rightJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
        hoops.forEach(hoop => {
          hoop.entered = false;
          hoop.passed = false;
          hoop.mesh.material.color.set(0xffa500);
          const canvas = hoop.labelSprite.material.map.image;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "yellow";
          ctx.font = "Bold 80px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(hoop.number.toString(), canvas.width / 2, canvas.height / 2);
          hoop.labelSprite.material.map.needsUpdate = true;
        });
        if (homeMarker && homeMarker.userData && homeMarker.userData.ctx) {
          drawHomeMarker(homeMarker.userData.ctx, "white");
          homeMarker.userData.texture.needsUpdate = true;
        }
        document.getElementById("message").style.display = "none";
        for (let i = 1; i <= totalHoops; i++) {
          const cell = document.getElementById("hoopCell-" + i);
          if (cell) cell.classList.remove("passed");
        }
        rthBtn.style.backgroundColor = "#2196f3";
        rthAudioPlaying = false;
        landAudioPlayed = false;
        updateUIText();
      }
      document.getElementById("btn-reset").addEventListener("click", resetDrone);
      
      updateUIText();
    </script>
  </body>
</html>
