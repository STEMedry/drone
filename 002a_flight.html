<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- Meta viewport for responsiveness -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Quadcopter Flight Simulation</title>
    <style>
      /* Basic styling and prevent zoom/scroll */
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        touch-action: none;
        -ms-touch-action: none;
        user-select: none;
        -webkit-user-select: none;
      }
      canvas {
        display: block;
      }
      /* Title */
      #title {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 32px;
        font-weight: bold;
        text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
        z-index: 100;
      }
      /* Language Toggle Button */
      #langToggle {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 110;
        padding: 8px 12px;
        font-size: 16px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        background-color: #4caf50;
        color: white;
      }
      /* General message (for RTH, landing, etc.) */
      #message {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        font-size: 24px;
        border-radius: 5px;
        z-index: 110;
        display: none;
      }
      @keyframes blinking {
        0% { opacity: 1; }
        50% { opacity: 0; }
        100% { opacity: 1; }
      }
      .blinking {
        animation: blinking 1s infinite;
      }
      /* Controls container */
      #controls {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        background: rgba(255, 255, 255, 0.8);
        padding: 20px;
        border-radius: 5px;
        width: 1000px;
        height: 220px;
      }
      /* Info box */
      #info {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 18px;
        color: red;
        font-weight: bold;
      }
      #btn-reset {
        position: absolute;
        bottom: 10px;
        right: 480px;
        width: 80px;
        height: 40px;
        padding: 10px;
        font-size: 18px;
        font-weight: bold;
        border: none;
        border-radius: 5px;
      }
      /* Main control layout (slider and joysticks) */
      #main-controls {
        display: flex;
        align-items: center;
        gap: 100px;
      }
      /* Speed slider container */
      #speedContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        transform: translateY(-60px);
      }
      #speedLabel {
        font-size: 18px;
        font-weight: bold;
      }
      #speedSlider {
        width: 200px;
      }
      /* Toggle Flight Path & RTH Button */
      #toggleFlightPath {
        font-size: 16px;
        padding: 10px 20px;
      }
      #rthBtn {
        font-size: 16px;
        padding: 10px 20px;
        margin-top: 5px;
      }
      /* Virtual Joystick Styles */
      .joystick-container {
        width: 300px;
        height: 300px;
        position: relative;
        touch-action: none;
        -ms-touch-action: none;
      }
      .joystick-base {
        width: 200px;
        height: 200px;
        background: rgba(76, 175, 80, 0.5);
        border: 2px solid #aaa;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        top: 40%;
        transform: translate(-50%, -50%);
      }
      .joystick-thumb {
        width: 80px;
        height: 80px;
        border: 2px solid #555;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        top: 40%;
        transform: translate(-50%, -50%);
        touch-action: none;
        -ms-touch-action: none;
      }
      #leftJoystick .joystick-thumb {
        background-color: #006400;
      }
      #rightJoystick .joystick-thumb {
        background-color: #FF8C00;
      }
      #rightJoystick .joystick-base {
        background: rgba(255, 152, 0, 0.5);
      }
      .joystick-label {
        position: absolute;
        font-size: 16px;
        color: black;
        font-weight: bold;
        pointer-events: none;
      }
      /* Left joystick labels */
      #leftJoystick .label-top {
        top: 0px;
        left: 50%;
        transform: translateX(-50%);
      }
      #leftJoystick .label-bottom {
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
      }
      #leftJoystick .label-left {
        left: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      #leftJoystick .label-right {
        right: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      /* Right joystick labels */
      #rightJoystick .label-top {
        top: 0px;
        left: 50%;
        transform: translateX(-50%);
      }
      #rightJoystick .label-bottom {
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
      }
      #rightJoystick .label-left {
        left: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      #rightJoystick .label-right {
        right: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      /* Top View Container */
      #topViewContainer {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 30;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #topViewRenderer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        transform: rotate(180deg);
        background: none;
        position: relative;
      }
      .arrow-btn {
        position: absolute;
        background: rgba(200, 200, 200, 0.7);
        border: 1px solid #666;
        border-radius: 3px;
        font-size: 18px;
        padding: 5px;
        cursor: pointer;
      }
      #topArrowUp {
        top: 5px;
        left: 50%;
        transform: translateX(-50%);
      }
      #topArrowDown {
        bottom: 5px;
        left: 50%;
        transform: translateX(-50%);
      }
      #topArrowLeft {
        left: 5px;
        top: 50%;
        transform: translateY(-50%);
      }
      #topArrowRight {
        right: 5px;
        top: 50%;
        transform: translateY(-50%);
      }
      #zoomControls {
        margin-top: 5px;
        display: flex;
        gap: 10px;
      }
      /* Hoop Table */
      #hoopTable {
        position: absolute;
        top: 60px;
        right: 20px;
        z-index: 100;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border: 1px solid #ccc;
        display: grid;
        grid-template-columns: repeat(5, 30px);
        gap: 5px;
      }
      #hoopTable .hoopCell {
        width: 30px;
        height: 30px;
        line-height: 30px;
        text-align: center;
        font-weight: bold;
        background: yellow;
        border: 1px solid #000;
      }
      #hoopTable .hoopCell.passed {
        background: grey;
      }
      /* Stats Box */
      #statsBox {
        position: absolute;
        top: 160px;
        right: 20px;
        width: 220px;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border: 1px solid #ccc;
        font-family: Arial, sans-serif;
        font-weight: bold;
        font-size: 16px;
        text-align: left;
        line-height: 1.8;
      }
      /* New Game Button */
      #newGameButton {
        font-size: 24px;
        padding: 15px 25px;
        margin-top: 10px;
        border-radius: 8px;
        border: none;
        background-color: #2196f3;
        color: white;
        cursor: pointer;
      }
      /* Button Classes */
      .btn-green { background-color: #4caf50; color: white; }
      .btn-red { background-color: #f44336; color: white; }
      .btn-default { background-color: #2196f3; color: white; }
    </style>
  </head>
  <body>
    <!-- Title -->
    <div id="title">Quadcopter Flight Simulation</div>
    <!-- Language Toggle Button -->
    <button id="langToggle" class="btn-green">繁體中文</button>
    <!-- General Message -->
    <div id="message"></div>
    
    <!-- Top View Container -->
    <div id="topViewContainer">
      <div id="topViewRenderer">
        <!-- Arrow buttons inside top view renderer -->
        <button id="topArrowUp" class="arrow-btn">▲</button>
        <button id="topArrowDown" class="arrow-btn">▼</button>
        <button id="topArrowLeft" class="arrow-btn">◄</button>
        <button id="topArrowRight" class="arrow-btn">►</button>
      </div>
      <!-- Zoom Controls with "Home" Button -->
      <div id="zoomControls">
        <button id="zoomIn">Zoom In</button>
        <button id="homeView">Home</button>
        <button id="zoomOut">Zoom Out</button>
      </div>
    </div>
    
    <!-- Hoop Table -->
    <div id="hoopTable">
      <div class="hoopCell" id="hoopCell-1">1</div>
      <div class="hoopCell" id="hoopCell-2">2</div>
      <div class="hoopCell" id="hoopCell-3">3</div>
      <div class="hoopCell" id="hoopCell-4">4</div>
      <div class="hoopCell" id="hoopCell-5">5</div>
      <div class="hoopCell" id="hoopCell-6">6</div>
      <div class="hoopCell" id="hoopCell-7">7</div>
      <div class="hoopCell" id="hoopCell-8">8</div>
      <div class="hoopCell" id="hoopCell-9">9</div>
      <div class="hoopCell" id="hoopCell-10">10</div>
    </div>
    
    <!-- Stats Box -->
    <div id="statsBox">
      Total Flight Distance: 0<br>
      Horizontal Speed: 0<br>
      Flight Time: 0 s
    </div>
    
    <!-- Controls Container -->
    <div id="controls">
      <div id="info">Altitude: 0 | Distance: 0</div>
      <div id="main-controls">
        <!-- Left Virtual Joystick (Throttle & Yaw) -->
        <div class="joystick-container" id="leftJoystick">
          <div class="joystick-base"></div>
          <div class="joystick-thumb"></div>
          <span class="joystick-label label-top">Throttle Up</span>
          <span class="joystick-label label-bottom">Throttle Down</span>
          <span class="joystick-label label-left">Yaw Left</span>
          <span class="joystick-label label-right">Yaw Right</span>
        </div>
        <!-- Speed Slider, Flight Path Toggle, and RTH Button -->
        <div id="speedContainer">
          <div id="speedLabel">Speed</div>
          <input type="range" id="speedSlider" min="10" max="100" value="50" step="1" />
          <button id="toggleFlightPath" class="btn-default">Show Flight Path</button>
          <button id="rthBtn" class="btn-default">RTH</button>
        </div>
        <!-- Right Virtual Joystick (Pitch & Roll) -->
        <div class="joystick-container" id="rightJoystick">
          <div class="joystick-base"></div>
          <div class="joystick-thumb"></div>
          <span class="joystick-label label-top">Pitch Forward</span>
          <span class="joystick-label label-bottom">Pitch Backward</span>
          <span class="joystick-label label-left">Roll Left</span>
          <span class="joystick-label label-right">Roll Right</span>
        </div>
      </div>
      <button id="btn-reset" class="btn-red">Reset</button>
    </div>
    
    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // ------------------------------------
      // Global Variables and Helper Functions
      // ------------------------------------
      function lerp(a, b, t) {
        return a + (b - a) * t;
      }
      
      let disableDroneControls = false;
      let flightEnded = false;
      let takenOff = false;
      let rthActive = false;
      let currentExpectedHoop = 1;
      let landedAtHome = false;
      let allHoopsPassed = false;
      let totalDistance = 0;
      let totalFlightTime = 0;
      let previousPosition = null;
      
      // Audio objects for flight sounds
      const flyAudio = new Audio("flysound.mp3");
      flyAudio.loop = true;
      flyAudio.volume = 0;
      const bonusAudio = new Audio("bonus.mp3");
      bonusAudio.loop = false;
      const sweetAudio = new Audio("sweet.mp3");
      const rth12Audio = new Audio("rth12.mp3");
      const land1Audio = new Audio("land1.mp3");
      let flyAudioPlaying = false;
      
      // To unlock audio on iOS/iPad, add a one‑time touchstart that “primes” the audio elements.
      function initAudio() {
        [flyAudio, bonusAudio, sweetAudio].forEach(audioElem => {
          audioElem.play().then(() => {
            audioElem.pause();
            audioElem.currentTime = 0;
          }).catch(() => {});
        });
        document.removeEventListener("touchstart", initAudio);
      }
      document.addEventListener("touchstart", initAudio, false);
      
      // Helper: createDirectionSprite
      function createDirectionSprite(text, color = "black") {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = color;
        ctx.font = "bold 90px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(250, 250, 1);
        return sprite;
      }
      
      // Helper: createHoopLabel
      function createHoopLabel(number) {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "yellow";
        ctx.font = "Bold 120px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(number.toString(), canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(4, 4, 1);
        return sprite;
      }
      
      // Helper: Virtual Joystick
      function attachJoystick(containerId, joystickObj) {
        const container = document.getElementById(containerId);
        const thumb = container.querySelector(".joystick-thumb");
        let dragging = false, pointerId = null, activeTouchId = null;
        let center = { x: 0, y: 0 };
        const maxDist = 40;
        joystickObj.active = false;
        function updateThumb(dx, dy) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
          }
          joystickObj.dx = dx / maxDist;
          joystickObj.dy = dy / maxDist;
          thumb.style.transform = `translate(${dx - 40}px, ${dy - 40}px)`;
        }
        function resetThumb() {
          dragging = false;
          joystickObj.active = false;
          activeTouchId = null;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          thumb.style.transform = "translate(-50%, -50%)";
        }
        function onPointerDown(e) {
          if (e.pointerType === "mouse" && e.button !== 0) return;
          dragging = true;
          joystickObj.active = true;
          pointerId = e.pointerId;
          const rect = container.getBoundingClientRect();
          center.x = rect.left + rect.width / 2;
          center.y = rect.top + rect.height / 2;
          updateThumb(e.clientX - center.x, e.clientY - center.y);
          container.setPointerCapture(e.pointerId);
          e.preventDefault();
        }
        function onPointerMove(e) {
          if (!dragging || e.pointerId !== pointerId) return;
          updateThumb(e.clientX - center.x, e.clientY - center.y);
          e.preventDefault();
        }
        function onPointerUp(e) {
          if (e.pointerId !== pointerId) return;
          resetThumb();
          container.releasePointerCapture(e.pointerId);
          e.preventDefault();
        }
        function onTouchStart(e) {
          if (e.targetTouches.length > 0) {
            dragging = true;
            joystickObj.active = true;
            const touch = e.targetTouches[0];
            activeTouchId = touch.identifier;
            const rect = container.getBoundingClientRect();
            center.x = rect.left + rect.width / 2;
            center.y = rect.top + rect.height / 2;
            updateThumb(touch.clientX - center.x, touch.clientY - center.y);
            e.preventDefault();
          }
        }
        function onTouchMove(e) {
          if (!dragging || activeTouchId === null) return;
          let targetTouch = null;
          for (let i = 0; i < e.touches.length; i++) {
            if (e.touches[i].identifier === activeTouchId) {
              targetTouch = e.touches[i];
              break;
            }
          }
          if (targetTouch) {
            updateThumb(targetTouch.clientX - center.x, targetTouch.clientY - center.y);
          }
          e.preventDefault();
        }
        function onTouchEnd(e) {
          for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === activeTouchId) {
              resetThumb();
              break;
            }
          }
          e.preventDefault();
        }
        container.addEventListener("touchcancel", onTouchEnd, { passive: false });
        if (window.PointerEvent) {
          container.addEventListener("pointerdown", onPointerDown, { passive: false });
          container.addEventListener("pointermove", onPointerMove, { passive: false });
          container.addEventListener("pointerup", onPointerUp, { passive: false });
          container.addEventListener("pointercancel", onPointerUp, { passive: false });
        }
        container.addEventListener("touchstart", onTouchStart, { passive: false });
        container.addEventListener("touchmove", onTouchMove, { passive: false });
        container.addEventListener("touchend", onTouchEnd, { passive: false });
      }
      
      // ------------------------------------
      // Three.js Scene Setup
      // ------------------------------------
      const scene = new THREE.Scene();
      const northSprite = createDirectionSprite("NORTH");
      northSprite.position.set(0, 8, 540);
      scene.add(northSprite);
      const eastSprite = createDirectionSprite("EAST");
      eastSprite.position.set(-540, 8, 0);
      scene.add(eastSprite);
      const southSprite = createDirectionSprite("SOUTH");
      southSprite.position.set(0, 8, -540);
      scene.add(southSprite);
      const westSprite = createDirectionSprite("WEST");
      westSprite.position.set(540, 8, 0);
      scene.add(westSprite);
      
      // ------------------------------------
      // Home Marker Creation
      // ------------------------------------
      function drawHomeMarker(ctx, padColor) {
        ctx.clearRect(0, 0, 256, 256);
        ctx.fillStyle = padColor;
        ctx.beginPath();
        ctx.arc(128, 128, 120, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "black";
        ctx.lineWidth = 10;
        ctx.stroke();
        ctx.fillStyle = "black";
        ctx.font = "bold 100px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("H", 128, 128);
      }
      function createHomeMarker() {
        const canvas = document.createElement("canvas");
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext("2d");
        drawHomeMarker(ctx, "white");
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
        const geometry = new THREE.CircleGeometry(5, 32);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.set(0, 0.01, 0);
        mesh.userData = { canvas, ctx, texture };
        return mesh;
      }
      const homeMarker = createHomeMarker();
      scene.add(homeMarker);
      
      // ------------------------------------
      // Lighting
      // ------------------------------------
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 200, 100);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.bias = -0.001;
      scene.add(directionalLight);
      
      // ------------------------------------
      // Drone Setup
      // ------------------------------------
      const droneGroup = new THREE.Group();
      droneGroup.rotation.order = "YXZ";
      scene.add(droneGroup);
      const drone = {
        position: new THREE.Vector3(0, 0.45, 0),
        yaw: 0,
        pitch: 0,
        roll: 0
      };
      const droneBodyGeometry = new THREE.BoxGeometry(1, 0.3, 1);
      const droneBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
      const droneBody = new THREE.Mesh(droneBodyGeometry, droneBodyMaterial);
      droneGroup.add(droneBody);
      function createDroneLabel(text) {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = "bold 150px Arial";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.center = new THREE.Vector2(0.5, 0.5);
        texture.rotation = Math.PI;
        texture.needsUpdate = true;
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const geometry = new THREE.PlaneGeometry(0.9, 0.3);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.set(0, 0.15 + 0.01, 0);
        return mesh;
      }
      const label = createDroneLabel("EdUHK");
      droneGroup.add(label);
      
      // ------------------------------------
      // Drone Propellers Setup
      // ------------------------------------
      const propellerGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.9);
      const propellers = [];
      
      // Front Left Propeller
      const frontLeft = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color: 0xff0000 }));
      frontLeft.position.set(-0.50, 0.2, 0.55);
      droneGroup.add(frontLeft);
      propellers.push({ mesh: frontLeft, spinSpeed: +10, defaultAngle: THREE.Math.degToRad(45), currentSpinSpeed: +10 });
      
      // Front Right Propeller
      const frontRight = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color: 0xff0000 }));
      frontRight.position.set(0.50, 0.2, 0.55);
      droneGroup.add(frontRight);
      propellers.push({ mesh: frontRight, spinSpeed: -10, defaultAngle: THREE.Math.degToRad(135), currentSpinSpeed: -10 });
      
      // Rear Left Propeller
      const rearLeft = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color: 0x00ff00 }));
      rearLeft.position.set(-0.50, 0.2, -0.55);
      droneGroup.add(rearLeft);
      propellers.push({ mesh: rearLeft, spinSpeed: -10, defaultAngle: THREE.Math.degToRad(135), currentSpinSpeed: -10 });
      
      // Rear Right Propeller
      const rearRight = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color: 0x00ff00 }));
      rearRight.position.set(0.50, 0.2, -0.55);
      droneGroup.add(rearRight);
      propellers.push({ mesh: rearRight, spinSpeed: +10, defaultAngle: THREE.Math.degToRad(45), currentSpinSpeed: +10 });
      
      // Scale the drone group.
      droneGroup.scale.set(3, 3, 3);
      droneGroup.traverse(child => {
        if (child instanceof THREE.Mesh) child.castShadow = true;
      });
      
      // Add blinking spots on each propeller.
      const blinkSphereGeometry = new THREE.SphereGeometry(0.08, 16, 16);
      propellers.forEach((prop, index) => {
        const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const blinkSpot = new THREE.Mesh(blinkSphereGeometry, mat);
        blinkSpot.position.set(0, 0, 0);
        prop.mesh.add(blinkSpot);
        prop.blinkOffset = index * (Math.PI / 2);
        prop.blinkSpot = blinkSpot;
      });
      
      // ------------------------------------
      // Hoop Creation Functions
      // ------------------------------------
      
      // Circular Hoop
      function createCircularHoop(number) {
        const mainRadius = 9;
        const tubeRadius = 0.2;
        const geometry = new THREE.TorusGeometry(mainRadius, tubeRadius, 16, 100);
        const material = new THREE.MeshLambertMaterial({ color: 0xffa500 });
        const hoopMesh = new THREE.Mesh(geometry, material);
        const labelSprite = createHoopLabel(number);
        labelSprite.position.set(0, mainRadius + 2, 0);
        hoopMesh.add(labelSprite);
        return {
          mesh: hoopMesh,
          mainRadius: mainRadius,
          tubeRadius: tubeRadius,
          entered: false,
          passed: false,
          number: number,
          labelSprite: labelSprite,
          type: "circular",
          originalColor: 0xffa500
        };
      }
      
      // Square Hoop
      function createSquareHoop(number) {
        const outer = 9;
        const inner = outer - 0.2;
        const shape = new THREE.Shape();
        shape.moveTo(-outer, -outer);
        shape.lineTo(outer, -outer);
        shape.lineTo(outer, outer);
        shape.lineTo(-outer, outer);
        shape.lineTo(-outer, -outer);
        const hole = new THREE.Path();
        hole.moveTo(-inner, -inner);
        hole.lineTo(-inner, inner);
        hole.lineTo(inner, inner);
        hole.lineTo(inner, -inner);
        hole.lineTo(-inner, -inner);
        shape.holes.push(hole);
        const geometry = new THREE.ShapeGeometry(shape);
        const material = new THREE.MeshLambertMaterial({ color: 0xff69b4, side: THREE.DoubleSide });
        const hoopMesh = new THREE.Mesh(geometry, material);
        const labelSprite = createHoopLabel(number);
        labelSprite.position.set(0, outer + 2, 0);
        hoopMesh.add(labelSprite);
        return {
          mesh: hoopMesh,
          mainRadius: outer,
          tubeRadius: outer - inner,
          entered: false,
          passed: false,
          number: number,
          labelSprite: labelSprite,
          type: "square",
          originalColor: 0xff69b4
        };
      }
      
      // Triangular Hoop
      function createTriangleHoop(number) {
        const rOuter = 9;
        const rInner = rOuter - 0.2;
        const shape = new THREE.Shape();
        const outerVertices = [];
        for (let i = 0; i < 3; i++) {
          const theta = THREE.Math.degToRad(90 + i * 120);
          const x = rOuter * Math.cos(theta);
          const y = rOuter * Math.sin(theta);
          outerVertices.push(new THREE.Vector2(x, y));
        }
        shape.moveTo(outerVertices[0].x, outerVertices[0].y);
        shape.lineTo(outerVertices[1].x, outerVertices[1].y);
        shape.lineTo(outerVertices[2].x, outerVertices[2].y);
        shape.closePath();
      
        const hole = new THREE.Path();
        const innerVertices = [];
        for (let i = 0; i < 3; i++) {
          const theta = THREE.Math.degToRad(90 + i * 120);
          const x = rInner * Math.cos(theta);
          const y = rInner * Math.sin(theta);
          innerVertices.push(new THREE.Vector2(x, y));
        }
        hole.moveTo(innerVertices[innerVertices.length - 1].x, innerVertices[innerVertices.length - 1].y);
        for (let i = innerVertices.length - 2; i >= 0; i--) {
          hole.lineTo(innerVertices[i].x, innerVertices[i].y);
        }
        hole.closePath();
        shape.holes.push(hole);
      
        const geometry = new THREE.ShapeGeometry(shape);
        const material = new THREE.MeshLambertMaterial({ color: 0x800080, side: THREE.DoubleSide });
        const hoopMesh = new THREE.Mesh(geometry, material);
        const labelSprite = createHoopLabel(number);
        labelSprite.position.set(0, rOuter + 2, 0);
        hoopMesh.add(labelSprite);
        return {
          mesh: hoopMesh,
          mainRadius: rOuter,
          tubeRadius: rOuter - rInner,
          entered: false,
          passed: false,
          number: number,
          labelSprite: labelSprite,
          type: "triangle",
          originalColor: 0x800080
        };
      }
      
      // ------------------------------------
      // Hoops Setup (10 hoops: 4 circular, 3 square, 3 triangle)
      // ------------------------------------
      const altitudes = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55];
      const hoops = [];
      for (let i = 1; i <= 10; i++) {
        let hoop;
        if (i <= 4) {
          hoop = createCircularHoop(i);
        } else if (i <= 7) {
          hoop = createSquareHoop(i);
        } else {
          hoop = createTriangleHoop(i);
        }
        hoop.mesh.position.set((Math.random() - 0.5) * 160, altitudes[i - 1], (Math.random() - 0.5) * 160);
        scene.add(hoop.mesh);
        hoops.push(hoop);
      }
      
      // ------------------------------------
      // User Input Handling 
      // ------------------------------------
      let translationSpeed = 50;
      const yawSpeed = 1.0;
      const throttleSpeed = 10;
      const maxTilt = 0.5 * Math.PI / 6;
      const throttleDeadZone = 0.2;
      const leftJoystickInput = { dx: 0, dy: 0 };
      const rightJoystickInput = { dx: 0, dy: 0 };
      attachJoystick("leftJoystick", leftJoystickInput);
      attachJoystick("rightJoystick", rightJoystickInput);
      
      const keys = {};
      document.addEventListener("keydown", e => { keys[e.code] = true; });
      document.addEventListener("keyup", e => { keys[e.code] = false; });
      
      // Keyboard shortcuts for RTH ("H"), Flight Path ("P") and Reset ("R")
      document.addEventListener("keydown", (event) => {
        if (event.code === "KeyH") {
          document.getElementById("rthBtn").click();
        } else if (event.code === "KeyP") {
          document.getElementById("toggleFlightPath").click();
        } else if (event.code === "KeyR") {
          document.getElementById("btn-reset").click();
        }
      });
      
      const speedSlider = document.getElementById("speedSlider");
      speedSlider.addEventListener("input", function () {
        translationSpeed = parseFloat(this.value);
      });
      
      let flightPathActive = false;
      let flightPathPoints = [];
      let flightPathLine = null;
      const toggleFlightPathBtn = document.getElementById("toggleFlightPath");
      toggleFlightPathBtn.addEventListener("click", function () {
        flightPathActive = !flightPathActive;
        if (flightPathActive) {
          toggleFlightPathBtn.innerHTML = translations[currentLanguage].hideFlightPath;
          flightPathPoints = [];
          if (flightPathLine) {
            scene.remove(flightPathLine);
            flightPathLine = null;
          }
        } else {
          toggleFlightPathBtn.innerHTML = translations[currentLanguage].showFlightPath;
          if (flightPathLine) {
            scene.remove(flightPathLine);
            flightPathLine = null;
          }
        }
      });
      
      // ------------------------------------
      // RTH Button and Audio
      // ------------------------------------
      document.getElementById("rthBtn").addEventListener("click", function () {
        if (drone.position.y < 1) return;
        rthActive = true;
        this.style.backgroundColor = "grey";
        const msgDiv = document.getElementById("message");
        msgDiv.style.display = "block";
        msgDiv.innerHTML = translations[currentLanguage].rthInProgress;
        msgDiv.classList.add("blinking");
        if (rth12Audio.paused) {
          rth12Audio.currentTime = 0;
          rth12Audio.play().catch(err => console.log("Error playing rth12Audio:", err));
        }
        if (flyAudioPlaying) {
          flyAudio.pause();
          flyAudio.currentTime = 0;
          flyAudioPlaying = false;
        }
      });
      
      function syncJoystickWithKeyboard() {
        if (!leftJoystickInput.active) {
          let leftKbDx = 0, leftKbDy = 0;
          if (keys["KeyW"]) leftKbDy = -1;
          if (keys["KeyS"]) leftKbDy = 1;
          if (keys["KeyA"]) leftKbDx = -1;
          if (keys["KeyD"]) leftKbDx = 1;
          leftJoystickInput.dx = leftKbDx;
          leftJoystickInput.dy = leftKbDy;
          const leftThumb = document.querySelector("#leftJoystick .joystick-thumb");
          leftThumb.style.transform = (leftKbDx !== 0 || leftKbDy !== 0)
            ? `translate(${(leftKbDx * 40) - 40}px, ${(leftKbDy * 40) - 40}px)`
            : "translate(-50%, -50%)";
        }
        if (!rightJoystickInput.active) {
          let rightKbDx = 0, rightKbDy = 0;
          if (keys["ArrowUp"]) rightKbDy = -1;
          if (keys["ArrowDown"]) rightKbDy = 1;
          if (keys["ArrowLeft"]) rightKbDx = -1;
          if (keys["ArrowRight"]) rightKbDx = 1;
          rightJoystickInput.dx = rightKbDx;
          rightJoystickInput.dy = rightKbDy;
          const rightThumb = document.querySelector("#rightJoystick .joystick-thumb");
          rightThumb.style.transform = (rightKbDx !== 0 || rightKbDy !== 0)
            ? `translate(${(rightKbDx * 40) - 40}px, ${(rightKbDy * 40) - 40}px)`
            : "translate(-50%, -50%)";
        }
      }
      
      // ------------------------------------
      // Translations
      // ------------------------------------
      const translations = {
        en: {
          title: "Quadcopter Flight Simulation",
          allHoopsPassed: "All hoops passed! Now fly back and land on the home point (marked with H).",
          landingMessage: "Congratulations! You landed safely at home.<br><button id='newGameButton' class='btn-default'>New Game</button>",
          reset: "Reset",
          showFlightPath: "Show Flight Path",
          hideFlightPath: "Hide Flight Path",
          throttleUp: "Throttle Up",
          throttleDown: "Throttle Down",
          yawLeft: "Yaw Left",
          yawRight: "Yaw Right",
          pitchForward: "Pitch Forward",
          pitchBackward: "Pitch Backward",
          rollLeft: "Roll Left",
          rollRight: "Roll Right",
          zoomIn: "Zoom In",
          zoomOut: "Zoom Out",
          altitude: "Altitude",
          distance: "Distance",
          totalFlightDistance: "Total Flight Distance: ",
          flightSpeed: "Horizontal Speed: ",
          flightTime: "Flight Time: ",
          rthInProgress: "Return-to-Home in Progress",
          automaticLanding: "Automatic Landing"
        },
        zh: {
          title: "四軸無人機飛行模擬",
          allHoopsPassed: "所有環門已通過！請飛回並在以「H」標示的起飛點著陸。",
          landingMessage: "恭喜！您已安全降落在起飛點。<br><button id='newGameButton' class='btn-default'>新遊戲</button>",
          reset: "重置",
          showFlightPath: "顯示飛行路徑",
          hideFlightPath: "隱藏飛行路徑",
          throttleUp: "上升",
          throttleDown: "下降",
          yawLeft: "左轉",
          yawRight: "右轉",
          pitchForward: "前飛",
          pitchBackward: "後飛",
          rollLeft: "左飛",
          rollRight: "右飛",
          zoomIn: "放大",
          zoomOut: "縮小",
          altitude: "高度",
          distance: "距離",
          totalFlightDistance: "飛行總距離：",
          flightSpeed: "飛行速度：",
          flightTime: "飛行時間：",
          rthInProgress: "正在返航",
          automaticLanding: "自動降落"
        }
      };
      let currentLanguage = "en";
      function updateUIText() {
        document.getElementById("title").innerHTML = translations[currentLanguage].title;
        document.getElementById("btn-reset").innerHTML = translations[currentLanguage].reset;
        const flightToggle = document.getElementById("toggleFlightPath");
        if (flightToggle) {
          flightToggle.innerHTML = flightPathActive
            ? translations[currentLanguage].hideFlightPath
            : translations[currentLanguage].showFlightPath;
        }
        document.querySelector("#leftJoystick .label-top").textContent =
          translations[currentLanguage].throttleUp;
        document.querySelector("#leftJoystick .label-bottom").textContent =
          translations[currentLanguage].throttleDown;
        document.querySelector("#leftJoystick .label-left").textContent =
          translations[currentLanguage].yawLeft;
        document.querySelector("#leftJoystick .label-right").textContent =
          translations[currentLanguage].yawRight;
        document.querySelector("#rightJoystick .label-top").textContent =
          translations[currentLanguage].pitchForward;
        document.querySelector("#rightJoystick .label-bottom").textContent =
          translations[currentLanguage].pitchBackward;
        document.querySelector("#rightJoystick .label-left").textContent =
          translations[currentLanguage].rollLeft;
        document.querySelector("#rightJoystick .label-right").textContent =
          translations[currentLanguage].rollRight;
        document.getElementById("zoomIn").innerHTML =
          translations[currentLanguage].zoomIn;
        document.getElementById("zoomOut").innerHTML =
          translations[currentLanguage].zoomOut;
      }
      document.getElementById("langToggle").addEventListener("click", function () {
        if (currentLanguage === "en") {
          currentLanguage = "zh";
          this.innerHTML = "English";
        } else {
          currentLanguage = "en";
          this.innerHTML = "繁體中文";
        }
        updateUIText();
      });
      
      // ------------------------------------
      // Main Renderer Setup
      // ------------------------------------
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x87ceeb);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // ------------------------------------
      // Top View Renderer & Orthographic Camera
      // ------------------------------------
      const topViewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      topViewRenderer.setSize(200, 200);
      topViewRenderer.setClearColor(0x000000, 0);
      const topViewDiv = document.getElementById("topViewRenderer");
      topViewDiv.appendChild(topViewRenderer.domElement);
      const d = 400;
      const topViewCamera = new THREE.OrthographicCamera(-d, d, d, -d, 0.1, 2000);
      topViewCamera.position.set(0, 1000, 0);
      topViewCamera.lookAt(new THREE.Vector3(0, 0, 0));
      topViewCamera.zoom = 5;
      topViewCamera.updateProjectionMatrix();
      document.getElementById("zoomIn").addEventListener("click", () => {
        topViewCamera.zoom *= 1.1;
        topViewCamera.updateProjectionMatrix();
      });
      document.getElementById("zoomOut").addEventListener("click", () => {
        topViewCamera.zoom /= 1.1;
        topViewCamera.updateProjectionMatrix();
      });
      
      // ------------------------------------
      // Ground & Grid
      // ------------------------------------
      const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xededed });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      const grid = new THREE.GridHelper(1000, 50, 0x000000, 0x000000);
      scene.add(grid);
      
      // ------------------------------------
      // Global Clock
      // ------------------------------------
      const clock = new THREE.Clock();
      
      // ------------------------------------
      // Animation Loop
      // ------------------------------------
      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
      
        if (takenOff && !flightEnded) {
          totalFlightTime += delta;
        }
        if (previousPosition) {
          let dx = drone.position.x - previousPosition.x;
          let dz = drone.position.z - previousPosition.z;
          let dHoriz = Math.sqrt(dx * dx + dz * dz);
          totalDistance += dHoriz;
          var flightSpeed = dHoriz / delta;
        } else {
          previousPosition = drone.position.clone();
          var flightSpeed = 0;
        }
        previousPosition = drone.position.clone();
        document.getElementById("statsBox").innerHTML =
          translations[currentLanguage].totalFlightDistance + totalDistance.toFixed(1) + "<br>" +
          translations[currentLanguage].flightSpeed + flightSpeed.toFixed(1) + "<br>" +
          translations[currentLanguage].flightTime + totalFlightTime.toFixed(1) + " s";
      
        if (!disableDroneControls && !flightEnded) {
          if (rthActive) {
            const msgDiv = document.getElementById("message");
            const hDist = new THREE.Vector2(drone.position.x, drone.position.z).length();
            if (hDist > 1) {
              msgDiv.innerHTML = translations[currentLanguage].rthInProgress;
              if (rth12Audio.paused) {
                rth12Audio.currentTime = 0;
                rth12Audio.play().catch(err => console.log("Error playing rth12Audio:", err));
              }
              if (!land1Audio.paused) {
                land1Audio.pause();
                land1Audio.currentTime = 0;
              }
              const dir = new THREE.Vector3(-drone.position.x, 0, -drone.position.z).normalize();
              const desiredYaw = Math.atan2(dir.x, dir.z);
              drone.yaw = lerp(drone.yaw, desiredYaw, 0.05);
              drone.position.x += dir.x * 30 * delta;
              drone.position.z += dir.z * 30 * delta;
            } else {
              const msgDiv = document.getElementById("message");
              msgDiv.innerHTML = translations[currentLanguage].automaticLanding;
              if (!rth12Audio.paused) {
                rth12Audio.pause();
                rth12Audio.currentTime = 0;
              }
              if (land1Audio.paused) {
                land1Audio.currentTime = 0;
                land1Audio.play().catch(err => console.log("Error playing land1Audio:", err));
              }
              if (drone.position.y > 0.45) {
                drone.position.y -= 5 * delta;
              }
              drone.yaw = lerp(drone.yaw, 0, 0.05);
              drone.pitch = lerp(drone.pitch, 0, 0.1);
              drone.roll = lerp(drone.roll, 0, 0.1);
              if (drone.position.y <= 0.45 + 0.01) {
                drone.position.y = 0.45;
                land1Audio.pause();
                land1Audio.currentTime = 0;
                rthActive = false;
                flightEnded = true;
                document.getElementById("message").style.display = "none";
                rthBtn.style.backgroundColor = "#2196f3";
                disableDroneControls = true;
              }
            }
          } else {
            syncJoystickWithKeyboard();
            let rawThrottle = (-leftJoystickInput.dy) + ((keys["KeyW"] ? 1 : 0) - (keys["KeyS"] ? 1 : 0));
            let throttleInput = Math.abs(rawThrottle) >= throttleDeadZone ? rawThrottle : 0;
            drone.position.y += throttleInput * throttleSpeed * delta;
            if (drone.position.y < 0.45) drone.position.y = 0.45;
            if (!takenOff && throttleInput !== 0 && drone.position.y > 1.0) {
              takenOff = true;
            }
            if (drone.position.y > 0.45) {
              let yawInput = (-leftJoystickInput.dx) + ((keys["KeyA"] ? 1 : 0) - (keys["KeyD"] ? 1 : 0));
              drone.yaw += yawSpeed * yawInput * delta;
              let pitchInput = (-rightJoystickInput.dy) + ((keys["ArrowUp"] ? 1 : 0) - (keys["ArrowDown"] ? 1 : 0));
              let desiredPitch = pitchInput * maxTilt;
              drone.pitch = lerp(drone.pitch, desiredPitch, 0.1);
              let rollInput = rightJoystickInput.dx + ((keys["ArrowRight"] ? 1 : 0) - (keys["ArrowLeft"] ? 1 : 0));
              let desiredRoll = -rollInput * maxTilt;
              drone.roll = lerp(drone.roll, desiredRoll, 0.1);
              const forwardDir = new THREE.Vector3(Math.sin(drone.yaw), 0, Math.cos(drone.yaw));
              const rightDir = new THREE.Vector3(Math.cos(drone.yaw), 0, -Math.sin(drone.yaw));
              const horizontalDisplacement = new THREE.Vector3();
              horizontalDisplacement.add(forwardDir.multiplyScalar(Math.sin(drone.pitch)))
                                     .add(rightDir.multiplyScalar(Math.sin(drone.roll)));
              horizontalDisplacement.multiplyScalar(translationSpeed * delta);
              drone.position.add(horizontalDisplacement);
            } else {
              drone.yaw = 0;
              drone.pitch = 0;
              drone.roll = 0;
            }
            if (drone.position.y > 1.0 && takenOff) {
              if (!flyAudioPlaying) {
                flyAudio.currentTime = 0;
                flyAudio.play().catch(err => console.log("Error playing flyAudio:", err));
                flyAudioPlaying = true;
                flyAudio.volume = 0;
              }
              if (flyAudio.volume < 1.0) {
                flyAudio.volume = Math.min(1.0, flyAudio.volume + delta * 0.5);
              }
            } else {
              if (flyAudioPlaying) {
                flyAudio.pause();
                flyAudio.currentTime = 0;
                flyAudioPlaying = false;
              }
            }
          }
        } else {
          if (flyAudioPlaying) {
            flyAudio.pause();
            flyAudio.currentTime = 0;
            flyAudioPlaying = false;
          }
        }
      
        droneGroup.position.copy(drone.position);
        droneGroup.rotation.set(drone.pitch, drone.yaw, -drone.roll);
      
        // Update propellers.
        propellers.forEach(prop => {
          if (drone.position.y > 0.45) {
            prop.currentSpinSpeed = prop.spinSpeed;
          } else {
            prop.currentSpinSpeed = lerp(prop.currentSpinSpeed, 0, 2.0 * delta);
          }
          prop.mesh.rotation.y += prop.currentSpinSpeed * delta;
          let blinkTime = clock.getElapsedTime() * 5 + prop.blinkOffset;
          prop.blinkSpot.visible = Math.sin(blinkTime) > 0;
        });
      
        // Hoop collision detection.
        hoops.forEach(hoop => {
          const dToHoop = drone.position.distanceTo(hoop.mesh.position);
          if (!hoop.entered && dToHoop < hoop.mainRadius) {
            hoop.entered = true;
          }
          if (hoop.entered && !hoop.passed && dToHoop > hoop.mainRadius * 1.1 && takenOff) {
            if (hoop.number === currentExpectedHoop) {
              hoop.passed = true;
              hoop.mesh.material.color.set(0x00ff00);
              bonusAudio.currentTime = 0;
              bonusAudio.play().catch(err => console.log("Error playing bonusAudio:", err));
              currentExpectedHoop++;
              const cell = document.getElementById("hoopCell-" + hoop.number);
              if (cell) cell.classList.add("passed");
              const canvas = hoop.labelSprite.material.map.image;
              const ctx = canvas.getContext("2d");
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.fillStyle = "green";
              ctx.font = "Bold 80px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(hoop.number.toString(), canvas.width / 2, canvas.height / 2);
              hoop.labelSprite.material.map.needsUpdate = true;
            }
            hoop.entered = false;
          }
        });
      
        // Rotate square and triangular hoops.
        hoops.forEach(hoop => {
          if (hoop.type === "square" || hoop.type === "triangle") {
            hoop.mesh.rotation.z += delta;
          }
        });
      
        if (!allHoopsPassed) {
          let passedCount = 0;
          hoops.forEach(hoop => { if (hoop.passed) passedCount++; });
          if (passedCount === hoops.length) {
            allHoopsPassed = true;
            const msgDiv = document.getElementById("message");
            msgDiv.style.display = "block";
            msgDiv.innerHTML = translations[currentLanguage].allHoopsPassed;
          }
        }
      
        const dX = drone.position.x;
        const dZ = drone.position.z;
        const distToHome = Math.sqrt(dX * dX + dZ * dZ);
        if (allHoopsPassed && !landedAtHome && distToHome < 10 && drone.position.y < 1 && takenOff) {
          landedAtHome = true;
          flightEnded = true;
          const msgDiv = document.getElementById("message");
          msgDiv.innerHTML = translations[currentLanguage].landingMessage;
          if (homeMarker && homeMarker.userData && homeMarker.userData.ctx) {
            drawHomeMarker(homeMarker.userData.ctx, "yellow");
            homeMarker.userData.texture.needsUpdate = true;
          }
          sweetAudio.currentTime = 0;
          sweetAudio.play().catch(err => console.log("Error playing sweetAudio:", err));
          land1Audio.pause();
          land1Audio.currentTime = 0;
          document.getElementById("newGameButton").addEventListener("click", () => { resetDrone(); });
        }
      
        const cameraOffset = new THREE.Vector3(0, 5, -15);
        const quat = new THREE.Quaternion();
        quat.setFromEuler(new THREE.Euler(0, drone.yaw, 0));
        const rotatedOffset = cameraOffset.clone().applyQuaternion(quat);
        camera.position.copy(drone.position.clone().add(rotatedOffset));
        camera.lookAt(drone.position);
        const alt = (drone.position.y - 0.45).toFixed(1);
        const dist = Math.sqrt(drone.position.x * drone.position.x + drone.position.z * drone.position.z).toFixed(1);
        document.getElementById("info").textContent =
          translations[currentLanguage].altitude + ": " + alt + " | " +
          translations[currentLanguage].distance + ": " + dist;
        if (flightPathActive && takenOff) {
          flightPathPoints.push(drone.position.clone());
          if (flightPathPoints.length > 500) {
            flightPathPoints.shift();
          }
          if (flightPathLine) {
            scene.remove(flightPathLine);
          }
          const geometry = new THREE.BufferGeometry().setFromPoints(flightPathPoints);
          const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
          flightPathLine = new THREE.Line(geometry, material);
          scene.add(flightPathLine);
        }
        renderer.render(scene, camera);
        topViewRenderer.render(scene, topViewCamera);
      }
      animate();
      
      // ------------------------------------
      // Reset Function
      // ------------------------------------
      function resetDrone() {
        drone.position.set(0, 0.45, 0);
        drone.yaw = 0;
        drone.pitch = 0;
        drone.roll = 0;
        takenOff = false;
        landedAtHome = false;
        allHoopsPassed = false;
        currentExpectedHoop = 1;
        flightPathPoints = [];
        if (flightPathLine) {
          scene.remove(flightPathLine);
          flightPathLine = null;
        }
        leftJoystickInput.dx = 0;
        leftJoystickInput.dy = 0;
        document.querySelector("#leftJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
        rightJoystickInput.dx = 0;
        rightJoystickInput.dy = 0;
        document.querySelector("#rightJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
        hoops.forEach(hoop => {
          hoop.entered = false;
          hoop.passed = false;
          hoop.mesh.material.color.setHex(hoop.originalColor);
          const canvas = hoop.labelSprite.material.map.image;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "yellow";
          ctx.font = "Bold 80px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(hoop.number.toString(), canvas.width / 2, canvas.height / 2);
          hoop.labelSprite.material.map.needsUpdate = true;
        });
        if (homeMarker && homeMarker.userData && homeMarker.userData.ctx) {
          drawHomeMarker(homeMarker.userData.ctx, "white");
          homeMarker.userData.texture.needsUpdate = true;
        }
        document.getElementById("message").style.display = "none";
        for (let i = 1; i <= hoops.length; i++) {
          const cell = document.getElementById("hoopCell-" + i);
          if (cell) cell.classList.remove("passed");
        }
        rthBtn.style.backgroundColor = "#2196f3";
        disableDroneControls = false;
        flightEnded = false;
        totalDistance = 0;
        totalFlightTime = 0;
        previousPosition = null;
        if (flyAudioPlaying) {
          flyAudio.pause();
          flyAudio.currentTime = 0;
          flyAudio.volume = 0;
          flyAudioPlaying = false;
        }
        if (!rth12Audio.paused) {
          rth12Audio.pause();
          rth12Audio.currentTime = 0;
        }
        if (!land1Audio.paused) {
          land1Audio.pause();
          land1Audio.currentTime = 0;
        }
        updateUIText();
      }
      document.getElementById("btn-reset").addEventListener("click", resetDrone);
      
      updateUIText();
    </script>
  </body>
</html>
