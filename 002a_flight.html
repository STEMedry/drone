<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Quadcopter Flight Simulation</title>
    <style>
      /* Basic Reset */
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      /* Title styling at the top middle */
      #title {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 32px;
        font-weight: bold;
        text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff,
          -1px 1px 0 #fff, 1px 1px 0 #fff;
        z-index: 100;
      }
      /* Language Toggle Button (Top Right Corner) */
      #langToggle {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 110;
        padding: 8px 12px;
        font-size: 16px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        background-color: #4caf50;
        color: white;
      }
      /* General Message */
      #message {
        position: absolute;
        top: 10%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        font-size: 20px;
        border-radius: 5px;
        z-index: 10;
        display: none;
      }
      /* Controls Container (bottom center) */
      #controls {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        background: rgba(255, 255, 255, 0.8);
        padding: 20px;
        border-radius: 5px;
        width: 1000px;
        height: 220px;
      }
      /* Info box for Altitude & Distance */
      #info {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 18px;
        color: #000;
      }
      #btn-reset {
        position: absolute;
        bottom: 10px;
        right: 480px;
        width: 80px;
        height: 40px;
        padding: 10px;
        font-size: 18px;
        font-weight: bold;
        border: none;
        border-radius: 5px;
      }
      /* Container for slider and joysticks */
      #main-controls {
        display: flex;
        align-items: center;
        gap: 100px;
      }
      /* Speed slider container (center) */
      #speedContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        /* Shift upward to avoid overlapping with the joystick areas */
        transform: translateY(-60px);
      }
      /* New speed label style */
      #speedLabel {
        font-size: 18px;
        font-weight: bold;
      }
      #speedSlider {
        width: 200px;
      }
      /* Enlarged Virtual Joystick Styles */
      .joystick-container {
        width: 300px;
        height: 300px;
        position: relative;
      }
      .joystick-base {
        width: 200px;
        height: 200px;
        background: rgba(200, 200, 200, 0.5);
        border: 2px solid #aaa;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        top: 40%;
        transform: translate(-50%, -50%);
      }
      .joystick-thumb {
        width: 80px;
        height: 80px;
        background: rgba(100, 100, 100, 0.8);
        border: 2px solid #555;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        top: 40%;
        transform: translate(-50%, -50%);
        touch-action: none;
      }
      /* Joystick label styles - placed outside the joystick base */
      .joystick-label {
        position: absolute;
        font-size: 16px;
        color: rgba(0, 0, 0, 0.9);
        font-weight: bold;
        pointer-events: none;
      }
      /* For the left joystick:
         Top: Throttle Up; Bottom: Throttle Down;
         Left: Yaw Left; Right: Yaw Right */
      #leftJoystick .label-top {
        top: 0px;
        left: 50%;
        transform: translateX(-50%);
      }
      #leftJoystick .label-bottom {
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
      }
      #leftJoystick .label-left {
        left: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      #leftJoystick .label-right {
        right: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      /* For the right joystick:
         Top: Pitch Forward; Bottom: Pitch Backward;
         Left: Roll Left; Right: Roll Right */
      #rightJoystick .label-top {
        top: 0px;
        left: 50%;
        transform: translateX(-50%);
      }
      #rightJoystick .label-bottom {
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
      }
      #rightJoystick .label-left {
        left: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      #rightJoystick .label-right {
        right: 0px;
        top: 40%;
        transform: translateY(-50%);
      }
      /* Zoom Controls and Top View Container */
      #topViewContainer {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 30;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #topViewRenderer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        transform: rotate(180deg);
        background: none;
      }
      #zoomControls {
        margin-top: 5px;
        display: flex;
        gap: 10px;
      }
      #zoomControls button {
        font-size: 14px;
        padding: 4px 8px;
      }
      /* Hoop Table in top right (displayed in 2 rows) */
      #hoopTable {
        position: absolute;
        top: 60px;
        right: 20px;
        z-index: 100;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border: 1px solid #ccc;
        display: grid;
        grid-template-columns: repeat(5, 30px);
        gap: 5px;
      }
      #hoopTable .hoopCell {
        width: 30px;
        height: 30px;
        line-height: 30px;
        text-align: center;
        font-weight: bold;
        background: yellow;
        border: 1px solid #000;
      }
      #hoopTable .hoopCell.passed {
        background: grey;
      }
      /* Button classes */
      .btn-green {
        background-color: #4caf50;
        color: white;
      }
      .btn-red {
        background-color: #f44336;
        color: white;
      }
      .btn-default {
        background-color: #2196f3;
        color: white;
      }
      /* Enlarge the "Show Flight Path" button */
      #toggleFlightPath {
        width: 200px;
        height: 50px;
        font-size: 20px;
        border: none;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <!-- Title -->
    <div id="title">Quadcopter Flight Simulation</div>
    <!-- Language Toggle Button -->
    <button id="langToggle" class="btn-green">繁體中文</button>
    <!-- General Message -->
    <div id="message"></div>
    
    <!-- Top View Container -->
    <div id="topViewContainer">
      <div id="topViewRenderer"></div>
      <div id="zoomControls">
        <button id="zoomIn">Zoom In</button>
        <button id="zoomOut">Zoom Out</button>
      </div>
    </div>
    
    <!-- Hoop Table -->
    <div id="hoopTable">
      <div class="hoopCell" id="hoopCell-1">1</div>
      <div class="hoopCell" id="hoopCell-2">2</div>
      <div class="hoopCell" id="hoopCell-3">3</div>
      <div class="hoopCell" id="hoopCell-4">4</div>
      <div class="hoopCell" id="hoopCell-5">5</div>
      <div class="hoopCell" id="hoopCell-6">6</div>
      <div class="hoopCell" id="hoopCell-7">7</div>
      <div class="hoopCell" id="hoopCell-8">8</div>
      <div class="hoopCell" id="hoopCell-9">9</div>
      <div class="hoopCell" id="hoopCell-10">10</div>
    </div>
    
    <!-- Controls Container -->
    <div id="controls">
      <div id="info">Altitude: 0 | Distance: 0</div>
      <div id="main-controls">
        <!-- Left Virtual Joystick -->
        <div class="joystick-container" id="leftJoystick">
          <div class="joystick-base"></div>
          <div class="joystick-thumb"></div>
          <!-- Movement labels placed outside the base -->
          <span class="joystick-label label-top">Throttle Up</span>
          <span class="joystick-label label-bottom">Throttle Down</span>
          <span class="joystick-label label-left">Yaw Left</span>
          <span class="joystick-label label-right">Yaw Right</span>
        </div>
        <!-- Speed Slider and Flight Path Toggle -->
        <div id="speedContainer">
          <div id="speedLabel">Speed</div>
          <input type="range" id="speedSlider" min="10" max="100" value="50" step="1" />
          <button id="toggleFlightPath" class="btn-default">Show Flight Path</button>
        </div>
        <!-- Right Virtual Joystick -->
        <div class="joystick-container" id="rightJoystick">
          <div class="joystick-base"></div>
          <div class="joystick-thumb"></div>
          <!-- Movement labels placed outside the base -->
          <span class="joystick-label label-top">Pitch Forward</span>
          <span class="joystick-label label-bottom">Pitch Backward</span>
          <span class="joystick-label label-left">Roll Left</span>
          <span class="joystick-label label-right">Roll Right</span>
        </div>
      </div>
      <button id="btn-reset" class="btn-red">Reset</button>
    </div>
    
    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Linear interpolation helper.
      function lerp(a, b, t) {
        return a + (b - a) * t;
      }
    
      // Virtual Joystick helper: attaches pointer/touch events to a joystick container.
      function attachJoystick(containerId, joystickObj) {
        const container = document.getElementById(containerId);
        const thumb = container.querySelector(".joystick-thumb");
        let dragging = false;
        let center = { x: 0, y: 0 };
        const maxDist = 40; // Maximum displacement in pixels.
    
        function updateThumb(dx, dy) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
          }
          thumb.style.transform = `translate(${dx - 40}px, ${dy - 40}px)`;
          joystickObj.dx = dx / maxDist;
          joystickObj.dy = dy / maxDist;
        }
    
        function resetJoystick() {
          dragging = false;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          thumb.style.transform = "translate(-50%, -50%)";
        }
    
        function onMove(clientX, clientY) {
          const dx = clientX - center.x;
          const dy = clientY - center.y;
          updateThumb(dx, dy);
        }
    
        container.addEventListener("mousedown", (e) => {
          dragging = true;
          const rect = container.getBoundingClientRect();
          center.x = rect.left + rect.width / 2;
          center.y = rect.top + rect.height / 2;
          onMove(e.clientX, e.clientY);
        });
    
        container.addEventListener("mousemove", (e) => {
          if (dragging) {
            onMove(e.clientX, e.clientY);
          }
        });
    
        container.addEventListener("mouseup", resetJoystick);
        container.addEventListener("mouseleave", resetJoystick);
    
        container.addEventListener("touchstart", (e) => {
          dragging = true;
          const rect = container.getBoundingClientRect();
          center.x = rect.left + rect.width / 2;
          center.y = rect.top + rect.height / 2;
          const touch = e.touches[0];
          onMove(touch.clientX, touch.clientY);
          e.preventDefault();
        });
    
        container.addEventListener("touchmove", (e) => {
          if (dragging) {
            const touch = e.touches[0];
            onMove(touch.clientX, touch.clientY);
            e.preventDefault();
          }
        });
    
        container.addEventListener("touchend", resetJoystick);
      }
    
      window.addEventListener("load", function () {
        // --------------------------------------------------
        // GLOBAL STATE VARIABLES & TRANSLATIONS
        // --------------------------------------------------
        let currentExpectedHoop = 1;
        let landedAtHome = false;
        let takenOff = false;
        let allHoopsPassed = false;
    
        let currentLanguage = "en";
        const translations = {
          en: {
            title: "Quadcopter Flight Simulation",
            allHoopsPassed:
              "All hoops passed! Now fly back and land on the home point (marked with H).",
            landingMessage:
              "Congratulations! You landed safely at home.<br><button id='newGameButton' class='btn-default'>New Game</button>",
            reset: "Reset",
            showFlightPath: "Show Flight Path",
            hideFlightPath: "Hide Flight Path",
            throttleUp: "Throttle Up",
            throttleDown: "Throttle Down",
            yawLeft: "Yaw Left",
            yawRight: "Yaw Right",
            pitchForward: "Pitch Forward",
            pitchBackward: "Pitch Backward",
            rollLeft: "Roll Left",
            rollRight: "Roll Right",
            zoomIn: "Zoom In",
            zoomOut: "Zoom Out",
            altitude: "Altitude",
            distance: "Distance"
          },
          zh: {
            title: "四軸無人機飛行模擬",
            allHoopsPassed:
              "所有環門已通過！請飛回並在以「H」標示的起飛點著陸。",
            landingMessage:
              "恭喜！您已安全降落在起飛點。<br><button id='newGameButton' class='btn-default'>新遊戲</button>",
            reset: "重置",
            showFlightPath: "顯示飛行路徑",
            hideFlightPath: "隱藏飛行路徑",
            throttleUp: "上升",
            throttleDown: "下降",
            yawLeft: "左轉",
            yawRight: "右轉",
            pitchForward: "前飛",
            pitchBackward: "後飛",
            rollLeft: "左飛",
            rollRight: "右飛",
            zoomIn: "放大",
            zoomOut: "縮小",
            altitude: "高度",
            distance: "距離"
          }
        };
    
        function updateUIText() {
          document.getElementById("title").innerHTML = translations[currentLanguage].title;
          document.getElementById("btn-reset").innerHTML = translations[currentLanguage].reset;
          const flightToggle = document.getElementById("toggleFlightPath");
          if (flightToggle) {
            flightToggle.innerHTML =
              flightPathActive
                ? translations[currentLanguage].hideFlightPath
                : translations[currentLanguage].showFlightPath;
          }
          document.getElementById("zoomIn").innerHTML = translations[currentLanguage].zoomIn;
          document.getElementById("zoomOut").innerHTML = translations[currentLanguage].zoomOut;
        }
    
        document.getElementById("langToggle").addEventListener("click", function () {
          if (currentLanguage === "en") {
            currentLanguage = "zh";
            this.innerHTML = "English";
          } else {
            currentLanguage = "en";
            this.innerHTML = "繁體中文";
          }
          updateUIText();
        });
    
        // --------------------------------------------------
        // MAIN SCENE, CAMERA, & RENDERER
        // --------------------------------------------------
        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87ceeb);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
    
        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          2000
        );
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
    
        // --------------------------------------------------
        // TOP VIEW RENDERER & ORTHOGRAPHIC CAMERA
        // --------------------------------------------------
        const topViewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        topViewRenderer.setSize(200, 200);
        topViewRenderer.setClearColor(0x000000, 0);
        const topViewDiv = document.getElementById("topViewRenderer");
        topViewDiv.appendChild(topViewRenderer.domElement);
    
        const d = 400;
        const topViewCamera = new THREE.OrthographicCamera(-d, d, d, -d, 0.1, 2000);
        topViewCamera.position.set(0, 1000, 0);
        topViewCamera.lookAt(0, 0, 0);
        topViewCamera.zoom = 5;
        topViewCamera.updateProjectionMatrix();
    
        document.getElementById("zoomIn").addEventListener("click", () => {
          topViewCamera.zoom *= 1.1;
          topViewCamera.updateProjectionMatrix();
        });
        document.getElementById("zoomOut").addEventListener("click", () => {
          topViewCamera.zoom /= 1.1;
          topViewCamera.updateProjectionMatrix();
        });
    
        // --------------------------------------------------
        // GROUND, GRID, & HOME MARKER
        // --------------------------------------------------
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xEDEDED });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
    
        const grid = new THREE.GridHelper(1000, 50, 0x000000, 0x000000);
        scene.add(grid);
    
        function createHomeMarker() {
          const canvas = document.createElement("canvas");
          canvas.width = 256;
          canvas.height = 256;
          const ctx = canvas.getContext("2d");
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(128, 128, 120, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.lineWidth = 10;
          ctx.stroke();
          ctx.fillStyle = "black";
          ctx.font = "bold 100px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("H", 128, 128);
          const texture = new THREE.CanvasTexture(canvas);
          const material = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
            transparent: true,
          });
          const geometry = new THREE.CircleGeometry(5, 32);
          const mesh = new THREE.Mesh(geometry, material);
          mesh.rotation.x = -Math.PI / 2;
          mesh.position.set(0, 0.01, 0);
          return mesh;
        }
        const homeMarker = createHomeMarker();
        scene.add(homeMarker);
    
        // --------------------------------------------------
        // BASIC LIGHTING
        // --------------------------------------------------
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(100, 200, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.bias = -0.001;
        scene.add(directionalLight);
    
        // --------------------------------------------------
        // DRONE (QUADCOPTER) SETUP
        // --------------------------------------------------
        const droneGroup = new THREE.Group();
        droneGroup.rotation.order = "YXZ";
        scene.add(droneGroup);
    
        const drone = {
          position: new THREE.Vector3(0, 0, 0),
          yaw: 0,
          pitch: 0,
          roll: 0,
        };
    
        const droneBodyGeometry = new THREE.BoxGeometry(1, 0.3, 1);
        const droneBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0000FF });
        const droneBody = new THREE.Mesh(droneBodyGeometry, droneBodyMaterial);
        droneGroup.add(droneBody);
    
        function createDroneLabel(text) {
          const canvas = document.createElement("canvas");
          canvas.width = 512;
          canvas.height = 128;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.font = "bold 150px Arial";
          ctx.fillStyle = "white";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(text, canvas.width / 2, canvas.height / 2);
          const texture = new THREE.CanvasTexture(canvas);
          texture.center = new THREE.Vector2(0.5, 0.5);
          texture.rotation = Math.PI;
          texture.needsUpdate = true;
          const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
          const geometry = new THREE.PlaneGeometry(0.9, 0.3);
          const mesh = new THREE.Mesh(geometry, material);
          mesh.rotation.x = -Math.PI / 2;
          mesh.position.set(0, 0.15 + 0.01, 0);
          return mesh;
        }
        const label = createDroneLabel("EdUHK");
        droneGroup.add(label);
    
        // --------------------------------------------------
        // PROPELLERS SETUP
        // --------------------------------------------------
        const propellerGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.9);
        const propellers = [];
    
        // Front Left
        const frontLeft = new THREE.Mesh(
          propellerGeometry,
          new THREE.MeshLambertMaterial({ color: 0xff0000 })
        );
        frontLeft.position.set(-0.50, 0.2, 0.55);
        droneGroup.add(frontLeft);
        propellers.push({ mesh: frontLeft, spinSpeed: +10, defaultAngle: THREE.Math.degToRad(45) });
    
        // Front Right
        const frontRight = new THREE.Mesh(
          propellerGeometry,
          new THREE.MeshLambertMaterial({ color: 0xff0000 })
        );
        frontRight.position.set(0.50, 0.2, 0.55);
        droneGroup.add(frontRight);
        propellers.push({ mesh: frontRight, spinSpeed: -10, defaultAngle: THREE.Math.degToRad(135) });
    
        // Rear Left
        const rearLeft = new THREE.Mesh(
          propellerGeometry,
          new THREE.MeshLambertMaterial({ color: 0x00ff00 })
        );
        rearLeft.position.set(-0.50, 0.2, -0.55);
        droneGroup.add(rearLeft);
        propellers.push({ mesh: rearLeft, spinSpeed: -10, defaultAngle: THREE.Math.degToRad(135) });
    
        // Rear Right
        const rearRight = new THREE.Mesh(
          propellerGeometry,
          new THREE.MeshLambertMaterial({ color: 0x00ff00 })
        );
        rearRight.position.set(0.50, 0.2, -0.55);
        droneGroup.add(rearRight);
        propellers.push({ mesh: rearRight, spinSpeed: +10, defaultAngle: THREE.Math.degToRad(45) });
    
        droneGroup.scale.set(3, 3, 3);
        droneGroup.traverse(child => {
          if (child instanceof THREE.Mesh) child.castShadow = true;
        });
    
        // --------------------------------------------------
        // BLINKING YELLOW SPOTS ON PROPELLERS
        // --------------------------------------------------
        const blinkSphereGeometry = new THREE.SphereGeometry(0.08, 16, 16);
        propellers.forEach((prop, index) => {
          const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
          const blinkSpot = new THREE.Mesh(blinkSphereGeometry, mat);
          blinkSpot.position.set(0, 0, 0);
          prop.mesh.add(blinkSpot);
          prop.blinkOffset = index * (Math.PI / 2);
          prop.blinkSpot = blinkSpot;
        });
    
        // --------------------------------------------------
        // HOOPS (OBJECTIVES) SETUP
        // --------------------------------------------------
        const totalHoops = 10;
        const altitudes = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55];
    
        function createHoopLabel(number) {
          const canvas = document.createElement("canvas");
          canvas.width = 128;
          canvas.height = 128;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "yellow";
          ctx.font = "Bold 120px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(number.toString(), canvas.width / 2, canvas.height / 2);
          const texture = new THREE.CanvasTexture(canvas);
          const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(4, 4, 1);
          return sprite;
        }
    
        function createHoop(number) {
          const mainRadius = 9;
          const tubeRadius = 0.2;
          const radialSegments = 16;
          const tubularSegments = 100;
          const geometry = new THREE.TorusGeometry(mainRadius, tubeRadius, radialSegments, tubularSegments);
          const material = new THREE.MeshLambertMaterial({ color: 0xffa500 });
          const hoopMesh = new THREE.Mesh(geometry, material);
          // By default all hoops previously faced north (rotation.y = Math.PI/2).
          // To change five of them to face a different direction, we set:
          if (number <= 5) {
            // Face east.
            hoopMesh.rotation.set(0, 0, 0);
          } else {
            // Face north.
            hoopMesh.rotation.set(0, Math.PI / 2, 0);
          }
          const labelSprite = createHoopLabel(number);
          labelSprite.position.set(0, mainRadius + 2, 0);
          hoopMesh.add(labelSprite);
          return { 
            mesh: hoopMesh, 
            mainRadius: mainRadius, 
            entered: false, 
            passed: false, 
            number: number, 
            labelSprite: labelSprite 
          };
        }
    
        const hoops = [];
        for (let i = 0; i < totalHoops; i++) {
          const hoop = createHoop(i + 1);
          hoop.mesh.position.set((Math.random() - 0.5) * 80, altitudes[i], (Math.random() - 0.5) * 80);
          scene.add(hoop.mesh);
          hoops.push(hoop);
        }
    
        // --------------------------------------------------
        // AUDIO SETUP
        // --------------------------------------------------
        const bonusSound = new Audio("bonus.mp3");
        const sweetSound = new Audio("sweet.mp3");
    
        // --------------------------------------------------
        // USER INPUT - Virtual Joysticks & Keyboard Controls
        // --------------------------------------------------
        let translationSpeed = 50;
        const yawSpeed = 1.0;
        const throttleSpeed = 10;
        const maxTilt = Math.PI / 6;
    
        // Global joystick input objects.
        const leftJoystickInput = { dx: 0, dy: 0 };
        const rightJoystickInput = { dx: 0, dy: 0 };
        attachJoystick("leftJoystick", leftJoystickInput);
        attachJoystick("rightJoystick", rightJoystickInput);
    
        // Flight path toggle.
        let flightPathActive = false;
        let flightPathPoints = [];
        let flightPathLine = null;
    
        const toggleFlightPathBtn = document.getElementById("toggleFlightPath");
        toggleFlightPathBtn.addEventListener("click", function () {
          flightPathActive = !flightPathActive;
          if (flightPathActive) {
            toggleFlightPathBtn.innerHTML = translations[currentLanguage].hideFlightPath;
            flightPathPoints = [];
            if (flightPathLine) {
              scene.remove(flightPathLine);
              flightPathLine = null;
            }
          } else {
            toggleFlightPathBtn.innerHTML = translations[currentLanguage].showFlightPath;
            if (flightPathLine) {
              scene.remove(flightPathLine);
              flightPathLine = null;
            }
          }
        });
    
        // Keyboard event handlers for AWSD and arrow keys.
        const keys = {};
        document.addEventListener("keydown", (e) => { keys[e.code] = true; });
        document.addEventListener("keyup", (e) => { keys[e.code] = false; });
    
        document.getElementById("speedSlider").addEventListener("input", function () {
          translationSpeed = parseFloat(this.value);
        });
    
        // --------------------------------------------------
        // RESET FUNCTIONALITY
        // --------------------------------------------------
        function resetDrone() {
          drone.position.set(0, 0, 0);
          drone.yaw = 0;
          drone.pitch = 0;
          drone.roll = 0;
          takenOff = false;
          landedAtHome = false;
          allHoopsPassed = false;
          currentExpectedHoop = 1;
          flightPathPoints = [];
          if (flightPathLine) {
            scene.remove(flightPathLine);
            flightPathLine = null;
          }
          hoops.forEach(hoop => {
            hoop.entered = false;
            hoop.passed = false;
            hoop.mesh.material.color.set(0xffa500);
            const canvas = hoop.labelSprite.material.map.image;
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "yellow";
            ctx.font = "Bold 80px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(hoop.number.toString(), canvas.width / 2, canvas.height / 2);
            hoop.labelSprite.material.map.needsUpdate = true;
          });
          document.getElementById("message").style.display = "none";
          for (let i = 1; i <= totalHoops; i++) {
            const cell = document.getElementById("hoopCell-" + i);
            if (cell) cell.classList.remove("passed");
          }
          updateUIText();
        }
        document.getElementById("btn-reset").addEventListener("click", resetDrone);
    
        // --------------------------------------------------
        // MAIN ANIMATION LOOP
        // --------------------------------------------------
        const clock = new THREE.Clock();
        function animate() {
          requestAnimationFrame(animate);
          const delta = clock.getDelta();
      
          if (drone.position.y < 0) drone.position.y = 0;
      
          const altitude = drone.position.y.toFixed(1);
          const distance = Math.sqrt(
            drone.position.x * drone.position.x + drone.position.z * drone.position.z
          ).toFixed(1);
          document.getElementById("info").textContent =
            translations[currentLanguage].altitude + ": " + altitude +
            " | " + translations[currentLanguage].distance + ": " + distance;
      
          if (!landedAtHome) {
            // Combined input: joystick + keyboard.
            // Throttle: left joystick vertical + W/S keys.
            let throttleInput = (-leftJoystickInput.dy) + ((keys["KeyW"] ? 1 : 0) - (keys["KeyS"] ? 1 : 0));
            drone.position.y += throttleInput * throttleSpeed * delta;
            if (drone.position.y < 0) drone.position.y = 0;
      
            // Always enable all combined controls for yaw, pitch, and roll.
            let yawInput = (-leftJoystickInput.dx) + ((keys["KeyA"] ? 1 : 0) - (keys["KeyD"] ? 1 : 0));
            drone.yaw += yawInput * yawSpeed * delta;
      
            let pitchInput = (-rightJoystickInput.dy) + ((keys["ArrowUp"] ? 1 : 0) - (keys["ArrowDown"] ? 1 : 0));
            let desiredPitch = pitchInput * maxTilt;
            drone.pitch = lerp(drone.pitch, desiredPitch, 0.1);
      
            let rollInput = (rightJoystickInput.dx) + ((keys["ArrowRight"] ? 1 : 0) - (keys["ArrowLeft"] ? 1 : 0));
            let desiredRoll = -rollInput * maxTilt; // Inversion.
            drone.roll = lerp(drone.roll, desiredRoll, 0.1);
      
            if (!takenOff && drone.position.y > 1) takenOff = true;
          }
      
          // Horizontal displacement based on pitch and roll (applied always).
          const forwardDir = new THREE.Vector3(Math.sin(drone.yaw), 0, Math.cos(drone.yaw));
          const rightDir = new THREE.Vector3(Math.cos(drone.yaw), 0, -Math.sin(drone.yaw));
          const horizontalDisplacement = new THREE.Vector3();
          horizontalDisplacement.add(forwardDir.multiplyScalar(Math.sin(drone.pitch)))
                                 .add(rightDir.multiplyScalar(Math.sin(drone.roll)));
          horizontalDisplacement.multiplyScalar(translationSpeed * delta);
          drone.position.add(horizontalDisplacement);
      
          droneGroup.position.copy(drone.position);
          droneGroup.rotation.set(drone.pitch, drone.yaw, -drone.roll);
      
          propellers.forEach(prop => {
            if (drone.position.y > 0.1) {
              prop.mesh.rotation.y += prop.spinSpeed * delta;
            } else {
              prop.mesh.rotation.y = prop.defaultAngle;
            }
            let blinkTime = clock.getElapsedTime() * 5 + prop.blinkOffset;
            prop.blinkSpot.visible = Math.sin(blinkTime) > 0;
          });
      
          if (flightPathActive) {
            const currentPos = new THREE.Vector3(drone.position.x, 0.1, drone.position.z);
            if (
              flightPathPoints.length === 0 ||
              currentPos.distanceTo(flightPathPoints[flightPathPoints.length - 1]) > 0.2
            ) {
              flightPathPoints.push(currentPos);
            }
            if (flightPathPoints.length > 1) {
              const geometry = new THREE.BufferGeometry().setFromPoints(flightPathPoints);
              if (!flightPathLine) {
                const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
                flightPathLine = new THREE.Line(geometry, material);
                scene.add(flightPathLine);
              } else {
                flightPathLine.geometry.dispose();
                flightPathLine.geometry = geometry;
              }
            }
          }
      
          if (!allHoopsPassed) {
            let passedCount = 0;
            hoops.forEach(hoop => {
              if (hoop.passed) passedCount++;
            });
            if (passedCount === totalHoops) {
              allHoopsPassed = true;
              const messageDiv = document.getElementById("message");
              messageDiv.style.display = "block";
              messageDiv.innerHTML = translations[currentLanguage].allHoopsPassed;
            }
          }
      
          if (allHoopsPassed && !landedAtHome) {
            const dX = drone.position.x;
            const dZ = drone.position.z;
            const distToHome = Math.sqrt(dX * dX + dZ * dZ);
            if (distToHome < 10 && drone.position.y < 1) {
              landedAtHome = true;
              const messageDiv = document.getElementById("message");
              messageDiv.innerHTML = translations[currentLanguage].landingMessage;
              document.getElementById("newGameButton").addEventListener("click", () => {
                resetDrone();
              });
              sweetSound.currentTime = 0;
              sweetSound.play();
            }
          }
      
          const cameraOffset = new THREE.Vector3(0, 5, -15);
          const quat = new THREE.Quaternion();
          quat.setFromEuler(new THREE.Euler(0, drone.yaw, 0));
          const rotatedOffset = cameraOffset.clone().applyQuaternion(quat);
          camera.position.copy(drone.position.clone().add(rotatedOffset));
          camera.lookAt(drone.position);
      
          renderer.render(scene, camera);
          topViewRenderer.render(scene, topViewCamera);
        }
        animate();
      
        updateUIText();
      });
    </script>
  </body>
</html>
