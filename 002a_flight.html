<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- Meta viewport for responsiveness -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Virtual Flight Simulator</title>
    <style>
      /* Base & Universal Styles */
      * { box-sizing: border-box; }
      html, body {
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        font-family: Arial, sans-serif;
        touch-action: none;
        user-select: none;
      }
      canvas { display: block; }
      
      /* Title & Description */
      #title {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 32px;
        font-weight: bold;
        text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff,
                     -1px 1px 0 #fff, 1px 1px 0 #fff;
        z-index: 100;
      }
      #description {
        position: absolute;
        top: 50px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 16px;
        color: #333;
        z-index: 100;
      }
      
/* Top Right Buttons */
#langToggle, #tutorialButton {
  position: absolute;
  top: 10px;
  z-index: 110;
  padding: 8px 12px;
  font-size: 16px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  color: white;
}
#langToggle { 
  right: 20px; /* Moved to occupy the "Back" button's position */
  background-color: #4caf50; 
}
#tutorialButton { 
  right: 120px; /* Adjust as needed for spacing */
  background-color: #ff9800; 
}
      
      /* General Message */
      #message {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        font-size: 24px;
        border-radius: 5px;
        z-index: 110;
        display: none;
      }
      @keyframes blinking {
        0% { opacity: 1; }
        50% { opacity: 0; }
        100% { opacity: 1; }
      }
      .blinking { animation: blinking 1s infinite; }
      
      /* Alert Message */
      #alertMessage {
        position: absolute;
        top: 100px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(255, 0, 0, 0.9) !important;
        color: #ffffff !important;
        padding: 12px 24px;
        font-size: 22px;
        border: 2px solid #cc0000;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        z-index: 120;
        display: none;
        transition: background 0.3s ease;
      }
      #alertMessage.blinking {
        animation: blinking 1s infinite;
      }
      
      /* Controls Container */
      #controls {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 20;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        background: rgba(255, 255, 255, 0.8);
        padding: 20px;
        border-radius: 5px;
        width: 1050px;
        height: 270px;
      }
      #info {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 18px;
        color: red;
        font-weight: bold;
      }
      #btn-reset {
        position: absolute;
        bottom: 20px;
        right: 480px;
        width: 80px;
        height: 40px;
        padding: 10px;
        font-size: 18px;
        font-weight: bold;
        border: none;
        border-radius: 5px;
      }
      
      /* Main Control Layout */
      #main-controls {
        display: flex;
        align-items: center;
        gap: 100px;
      }
      #speedContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        transform: translateY(-40px);
      }
      #speedLabel { font-size: 18px; font-weight: bold; }
      #speedSlider { width: 200px; }
      #toggleFlightPath, #rthBtn {
        font-size: 16px;
        padding: 10px 20px;
      }
      #rthBtn { margin-top: 5px; }
      
      /* Virtual Joysticks */
      .joystick-container {
        width: 300px;
        height: 300px;
        position: relative;
        touch-action: none;
        -ms-touch-action: none;
      }
      .joystick-base {
        width: 200px;
        height: 200px;
        border: 2px solid #aaa;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        top: 40%;
        transform: translate(-50%, -50%);
      }
      #leftJoystick .joystick-base { 
        background: rgba(76,175,80,0.5); 
      }
      #rightJoystick .joystick-base { 
        background: #FFDAB9; 
      }
      /* Joystick Thumbs */
      #leftJoystick .joystick-thumb {
        width: 80px;
        height: 80px;
        border: 2px solid #555;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        top: 40%;
        transform: translate(-50%, -50%);
        background-color: darkgreen;
        touch-action: none;
        -ms-touch-action: none;
      }
      #rightJoystick .joystick-thumb {
        width: 80px;
        height: 80px;
        border: 2px solid #555;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        top: 40%;
        transform: translate(-50%, -50%);
        background-color: darkorange;
        touch-action: none;
        -ms-touch-action: none;
      }
      /* Joystick Labels */
      .joystick-label {
        position: absolute;
        font-size: 16px;
        color: black;
        font-weight: bold;
        pointer-events: none;
      }
      #leftJoystick .label-top { top: 0px; left: 50%; transform: translateX(-50%); }
      #leftJoystick .label-bottom { bottom: 60px; left: 50%; transform: translateX(-50%); }
      #leftJoystick .label-left { left: 0px; top: 40%; transform: translateY(-50%); }
      #leftJoystick .label-right { right: 0px; top: 40%; transform: translateY(-50%); }
      #rightJoystick .label-top { top: 0px; left: 50%; transform: translateX(-50%); }
      #rightJoystick .label-bottom { bottom: 60px; left: 50%; transform: translateX(-50%); }
      #rightJoystick .label-left { left: 0px; top: 40%; transform: translateY(-50%); }
      #rightJoystick .label-right { right: 0px; top: 40%; transform: translateY(-50%); }
      
      /* Top View Container & Navigation */
      /* Updated: Removed direction and zoom/navigation buttons */
      #topViewContainer {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 30;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      /* Title above the top view */
      #topviewTitle {
        font-size: 16px;
        font-weight: bold;
        margin-bottom: 5px;
        color: black;
      }
      #topViewRenderer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        /* rotation applied to flip the flight path for a desired orientation */
        transform: rotate(180deg);
        background: none;
        position: relative;
      }
      
      /* Hoop Table Container with Hoop Status Title */
      #hoopTableContainer {
        position: absolute;
        top: 60px;
        right: 20px;
        z-index: 100;
        background: rgba(255,255,255,0.8);
        padding: 10px;
        border: 1px solid #ccc;
      }
      #hoopStatusTitle {
        font-size: 16px;
        font-weight: bold;
        text-align: center;
        margin-bottom: 5px;
      }
      #hoopTable {
        display: grid;
        grid-template-columns: repeat(5, 30px);
        gap: 5px;
      }
      #hoopTable .hoopCell {
        width: 30px;
        height: 30px;
        line-height: 30px;
        text-align: center;
        font-weight: bold;
        background: yellow;
        border: 1px solid #000;
      }
      #hoopTable .hoopCell.passed { background: grey; }
      
      /* Replay Box Styles */
      #replayBox {
        position: absolute;
        top: 280px;
        left: 20px;
        width: 200px; /* Reduced width */
        background: rgba(255,255,255,0.9);
        border: 2px solid #ccc;
        border-radius: 5px;
        padding: 10px;
        z-index: 30;
      }
      #replayTitle { margin: 5px 0; font-size: 16px; text-align: center; }
      #replayCanvas {
        width: 150px; /* Reduced width */
        height: 150px; /* Reduced height */
        background: #f0f0f0;
        border: 1px solid #ccc;
        display: block;
        margin: 5px auto;
        transform: rotate(180deg);
      }
      #replayInfo p { margin: 2px 0; font-size: 12px; text-align: center; } /* Reduced font size */
      #replayButtons { display: flex; justify-content: center; gap: 5px; } /* Reduced gap */
      #playReplay, #stopReplay {
        padding: 5px 10px;
        font-size: 12px; /* Reduced font size */
        border: none;
        border-radius: 5px;
        cursor: pointer;
        background-color: #2196f3;
        color: white;
      }
      
      /* Stats Box */
      #statsBox {
        position: absolute;
        top: 180px;
        right: 20px;
        width: 220px;
        background: rgba(255,255,255,0.8);
        padding: 10px;
        border: 1px solid #ccc;
        font-family: Arial, sans-serif;
        font-weight: bold;
        font-size: 16px;
        text-align: left;
        line-height: 1.8;
      }
      
      /* New Game Button */
      #newGameButton {
        font-size: 24px;
        padding: 15px 25px;
        margin-top: 10px;
        border-radius: 8px;
        border: none;
        background-color: #2196f3;
        color: white;
        cursor: pointer;
      }
      
      /* Button Classes */
      .btn-green { background-color: #4caf50; color: white; }
      .btn-red { background-color: #f44336; color: white; }
      .btn-default { background-color: #2196f3; color: white; }
      
      /* Tutorial Modal Styles */
      #tutorialModal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 200; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgba(0,0,0,0.8); /* Black w/ opacity */
      }
      
      #tutorialContent {
        background-color: #fefefe;
        margin: 5% auto; /* 5% from the top and centered */
        padding: 20px;
        border: 1px solid #888;
        width: 80%; /* Could be more or less, depending on screen size */
        max-width: 800px;
        border-radius: 10px;
        position: relative;
      }
      
      /* Close Button */
      .closeTutorial {
        color: #aaa;
        position: absolute;
        top: 10px;
        right: 25px;
        font-size: 30px;
        font-weight: bold;
        cursor: pointer;
      }
      .closeTutorial:hover,
      .closeTutorial:focus {
        color: black;
        text-decoration: none;
      }
      
      /* Tutorial Images */
      .tutorial-image {
        width: 100%;
        height: auto;
        margin: 10px 0;
      }
      
      /* Tutorial Sections */
      .tutorial-section {
        margin-bottom: 20px;
      }
      .tutorial-section h2 {
        margin-bottom: 10px;
        color: #2196f3;
      }
      .tutorial-section p, .tutorial-section ul {
        line-height: 1.6;
      }
      .tutorial-section ul {
        padding-left: 20px;
      }
      .tutorial-section li {
        margin-bottom: 5px;
      }
      .tutorial-section img {
        margin-top: 10px;
      }
      
      /* Responsive Adjustments for iPad */
      @media only screen and (max-width: 768px) {
        #controls {
          width: 90%;
          height: auto;
        }
        #replayBox {
          top: 220px;
          left: 10px;
          width: 180px; /* Further reduced width */
        }
        #replayCanvas {
          width: 120px; /* Further reduced width */
          height: 120px; /* Further reduced height */
        }
        #replayTitle { font-size: 14px; }
        #replayInfo p { font-size: 10px; }
        #replayButtons { gap: 3px; }
        #playReplay, #stopReplay {
          padding: 4px 8px;
          font-size: 10px; /* Further reduced font size */
        }
      }
    </style>
  </head>
  <body>
    <!-- Title and Description -->
    <div id="title">Virtual Flight Simulator</div>
    <div id="description">Guide your drone through hoops and safely return home.</div>
    
    <!-- Top Right Buttons -->
    <button id="langToggle" class="btn-green">繁體中文</button>
    <button id="tutorialButton" class="btn-default">Tutorial</button>
    
    <!-- General Message -->
    <div id="message"></div>
    
    <!-- Alert Message -->
    <div id="alertMessage"></div>
    
    <!-- Top View Container (Navigation Topview) -->
    <div id="topViewContainer">
      <div id="topviewTitle"></div>
      <div id="topViewRenderer"></div>
    </div>
    
    <!-- Replay Box -->
    <div id="replayBox">
      <h3 id="replayTitle">Replay</h3>
      <canvas id="replayCanvas" width="150" height="150"></canvas> <!-- Reduced size -->
      <div id="replayInfo">
        <p>
          <span id="replayTotalDistanceLabel"></span><span id="replayDistance">0</span>
        </p>
        <p>
          <span id="replayFlightTimeLabel"></span><span id="replayTime">0 s</span>
        </p>
      </div>
      <div id="replayButtons">
        <button id="playReplay" class="btn-default">Play</button>
        <button id="stopReplay" class="btn-default">Stop</button>
      </div>
    </div>
    
    <!-- Hoop Table Container (with Hoop Status title) -->
    <div id="hoopTableContainer">
      <div id="hoopStatusTitle"></div>
      <div id="hoopTable">
        <div class="hoopCell" id="hoopCell-1">1</div>
        <div class="hoopCell" id="hoopCell-2">2</div>
        <div class="hoopCell" id="hoopCell-3">3</div>
        <div class="hoopCell" id="hoopCell-4">4</div>
        <div class="hoopCell" id="hoopCell-5">5</div>
        <div class="hoopCell" id="hoopCell-6">6</div>
        <div class="hoopCell" id="hoopCell-7">7</div>
        <div class="hoopCell" id="hoopCell-8">8</div>
        <div class="hoopCell" id="hoopCell-9">9</div>
        <div class="hoopCell" id="hoopCell-10">10</div>
      </div>
    </div>
    
    <!-- Stats Box -->
    <div id="statsBox">
      Total Flight Distance: 0<br>
      Horizontal Speed: 0<br>
      Flight Time: 0 s
    </div>
    
    <!-- Controls Container -->
    <div id="controls">
      <div id="info">Altitude: 0 | Distance: 0</div>
      <div id="main-controls">
        <div class="joystick-container" id="leftJoystick">
          <div class="joystick-base"></div>
          <div class="joystick-thumb"></div>
          <span class="joystick-label label-top">Throttle Up</span>
          <span class="joystick-label label-bottom">Throttle Down</span>
          <span class="joystick-label label-left">Yaw Left</span>
          <span class="joystick-label label-right">Yaw Right</span>
        </div>
        <div id="speedContainer">
          <div id="speedLabel">Speed</div>
          <input type="range" id="speedSlider" min="10" max="100" value="50" step="1" />
          <button id="toggleFlightPath" class="btn-default">Show Flight Path</button>
          <button id="rthBtn" class="btn-default">Return-to-Home (RTH)</button>
        </div>
        <div class="joystick-container" id="rightJoystick">
          <div class="joystick-base"></div>
          <div class="joystick-thumb"></div>
          <span class="joystick-label label-top">Pitch Forward</span>
          <span class="joystick-label label-bottom">Pitch Backward</span>
          <span class="joystick-label label-left">Roll Left</span>
          <span class="joystick-label label-right">Roll Right</span>
        </div>
      </div>
      <button id="btn-reset" class="btn-red">Reset</button>
    </div>
    
    <!-- Tutorial Modal -->
    <div id="tutorialModal">
      <div id="tutorialContent">
        <span class="closeTutorial">&times;</span>
        <h1>Virtual Flight Simulator Tutorial</h1>
        
        <div class="tutorial-section">
          <h2 data-key="tutorial_intro_title">Introduction</h2>
          <p data-key="tutorial_intro_text">
            Welcome to the Virtual Flight Simulator! This tutorial will guide you through the basics of piloting your drone, understanding 3D spatial concepts, and mastering the eight dimensions of movement.
          </p>
        </div>
        
        <div class="tutorial-section">
          <h2 data-key="tutorial_spatial_title">Understanding 3D Spatial Concepts</h2>
          <p data-key="tutorial_spatial_text">
            In a 3D environment, objects have three spatial dimensions: X (horizontal), Y (depth), and Z (vertical). Understanding these axes is crucial for maneuvering your drone accurately.
          </p>
          <img src="F01.jpg" alt="3D Axes" class="tutorial-image">
        </div>
        
        <div class="tutorial-section">
          <h2 data-key="tutorial_movement_title">The Eight Dimensions of Movement</h2>
          <p data-key="tutorial_movement_intro">
            Your drone can move in eight distinct ways, allowing for precise control:
          </p>
          <ul>
            <li><strong data-key="tutorial_movement_throttle_up">Throttle Up:</strong> Increases altitude.</li>
            <li><strong data-key="tutorial_movement_throttle_down">Throttle Down:</strong> Decreases altitude.</li>
            <li><strong data-key="tutorial_movement_yaw_left">Yaw Left:</strong> Rotates the drone to the left around its vertical axis.</li>
            <li><strong data-key="tutorial_movement_yaw_right">Yaw Right:</strong> Rotates the drone to the right around its vertical axis.</li>
            <li><strong data-key="tutorial_movement_pitch_forward">Pitch Forward:</strong> Tilts the drone forward, causing it to move forward.</li>
            <li><strong data-key="tutorial_movement_pitch_backward">Pitch Backward:</strong> Tilts the drone backward, causing it to move backward.</li>
            <li><strong data-key="tutorial_movement_roll_left">Roll Left:</strong> Tilts the drone to the left, causing lateral movement.</li>
            <li><strong data-key="tutorial_movement_roll_right">Roll Right:</strong> Tilts the drone to the right, causing lateral movement.</li>
          </ul>
          <img src="F02.jpg" alt="Drone Movements" class="tutorial-image">
        </div>
        
        <div class="tutorial-section">
          <h2 data-key="tutorial_controls_title">Controls Overview</h2>
          <p data-key="tutorial_controls_text">
            Use the virtual joysticks on the screen or your keyboard to control the drone:
          </p>
          <ul>
            <li><strong data-key="tutorial_controls_left_joystick">Left Joystick:</strong> Controls Throttle and Yaw.</li>
            <li><strong data-key="tutorial_controls_right_joystick">Right Joystick:</strong> Controls Pitch and Roll.</li>
            <li><strong data-key="tutorial_controls_keyboard">Keyboard Controls:</strong> 
              <ul>
                <li><strong>W/S:</strong> Throttle Up/Down</li>
                <li><strong>A/D:</strong> Yaw Left/Right</li>
                <li><strong>Arrow Up/Down:</strong> Pitch Forward/Backward</li>
                <li><strong>Arrow Left/Right:</strong> Roll Left/Right</li>
              </ul>
            </li>
          </ul>
        </div>
        
        <div class="tutorial-section">
          <h2 data-key="tutorial_flightpath_title">Flight Path and Hoops</h2>
          <p data-key="tutorial_flightpath_text">
            Navigate your drone through the hoops scattered around the environment. Successfully passing through all hoops will enable you to return home safely.
          </p>
          <img src="F03.jpg" class="tutorial-image" alt="Flight Path and Hoops">
        </div>
        
        <div class="tutorial-section">
          <h2 data-key="tutorial_rth_title">Return-to-Home (RTH)</h2>
          <p data-key="tutorial_rth_text">
            If you lose control or reach the maximum distance, activate the Return-to-Home (RTH) feature to automate the drone's return to its starting point.
          </p>
          <img src="F04.jpg" class="tutorial-image" alt="Return-to-Home">
        </div>
        
        <div class="tutorial-section">
          <h2 data-key="tutorial_safety_title">Safety Tips</h2>
          <ul>
            <li data-key="tutorial_safety_tip1">Always maintain awareness of your drone's altitude and distance.</li>
            <li data-key="tutorial_safety_tip2">Gradually practice each movement dimension to build confidence.</li>
            <li data-key="tutorial_safety_tip3">Avoid sudden or extreme movements to prevent crashes.</li>
            <li data-key="tutorial_safety_tip4">Use the tutorial to familiarize yourself with the controls before attempting challenging maneuvers.</li>
          </ul>
        </div>
        
        <div class="tutorial-section">
          <h2 data-key="tutorial_conclusion_title">Conclusion</h2>
          <p data-key="tutorial_conclusion_text">
            Mastering these controls and understanding 3D spatial relationships will enhance your piloting skills, ensuring safe and efficient navigation through the simulation and real-world scenarios.
          </p>
        </div>
      </div>
    </div>
    
    <!-- Include Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      /***********************
       * Global Variables
       ***********************/
      function lerp(a, b, t) { return a + (b - a) * t; }
      
      let disableDroneControls = false,
          flightEnded = false,
          takenOff = false,
          rthActive = false;
      let manualRTH = false;
      let currentExpectedHoop = 1,
          landedAtHome = false,
          allHoopsPassed = false;
      let totalDistance = 0, totalFlightTime = 0;
      let previousPosition = null;
      
      // Store timestamped positions
      let recordedFlightPath = []; // Each element: { pos: THREE.Vector3, t: <time> }
      let recordedDistance = 0, recordedTime = 0;
      
      let replayAnimationId,
          replayPaused = false,
          replayStartTime = 0, // in ms
          replayElapsedOffset = 0;
      
      let rthActivationTime = null,
          landingStartTime = null,
          landingCompleteTime = null;
      
      const replayCanvas = document.getElementById("replayCanvas");
      const replayCtx = replayCanvas.getContext("2d");
      
      let flightPathPoints = [];
      let flightPathLine = null;
      
      let fixedTopViewZoom = null;
      let fixedTopViewCenter = new THREE.Vector3();
      
      let isLanding = false;
      
      const flyAudio = new Audio("flysound.mp3"); flyAudio.loop = true;
      const bonusAudio = new Audio("bonus.mp3"); bonusAudio.loop = false;
      const sweetAudio = new Audio("sweet.mp3");
      const rth12Audio = new Audio("rth12.mp3");
      const land1Audio = new Audio("land1.mp3");
      let flyAudioPlaying = false;
      
      function initAudio() {
          [flyAudio, bonusAudio, sweetAudio, rth12Audio, land1Audio].forEach(audioElem => {
              const prevVolume = audioElem.volume;
              audioElem.muted = true;
              audioElem.play().then(() => {
                  audioElem.pause();
                  audioElem.currentTime = 0;
                  audioElem.muted = false;
                  audioElem.volume = prevVolume;
              }).catch(() => {});
          });
          document.removeEventListener("touchstart", initAudio);
      }
      document.addEventListener("touchstart", initAudio, false);
      
      // ------------------------------------
      // Helper Functions
      // ------------------------------------
      function createDirectionSprite(text, color="black") {
          const canvas = document.createElement("canvas");
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = color;
          ctx.font = "bold 90px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(text, canvas.width/2, canvas.height/2);
          const texture = new THREE.CanvasTexture(canvas);
          const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true }));
          sprite.scale.set(250,250,1);
          return sprite;
      }
      
      function updateDirectionSprite(sprite, text) {
          const canvas = document.createElement("canvas");
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "black";
          ctx.font = "bold 90px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(text, canvas.width/2, canvas.height/2);
          sprite.material.map.image = canvas;
          sprite.material.map.needsUpdate = true;
      }
      
      // New helper to create two hoop label sprites:
      function createHoopLabels(number) {
          function createSprite() {
              const canvas = document.createElement("canvas");
              canvas.width = 128;
              canvas.height = 128;
              const ctx = canvas.getContext("2d");
              ctx.clearRect(0,0,canvas.width,canvas.height);
              ctx.fillStyle = "yellow";
              ctx.font = "Bold 120px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(number.toString(), canvas.width/2, canvas.height/2);
              const texture = new THREE.CanvasTexture(canvas);
              const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true }));
              sprite.scale.set(4,4,1);
              return sprite;
          }
          const mainSprite = createSprite();  // for main view
          const tvSprite = createSprite();    // for top view
          tvSprite.material.rotation = Math.PI; // rotate 180° to cancel the topview canvas rotation
          mainSprite.layers.set(2);
          tvSprite.layers.set(1);
          return { main: mainSprite, tv: tvSprite };
      }
      
      function createHoopLabel_UpdateSprites(spriteObj, number, color, fontSize) {
          [spriteObj.main, spriteObj.tv].forEach(sprite => {
              const canvas = sprite.material.map.image;
              const ctx = canvas.getContext("2d");
              ctx.clearRect(0,0,canvas.width,canvas.height);
              ctx.fillStyle = color;
              ctx.font = "Bold " + fontSize + "px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(number.toString(), canvas.width/2, canvas.height/2);
              sprite.material.map.needsUpdate = true;
          });
      }
      
      function createHoopLabel_Reset(spriteObj, number) {
          // Reset to yellow with a larger font.
          createHoopLabel_UpdateSprites(spriteObj, number, "yellow", 120);
      }
      
      // ------------------------------------
      // Virtual Joystick Helper
      // ------------------------------------
      function attachJoystick(containerId, joystickObj) {
          const container = document.getElementById(containerId);
          const thumb = container.querySelector(".joystick-thumb");
          let dragging = false, pointerId = null, activeTouchId = null;
          let center = { x: 0, y: 0 };
          const maxDist = 40;
          joystickObj.active = false;
          function updateThumb(dx, dy) {
              const dist = Math.sqrt(dx*dx + dy*dy);
              if(dist > maxDist){ dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; }
              joystickObj.dx = dx/maxDist;
              joystickObj.dy = dy/maxDist;
              thumb.style.transform = `translate(${dx-40}px, ${dy-40}px)`;
          }
          function resetThumb() {
              dragging = false;
              joystickObj.active = false;
              activeTouchId = null;
              joystickObj.dx = 0;
              joystickObj.dy = 0;
              thumb.style.transform = "translate(-50%, -50%)";
          }
          function onPointerDown(e) {
              if(e.pointerType==="mouse" && e.button!==0) return;
              dragging = true;
              joystickObj.active = true;
              pointerId = e.pointerId;
              const rect = container.getBoundingClientRect();
              center.x = rect.left + rect.width/2;
              center.y = rect.top + rect.height/2;
              updateThumb(e.clientX-center.x, e.clientY-center.y);
              container.setPointerCapture(e.pointerId);
              e.preventDefault();
          }
          function onPointerMove(e) {
              if(!dragging || e.pointerId!==pointerId)return;
              updateThumb(e.clientX-center.x, e.clientY-center.y);
              e.preventDefault();
          }
          function onPointerUp(e) {
              if(e.pointerId!==pointerId)return;
              resetThumb();
              container.releasePointerCapture(e.pointerId);
              e.preventDefault();
          }
          function onTouchStart(e) {
              if(e.targetTouches.length>0){
                  dragging = true;
                  joystickObj.active = true;
                  const touch = e.targetTouches[0];
                  activeTouchId = touch.identifier;
                  const rect = container.getBoundingClientRect();
                  center.x = rect.left+rect.width/2;
                  center.y = rect.top+rect.height/2;
                  updateThumb(touch.clientX-center.x, touch.clientY-center.y);
                  e.preventDefault();
              }
          }
          function onTouchMove(e) {
              if(!dragging || activeTouchId===null) return;
              let targetTouch = null;
              for(let i=0;i<e.touches.length;i++){
                  if(e.touches[i].identifier===activeTouchId){
                      targetTouch = e.touches[i];
                      break;
                  }
              }
              if(targetTouch){ updateThumb(targetTouch.clientX-center.x, targetTouch.clientY-center.y); }
              e.preventDefault();
          }
          function onTouchEnd(e) {
              for(let i=0;i<e.changedTouches.length;i++){
                  if(e.changedTouches[i].identifier===activeTouchId){
                      resetThumb();
                      break;
                  }
              }
              e.preventDefault();
          }
          container.addEventListener("touchcancel", onTouchEnd, { passive: false });
          if(window.PointerEvent){
              container.addEventListener("pointerdown", onPointerDown, { passive: false });
              container.addEventListener("pointermove", onPointerMove, { passive: false });
              container.addEventListener("pointerup", onPointerUp, { passive: false });
              container.addEventListener("pointercancel", onPointerUp, { passive: false });
          }
          container.addEventListener("touchstart", onTouchStart, { passive: false });
          container.addEventListener("touchmove", onTouchMove, { passive: false });
          container.addEventListener("touchend", onTouchEnd, { passive: false });
      }
      
      // ------------------------------------
      // Three.js Scene Setup
      // ------------------------------------
      const scene = new THREE.Scene();
      
      /* 
         Two sets of directional sprites:
           • Main set (layer 2): used in flight simulation view.
           • Top-view set (layer 1): rotated 180° by setting material.rotation=Math.PI.
      */
      
      const mainNorthSprite = createDirectionSprite("NORTH");
      mainNorthSprite.position.set(0,8,540);
      mainNorthSprite.layers.set(2);
      scene.add(mainNorthSprite);
      const mainEastSprite = createDirectionSprite("EAST");
      mainEastSprite.position.set(-540,8,0);
      mainEastSprite.layers.set(2);
      scene.add(mainEastSprite);
      const mainSouthSprite = createDirectionSprite("SOUTH");
      mainSouthSprite.position.set(0,8,-540);
      mainSouthSprite.layers.set(2);
      scene.add(mainSouthSprite);
      const mainWestSprite = createDirectionSprite("WEST");
      mainWestSprite.position.set(540,8,0);
      mainWestSprite.layers.set(2);
      scene.add(mainWestSprite);
      
      const tvNorthSprite = createDirectionSprite("NORTH");
      tvNorthSprite.position.set(0,8,540);
      tvNorthSprite.layers.set(1);
      tvNorthSprite.material.rotation = Math.PI;
      const tvEastSprite = createDirectionSprite("EAST");
      tvEastSprite.position.set(-540,8,0);
      tvEastSprite.layers.set(1);
      tvEastSprite.material.rotation = Math.PI;
      const tvSouthSprite = createDirectionSprite("SOUTH");
      tvSouthSprite.position.set(0,8,-540);
      tvSouthSprite.layers.set(1);
      tvSouthSprite.material.rotation = Math.PI;
      const tvWestSprite = createDirectionSprite("WEST");
      tvWestSprite.position.set(540,8,0);
      tvWestSprite.layers.set(1);
      tvWestSprite.material.rotation = Math.PI;
      scene.add(tvNorthSprite, tvEastSprite, tvSouthSprite, tvWestSprite);
      
      // ------------------------------------
      // Home Marker
      // ------------------------------------
      function drawHomeMarker(ctx, padColor) {
          ctx.clearRect(0, 0, 256, 256);
          ctx.fillStyle = padColor;
          ctx.beginPath();
          ctx.arc(128, 128, 120, 0, Math.PI*2);
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.lineWidth = 10;
          ctx.stroke();
          ctx.fillStyle = "black";
          ctx.font = "bold 100px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("H",128,128);
      }
      function createHomeMarker() {
          const canvas = document.createElement("canvas");
          canvas.width = 256; canvas.height = 256;
          const ctx = canvas.getContext("2d");
          drawHomeMarker(ctx, "white");
          const texture = new THREE.CanvasTexture(canvas);
          const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent:true });
          const geometry = new THREE.CircleGeometry(5,32);
          const mesh = new THREE.Mesh(geometry, material);
          mesh.rotation.x = -Math.PI/2;
          mesh.position.set(0,0.01,0);
          mesh.userData = { canvas, ctx, texture };
          return mesh;
      }
      const homeMarker = createHomeMarker();
      scene.add(homeMarker);
      
      // ------------------------------------
      // Lighting
      // ------------------------------------
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100,200,100);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.bias = -0.001;
      scene.add(directionalLight);
      
      // ------------------------------------
      // Drone Setup
      // ------------------------------------
      const droneGroup = new THREE.Group();
      droneGroup.rotation.order = "YXZ";
      scene.add(droneGroup);
      const drone = { position: new THREE.Vector3(0,0.45,0), yaw:0, pitch:0, roll:0 };
      const droneBodyGeometry = new THREE.BoxGeometry(1,0.3,1);
      const droneBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
      const droneBody = new THREE.Mesh(droneBodyGeometry, droneBodyMaterial);
      droneGroup.add(droneBody);
      function createDroneLabel(text) {
          const canvas = document.createElement("canvas");
          canvas.width = 512; canvas.height = 128;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0,0,canvas.width,canvas.height);
          ctx.font = "bold 150px Arial";
          ctx.fillStyle = "white";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(text, canvas.width/2, canvas.height/2);
          const texture = new THREE.CanvasTexture(canvas);
          texture.center = new THREE.Vector2(0.5, 0.5);
          texture.rotation = Math.PI;
          texture.needsUpdate = true;
          const material = new THREE.MeshBasicMaterial({ map: texture, transparent:true });
          const geometry = new THREE.PlaneGeometry(0.9,0.3);
          const mesh = new THREE.Mesh(geometry, material);
          mesh.rotation.x = -Math.PI/2;
          mesh.position.set(0,0.16,0);
          return mesh;
      }
      const label = createDroneLabel("EdUHK");
      droneGroup.add(label);
      
      // ------------------------------------
      // Drone Propellers Setup
      // ------------------------------------
      const propellerGeometry = new THREE.BoxGeometry(0.2,0.05,0.9);
      const propellers = [];
      const frontLeft = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color:0xff0000 }));
      frontLeft.position.set(-0.50,0.2,0.55);
      droneGroup.add(frontLeft);
      propellers.push({ mesh: frontLeft, spinSpeed: +10, defaultAngle: THREE.Math.degToRad(45), currentSpinSpeed: +10 });
      const frontRight = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color:0xff0000 }));
      frontRight.position.set(0.50,0.2,0.55);
      droneGroup.add(frontRight);
      propellers.push({ mesh: frontRight, spinSpeed: -10, defaultAngle: THREE.Math.degToRad(135), currentSpinSpeed: -10 });
      const rearLeft = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color:0x00ff00 }));
      rearLeft.position.set(-0.50,0.2,-0.55);
      droneGroup.add(rearLeft);
      propellers.push({ mesh: rearLeft, spinSpeed: -10, defaultAngle: THREE.Math.degToRad(135), currentSpinSpeed: -10 });
      const rearRight = new THREE.Mesh(propellerGeometry, new THREE.MeshLambertMaterial({ color:0x00ff00 }));
      rearRight.position.set(0.50,0.2,-0.55);
      droneGroup.add(rearRight);
      propellers.push({ mesh: rearRight, spinSpeed: +10, defaultAngle: THREE.Math.degToRad(45), currentSpinSpeed: +10 });
      droneGroup.scale.set(3,3,3);
      droneGroup.traverse(child=> { if(child instanceof THREE.Mesh) child.castShadow = true; });
      const blinkSphereGeometry = new THREE.SphereGeometry(0.08,16,16);
      propellers.forEach((prop,index)=>{
          const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
          const blinkSpot = new THREE.Mesh(blinkSphereGeometry, mat);
          blinkSpot.position.set(0,0,0);
          prop.mesh.add(blinkSpot);
          prop.blinkOffset = index*(Math.PI/2);
          prop.blinkSpot = blinkSpot;
      });
      
      // ------------------------------------
      // Hoop Creation Functions
      // ------------------------------------
      function createCircularHoop(number) {
          const mainRadius = 9, tubeRadius = 0.2;
          const geometry = new THREE.TorusGeometry(mainRadius, tubeRadius, 16, 100);
          const material = new THREE.MeshLambertMaterial({ color:0xffa500 });
          const hoopMesh = new THREE.Mesh(geometry, material);
          // Create two hoop label sprites and add both to the hoop
          const labelSprites = createHoopLabels(number);
          labelSprites.main.position.set(0, mainRadius+2, 0);
          labelSprites.tv.position.copy(labelSprites.main.position);
          hoopMesh.add(labelSprites.main);
          hoopMesh.add(labelSprites.tv);
          return { mesh: hoopMesh, mainRadius, tubeRadius, entered: false, passed: false, number, labelSprites, type:"circular", originalColor:0xffa500 };
      }
      function createSquareHoop(number) {
          const outer = 9, inner = outer-0.2;
          const shape = new THREE.Shape();
          shape.moveTo(-outer,-outer);
          shape.lineTo(outer,-outer);
          shape.lineTo(outer,outer);
          shape.lineTo(-outer,outer);
          shape.lineTo(-outer,-outer);
          const hole = new THREE.Path();
          hole.moveTo(-inner,-inner);
          hole.lineTo(-inner,inner);
          hole.lineTo(inner,inner);
          hole.lineTo(inner,-inner);
          hole.lineTo(-inner,-inner);
          shape.holes.push(hole);
          const geometry = new THREE.ShapeGeometry(shape);
          const material = new THREE.MeshLambertMaterial({ color:0xff69b4, side: THREE.DoubleSide });
          const hoopMesh = new THREE.Mesh(geometry, material);
          const labelSprites = createHoopLabels(number);
          labelSprites.main.position.set(0, outer+2, 0);
          labelSprites.tv.position.copy(labelSprites.main.position);
          hoopMesh.add(labelSprites.main);
          hoopMesh.add(labelSprites.tv);
          return { mesh: hoopMesh, mainRadius: outer, tubeRadius: outer-inner, entered: false, passed: false, number, labelSprites, type:"square", originalColor:0xff69b4 };
      }
      function createTriangleHoop(number) {
          const rOuter = 9, rInner = rOuter - 0.2;
          const shape = new THREE.Shape();
          const outerVertices = [];
          for(let i=0;i<3;i++){
              const theta = THREE.Math.degToRad(90 + i*120);
              outerVertices.push(new THREE.Vector2(rOuter*Math.cos(theta), rOuter*Math.sin(theta)));
          }
          shape.moveTo(outerVertices[0].x, outerVertices[0].y);
          shape.lineTo(outerVertices[1].x, outerVertices[1].y);
          shape.lineTo(outerVertices[2].x, outerVertices[2].y);
          shape.closePath();
          const hole = new THREE.Path();
          const innerVertices = [];
          for(let i=0;i<3;i++){
              const theta = THREE.Math.degToRad(90 + i*120);
              innerVertices.push(new THREE.Vector2(rInner*Math.cos(theta), rInner*Math.sin(theta)));
          }
          hole.moveTo(innerVertices[innerVertices.length-1].x, innerVertices[innerVertices.length-1].y);
          for(let i=innerVertices.length-2;i>=0;i--){
              hole.lineTo(innerVertices[i].x, innerVertices[i].y);
          }
          hole.closePath();
          shape.holes.push(hole);
          const geometry = new THREE.ShapeGeometry(shape);
          const material = new THREE.MeshLambertMaterial({ color:0x800080, side: THREE.DoubleSide });
          const hoopMesh = new THREE.Mesh(geometry, material);
          const labelSprites = createHoopLabels(number);
          labelSprites.main.position.set(0, rOuter+2, 0);
          labelSprites.tv.position.copy(labelSprites.main.position);
          hoopMesh.add(labelSprites.main);
          hoopMesh.add(labelSprites.tv);
          return { mesh: hoopMesh, mainRadius: rOuter, tubeRadius: rOuter-rInner, entered: false, passed: false, number, labelSprites, type:"triangle", originalColor:0x800080 };
      }
      
      // ------------------------------------
      // Hoops Setup
      // ------------------------------------
      const altitudes = [10,15,20,25,30,35,40,45,50,55];
      const hoops = [];
      for(let i=1;i<=10;i++){
          let hoop;
          if(i<=4) hoop = createCircularHoop(i);
          else if(i<=7) hoop = createSquareHoop(i);
          else hoop = createTriangleHoop(i);
          hoop.mesh.position.set((Math.random()-0.5)*160, altitudes[i-1], (Math.random()-0.5)*160);
          scene.add(hoop.mesh);
          hoops.push(hoop);
      }
      
      // ------------------------------------
      // User Input Handling
      // ------------------------------------
      let translationSpeed = 50;
      const yawSpeed = 1.0, throttleSpeed = 10;
      const maxTilt = 0.5*Math.PI/6, throttleDeadZone = 0.2;
      const leftJoystickInput = { dx: 0, dy: 0 };
      const rightJoystickInput = { dx: 0, dy: 0 };
      attachJoystick("leftJoystick", leftJoystickInput);
      attachJoystick("rightJoystick", rightJoystickInput);
      const keys = {};
      document.addEventListener("keydown", e => { keys[e.code] = true; });
      document.addEventListener("keyup", e => { keys[e.code] = false; });
      document.addEventListener("keydown", event => {
          if(event.code==="KeyH"){ document.getElementById("rthBtn").click(); }
          else if(event.code==="KeyP"){ document.getElementById("toggleFlightPath").click(); }
          else if(event.code==="KeyR"){ document.getElementById("btn-reset").click(); }
      });
      const speedSlider = document.getElementById("speedSlider");
      speedSlider.addEventListener("input", function(){ translationSpeed = parseFloat(this.value); });
      
      let flightPathActive = false;
      const toggleFlightPathBtn = document.getElementById("toggleFlightPath");
      toggleFlightPathBtn.addEventListener("click", function(){
          flightPathActive = !flightPathActive;
          if(flightPathActive){
              toggleFlightPathBtn.innerHTML = translations[currentLanguage].hideFlightPath;
              flightPathPoints = [];
          } else {
              toggleFlightPathBtn.innerHTML = translations[currentLanguage].showFlightPath;
              if(flightPathLine){ scene.remove(flightPathLine); flightPathLine = null; }
          }
      });
      
      const rthBtn = document.getElementById("rthBtn");
      rthBtn.addEventListener("click", function(){
          if(drone.position.y < 1) return;
          manualRTH = true;
          rthActive = true;
          rthActivationTime = totalFlightTime;
          this.style.backgroundColor = "grey";
          leftJoystickInput.dx = 0; leftJoystickInput.dy = 0;
          document.querySelector("#leftJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
          rightJoystickInput.dx = 0; rightJoystickInput.dy = 0;
          document.querySelector("#rightJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
          const msgDiv = document.getElementById("message");
          msgDiv.style.backgroundColor = "rgba(0,128,0,0.9)";
          msgDiv.style.display = "block";
          msgDiv.innerHTML = translations[currentLanguage].rthInProgress;
          if(rth12Audio.paused){
              rth12Audio.currentTime = 0;
              rth12Audio.play().catch(err=>console.log("Error playing rth12Audio:",err));
          }
          if(flyAudioPlaying){
              flyAudio.pause();
              flyAudio.currentTime = 0;
              flyAudioPlaying = false;
          }
      });
      
     
      // ------------------------------------
      // Translations Setup
      // ------------------------------------
      const translations = {
          en: {
              title: "Virtual Flight Simulator",
              description: "Guide your drone through hoops and safely return home.",
              allHoopsPassed: "All hoops passed! Now fly back and land on the home point (marked with H).",
              landingMessage: "Congratulations! You landed safely at home.<br><button id='newGameButton' onclick='resetDrone()' class='btn-default'>New Game</button>",
              automaticLanding: "Automatic Landing",
              reset: "Reset",
              showFlightPath: "Show Flight Path",
              hideFlightPath: "Hide Flight Path",
              throttleUp: "Throttle Up",
              throttleDown: "Throttle Down",
              yawLeft: "Yaw Left",
              yawRight: "Yaw Right",
              pitchForward: "Pitch Forward",
              pitchBackward: "Pitch Backward",
              rollLeft: "Roll Left",
              rollRight: "Roll Right",
              zoomIn: "Zoom In",
              zoomOut: "Zoom Out",
              altitude: "Altitude",
              distance: "Distance",
              totalFlightDistance: "Total Flight Distance: ",
              flightSpeed: "Horizontal Speed: ",
              flightTime: "Flight Time: ",
              rthInProgress: "Return-to-Home in Progress",
              returnToHome: "Return-to-Home (RTH)",
              topHome: "Home",
              back: "Back",
              speed: "Speed",
              replayTitle: "Replay",
              playReplay: "Play",
              stopReplay: "Stop",
              noFlightData: "No Flight Data",
              replayTotalDistance: "Total Distance: ",
              replayFlightTime: "Flight Time: ",
              timeLabel: "Time: ",
              rthActivatedLabel: "RTH Activated",
              landingLabel: "Landing",
              north: "NORTH",
              east: "EAST",
              south: "SOUTH",
              west: "WEST",
              heightAlert: "Altitude limit reached",
              distanceAlert: "Distance limit reached - initiating RTH",
              navigationTopview: "Flight Path Topview",
              hoopStatus: "Hoop Status",
              tutorialTitle: "Tutorial",
              closeTutorial: "Close",
              /* Tutorial Translations */
              tutorial_intro_title: "Introduction",
              tutorial_intro_text: "Welcome to the Virtual Flight Simulator! This tutorial will guide you through the basics of piloting your drone, understanding 3D spatial concepts, and mastering the eight dimensions of movement.",
              tutorial_spatial_title: "Understanding 3D Spatial Concepts",
              tutorial_spatial_text: "In a 3D environment, objects have three spatial dimensions: X (horizontal), Y (depth), and Z (vertical). Understanding these axes is crucial for maneuvering your drone accurately.",
              tutorial_movement_title: "The Eight Dimensions of Movement",
              tutorial_movement_intro: "Your drone can move in eight distinct ways, allowing for precise control:",
              tutorial_movement_throttle_up: "Throttle Up",
              tutorial_movement_throttle_down: "Throttle Down",
              tutorial_movement_yaw_left: "Yaw Left",
              tutorial_movement_yaw_right: "Yaw Right",
              tutorial_movement_pitch_forward: "Pitch Forward",
              tutorial_movement_pitch_backward: "Pitch Backward",
              tutorial_movement_roll_left: "Roll Left",
              tutorial_movement_roll_right: "Roll Right",
              tutorial_controls_title: "Controls Overview",
              tutorial_controls_text: "Use the virtual joysticks on the screen or your keyboard to control the drone:",
              tutorial_controls_left_joystick: "Left Joystick",
              tutorial_controls_right_joystick: "Right Joystick",
              tutorial_controls_keyboard: "Keyboard Controls",
              tutorial_flightpath_title: "Flight Path and Hoops",
              tutorial_flightpath_text: "Navigate your drone through the hoops scattered around the environment. Successfully passing through all hoops will enable you to return home safely.",
              tutorial_rth_title: "Return-to-Home (RTH)",
              tutorial_rth_text: "If you lose control or reach the maximum distance, activate the Return-to-Home (RTH) feature to automate the drone's return to its starting point.",
              tutorial_safety_title: "Safety Tips",
              tutorial_safety_tip1: "Always maintain awareness of your drone's altitude and distance.",
              tutorial_safety_tip2: "Gradually practice each movement dimension to build confidence.",
              tutorial_safety_tip3: "Avoid sudden or extreme movements to prevent crashes.",
              tutorial_safety_tip4: "Use the tutorial to familiarize yourself with the controls before attempting challenging maneuvers.",
              tutorial_conclusion_title: "Conclusion",
              tutorial_conclusion_text: "Mastering these controls and understanding 3D spatial relationships will enhance your piloting skills, ensuring safe and efficient navigation through the simulation and real-world scenarios."
          },
          zh: {
              title: "四軸無人機飛行模擬",
              description: "操控無人機穿越環門並安全降落於起飛點。",
              allHoopsPassed: "所有環門已通過！請飛回並在以「H」標示的起飛點著陸。",
              landingMessage: "恭喜！您已安全降落在起飛點。<br><button id='newGameButton' onclick='resetDrone()' class='btn-default'>新遊戲</button>",
              automaticLanding: "自動降落",
              reset: "重置",
              showFlightPath: "顯示飛行路徑",
              hideFlightPath: "隱藏飛行路徑",
              throttleUp: "上升",
              throttleDown: "下降",
              yawLeft: "左轉",
              yawRight: "右轉",
              pitchForward: "前飛",
              pitchBackward: "後飛",
              rollLeft: "左飛",
              rollRight: "右飛",
              zoomIn: "放大",
              zoomOut: "縮小",
              altitude: "高度",
              distance: "距離",
              totalFlightDistance: "飛行總距離：",
              flightSpeed: "飛行速度：",
              flightTime: "飛行時間：",
              rthInProgress: "正在返航",
              returnToHome: "自動返航 (RTH)",
              topHome: "原位",
              back: "返回",
              speed: "速度",
              replayTitle: "回放",
              playReplay: "播放",
              stopReplay: "停止",
              noFlightData: "沒有飛行數據",
              replayTotalDistance: "總距離：",
              replayFlightTime: "飛行時間：",
              timeLabel: "時間: ",
              rthActivatedLabel: "已啟動自動返航",
              landingLabel: "降落中",
              north: "北",
              east: "東",
              south: "南",
              west: "西",
              heightAlert: "高度限制已達",
              distanceAlert: "距離限制已達 - 啟動自動返航",
              navigationTopview: "飛行路徑頂視圖",
              hoopStatus: "環門狀態",
              tutorialTitle: "教程",
              closeTutorial: "關閉",
              /* Tutorial Translations */
              tutorial_intro_title: "介紹",
              tutorial_intro_text: "歡迎使用四軸無人機飛行模擬！本教程將指導您瞭解操控無人機的基礎知識、3D 空間概念以及掌握八個運動維度。",
              tutorial_spatial_title: "理解3D空間概念",
              tutorial_spatial_text: "在3D環境中，物體具有三個空間維度：X（水平）、Y（深度）和Z（垂直）。理解這些軸對於精確操控無人機至關重要。",
              tutorial_movement_title: "八個運動維度",
              tutorial_movement_intro: "您的無人機可以在八個不同的方向移動，以實現精確控制：",
              tutorial_movement_throttle_up: "上升",
              tutorial_movement_throttle_down: "下降",
              tutorial_movement_yaw_left: "左轉",
              tutorial_movement_yaw_right: "右轉",
              tutorial_movement_pitch_forward: "前飛",
              tutorial_movement_pitch_backward: "後飛",
              tutorial_movement_roll_left: "左飛",
              tutorial_movement_roll_right: "右飛",
              tutorial_controls_title: "控制概覽",
              tutorial_controls_text: "使用屏幕上的虛擬搖桿或鍵盤來控制無人機：",
              tutorial_controls_left_joystick: "左搖桿",
              tutorial_controls_right_joystick: "右搖桿",
              tutorial_controls_keyboard: "鍵盤控制",
              tutorial_flightpath_title: "飛行路徑與環門",
              tutorial_flightpath_text: "導航您的無人機穿越環境中散布的環門。成功通過所有環門後，您將能安全返回家中。",
              tutorial_rth_title: "自動返航 (RTH)",
              tutorial_rth_text: "如果您失去控制或達到最大距離，啟動自動返航(RTH)功能，無人機將自動返回起始點。",
              tutorial_safety_title: "安全提示",
              tutorial_safety_tip1: "始終保持對無人機的高度和距離的警覺。",
              tutorial_safety_tip2: "逐漸練習每個運動維度以建立信心。",
              tutorial_safety_tip3: "避免突然或劇烈的動作以防止墜落。",
              tutorial_safety_tip4: "使用教程熟悉控制方式，再嘗試具挑戰性的操作。",
              tutorial_conclusion_title: "結論",
              tutorial_conclusion_text: "掌握這些控制方式並理解3D空間關係將提升您的飛行技能，確保在模擬和現實情境中的安全高效導航。"
          }
      };
      let currentLanguage = "en";
      function updateUIText() {
          document.getElementById("title").innerHTML = translations[currentLanguage].title;
          document.getElementById("description").innerHTML = translations[currentLanguage].description;
          document.getElementById("btn-reset").innerHTML = translations[currentLanguage].reset;
          document.getElementById("backButton").innerHTML = translations[currentLanguage].back;
          const flightToggle = document.getElementById("toggleFlightPath");
          if (flightToggle) {
              flightToggle.innerHTML = flightPathActive ? translations[currentLanguage].hideFlightPath : translations[currentLanguage].showFlightPath;
          }
          document.querySelector("#leftJoystick .label-top").textContent = translations[currentLanguage].throttleUp;
          document.querySelector("#leftJoystick .label-bottom").textContent = translations[currentLanguage].throttleDown;
          document.querySelector("#leftJoystick .label-left").textContent = translations[currentLanguage].yawLeft;
          document.querySelector("#leftJoystick .label-right").textContent = translations[currentLanguage].yawRight;
          document.querySelector("#rightJoystick .label-top").textContent = translations[currentLanguage].pitchForward;
          document.querySelector("#rightJoystick .label-bottom").textContent = translations[currentLanguage].pitchBackward;
          document.querySelector("#rightJoystick .label-left").textContent = translations[currentLanguage].rollLeft;
          document.querySelector("#rightJoystick .label-right").textContent = translations[currentLanguage].rollRight;
          document.getElementById("rthBtn").innerHTML = translations[currentLanguage].returnToHome;
          document.getElementById("speedLabel").innerHTML = translations[currentLanguage].speed;
          document.getElementById("replayTitle").innerHTML = translations[currentLanguage].replayTitle;
          document.getElementById("playReplay").innerHTML = translations[currentLanguage].playReplay;
          document.getElementById("stopReplay").innerHTML = translations[currentLanguage].stopReplay;
          document.getElementById("replayTotalDistanceLabel").textContent = translations[currentLanguage].replayTotalDistance;
          document.getElementById("replayFlightTimeLabel").textContent = translations[currentLanguage].replayFlightTime;
          
          // Update directional sprites for both views.
          updateDirectionSprite(mainNorthSprite, translations[currentLanguage].north);
          updateDirectionSprite(mainEastSprite, translations[currentLanguage].east);
          updateDirectionSprite(mainSouthSprite, translations[currentLanguage].south);
          updateDirectionSprite(mainWestSprite, translations[currentLanguage].west);
          
          updateDirectionSprite(tvNorthSprite, translations[currentLanguage].north);
          tvNorthSprite.material.rotation = Math.PI;
          updateDirectionSprite(tvEastSprite, translations[currentLanguage].east);
          tvEastSprite.material.rotation = Math.PI;
          updateDirectionSprite(tvSouthSprite, translations[currentLanguage].south);
          tvSouthSprite.material.rotation = Math.PI;
          updateDirectionSprite(tvWestSprite, translations[currentLanguage].west);
          tvWestSprite.material.rotation = Math.PI;
          
          // Update title on top view container
          document.getElementById("topviewTitle").textContent = translations[currentLanguage].navigationTopview;
          // Update title above hoop table
          document.getElementById("hoopStatusTitle").textContent = translations[currentLanguage].hoopStatus;
          
          // Update tutorial button text
          document.getElementById("tutorialButton").textContent = translations[currentLanguage].tutorialTitle;
          
          // Update Tutorial Modal Content
          const tutorialContent = document.getElementById("tutorialContent");
          const sections = tutorialContent.getElementsByClassName("tutorial-section");
          for(let i=0; i<sections.length; i++){
              const section = sections[i];
              const header = section.querySelector("h2");
              const paragraphs = section.querySelectorAll("p, ul, li");
              const headingKey = header.getAttribute("data-key");
              if (translations[currentLanguage][headingKey]) {
                  header.textContent = translations[currentLanguage][headingKey];
              }
              paragraphs.forEach(element => {
                  const key = element.getAttribute("data-key");
                  if (key && translations[currentLanguage][key]) {
                      if(element.tagName.toLowerCase() === 'strong'){
                          element.textContent = translations[currentLanguage][key] + ":";
                      } else {
                          element.textContent = translations[currentLanguage][key];
                      }
                  }
              });
          }
      }
      document.getElementById("langToggle").addEventListener("click", function(){
          if(currentLanguage==="en"){ currentLanguage="zh"; this.innerHTML="English"; }
          else { currentLanguage="en"; this.innerHTML="繁體中文"; }
          updateUIText();
      });
      
      // ------------------------------------
      // Tutorial Modal Functionality
      // ------------------------------------
      const tutorialModal = document.getElementById("tutorialModal");
      const tutorialButton = document.getElementById("tutorialButton");
      const closeTutorial = document.querySelector(".closeTutorial");
      
      // Open the modal
      tutorialButton.onclick = function() {
          tutorialModal.style.display = "block";
      }
      
      // Close the modal
      closeTutorial.onclick = function() {
          tutorialModal.style.display = "none";
      }
      
      // Close the modal when clicking outside of the content
      window.onclick = function(event) {
          if (event.target == tutorialModal) {
              tutorialModal.style.display = "none";
          }
      }
      
      // ------------------------------------
      // Main Renderer Setup
      // ------------------------------------
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x87ceeb);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
      // Main camera sees default (layer 0) and main directional sprites (layer 2)
      camera.layers.disableAll();
      camera.layers.enable(0);
      camera.layers.enable(2);
      window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth/window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // ------------------------------------
      // Top View Renderer & Orthographic Camera
      // ------------------------------------
      const topViewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      topViewRenderer.setSize(200, 200);
      topViewRenderer.setClearColor(0x000000, 0);
      const topViewDiv = document.getElementById("topViewRenderer");
      topViewDiv.appendChild(topViewRenderer.domElement);
      const d = 400;
      const DEFAULT_TOP_VIEW_ZOOM = 5;
      const topViewCamera = new THREE.OrthographicCamera(-d, d, d, -d, 0.1, 2000);
      topViewCamera.position.set(0, 1000, 0);
      topViewCamera.lookAt(new THREE.Vector3(0, 0, 0));
      topViewCamera.zoom = DEFAULT_TOP_VIEW_ZOOM;
      topViewCamera.updateProjectionMatrix();
      fixedTopViewZoom = topViewCamera.zoom;
      fixedTopViewCenter.copy(topViewCamera.position);
      // Top view camera sees default (layer 0) and top view directional sprites (layer 1)
      topViewCamera.layers.disableAll();
      topViewCamera.layers.enable(0);
      topViewCamera.layers.enable(1);
      
      // ------------------------------------
      // Ground & Grid
      // ------------------------------------
      const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xededed });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI/2;
      ground.receiveShadow = true;
      scene.add(ground);
      const grid = new THREE.GridHelper(1000,50,0x000000,0x000000);
      scene.add(grid);
      
      // ------------------------------------
      // Global Clock
      // ------------------------------------
      const clock = new THREE.Clock();
      
      // ------------------------------------
      // Replay Functions
      // ------------------------------------
      function computeReplayTransform(points) {
          let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
          points.forEach(obj => {
              const pt = obj.pos;
              if(pt.x < minX) minX = pt.x;
              if(pt.x > maxX) maxX = pt.x;
              if(pt.z < minZ) minZ = pt.z;
              if(pt.z > maxZ) maxZ = pt.z;
          });
          const width = maxX - minX, height = maxZ - minZ;
          const marginFactor = 1.2;
          const scaleX = replayCanvas.width/(width*marginFactor||1);
          const scaleY = replayCanvas.height/(height*marginFactor||1);
          const scale = Math.min(scaleX, scaleY);
          const centerX = (minX+maxX)/2;
          const centerZ = (minZ+maxZ)/2;
          const offsetX = replayCanvas.width/2 - centerX*scale;
          const offsetY = replayCanvas.height/2 - centerZ*scale;
          return { scale, offsetX, offsetY };
      }
      
      function getInterpolatedPosition(currentReplayTime) {
          if(recordedFlightPath.length === 0) return null;
          if(currentReplayTime <= recordedFlightPath[0].t) {
              return recordedFlightPath[0].pos.clone();
          }
          if(currentReplayTime >= recordedFlightPath[recordedFlightPath.length-1].t) {
              return recordedFlightPath[recordedFlightPath.length-1].pos.clone();
          }
          for(let i=0; i<recordedFlightPath.length-1; i++){
              let a = recordedFlightPath[i];
              let b = recordedFlightPath[i+1];
              if(currentReplayTime >= a.t && currentReplayTime <= b.t) {
                  let ratio = (currentReplayTime - a.t) / (b.t - a.t);
                  let interp = a.pos.clone().lerp(b.pos, ratio);
                  return interp;
              }
          }
          return recordedFlightPath[recordedFlightPath.length-1].pos.clone();
      }
      
      function animateReplay() {
          if (!replayPaused) {
              replayCtx.clearRect(0,0,replayCanvas.width,replayCanvas.height);
          }
          if(recordedFlightPath.length===0){
              replayCtx.save();
              replayCtx.translate(replayCanvas.width/2, replayCanvas.height/2);
              replayCtx.rotate(Math.PI);
              replayCtx.fillStyle = "#000";
              replayCtx.font = "14px Arial";
              replayCtx.textAlign = "center";
              replayCtx.fillText(translations[currentLanguage].noFlightData||"No Flight Data", 0,0);
              replayCtx.restore();
              return;
          }
          const { scale, offsetX, offsetY } = computeReplayTransform(recordedFlightPath);
          
          replayCtx.strokeStyle = "#ff0000";
          replayCtx.lineWidth = 2;
          replayCtx.beginPath();
          replayCtx.moveTo(recordedFlightPath[0].pos.x*scale+offsetX, recordedFlightPath[0].pos.z*scale+offsetY);
          recordedFlightPath.forEach(obj=>{
              replayCtx.lineTo(obj.pos.x*scale+offsetX, obj.pos.z*scale+offsetY);
          });
          replayCtx.stroke();
          
          let elapsed = (performance.now() - replayStartTime)/1000 + replayElapsedOffset;
          let currentReplayTime = Math.min(elapsed, recordedTime);
          
          let currentPos = getInterpolatedPosition(currentReplayTime);
          if(currentPos){
              replayCtx.fillStyle = "#0000ff";
              replayCtx.beginPath();
              replayCtx.arc(currentPos.x*scale+offsetX, currentPos.z*scale+offsetY, 4, 0, Math.PI*2);
              replayCtx.fill();
          }
          
          hoops.forEach(hoop=>{
              const hoopPos = hoop.mesh.position;
              const x = hoopPos.x*scale+offsetX;
              const y = hoopPos.z*scale+offsetY;
              replayCtx.save();
              replayCtx.translate(x,y);
              replayCtx.rotate(Math.PI);
              replayCtx.fillStyle = "black";
              replayCtx.font = "14px Arial";
              replayCtx.textAlign = "center";
              replayCtx.textBaseline = "middle";
              replayCtx.fillText(hoop.number.toString(), 0,0);
              replayCtx.restore();
          });
          
          replayCtx.save();
          replayCtx.setTransform(1,0,0,1,0,0);
          replayCtx.translate(replayCanvas.width/2, replayCanvas.height/2);
          replayCtx.rotate(Math.PI);
          replayCtx.translate(-replayCanvas.width/2, -replayCanvas.height/2);
          replayCtx.font = "bold 14px Arial";
          replayCtx.fillStyle = "blue";
          replayCtx.textAlign = "right";
          replayCtx.fillText(translations[currentLanguage].timeLabel + currentReplayTime.toFixed(1) + " s", replayCanvas.width-10, 20);
          
          if(rthActivationTime !== null && currentReplayTime >= rthActivationTime &&
             (landingStartTime === null || currentReplayTime < landingStartTime)){
              replayCtx.fillStyle = "red";
              replayCtx.fillText(translations[currentLanguage].rthActivatedLabel, replayCanvas.width-10, 40);
          } else if(landingStartTime !== null && currentReplayTime >= landingStartTime && currentReplayTime < landingCompleteTime){
              replayCtx.fillStyle = "red";
              replayCtx.fillText(translations[currentLanguage].landingLabel, replayCanvas.width-10, 40);
          }
          replayCtx.restore();
          
          if(elapsed < recordedTime){
              replayAnimationId = requestAnimationFrame(animateReplay);
          } else {
              replayAnimationId = requestAnimationFrame(animateReplay);
          }
      }
      
      document.getElementById("playReplay").addEventListener("click", function(){
          if(recordedFlightPath.length===0){
              replayCtx.clearRect(0,0,replayCanvas.width,replayCanvas.height);
              replayCtx.save();
              replayCtx.translate(replayCanvas.width/2, replayCanvas.height/2);
              replayCtx.rotate(Math.PI);
              replayCtx.fillStyle = "#000";
              replayCtx.font = "14px Arial";
              replayCtx.textAlign = "center";
              replayCtx.fillText(translations[currentLanguage].noFlightData||"No Flight Data", 0,0);
              replayCtx.restore();
              return;
          }
          document.getElementById("replayDistance").textContent = recordedDistance.toFixed(1);
          document.getElementById("replayTime").textContent = recordedTime.toFixed(1) + " s";
          replayElapsedOffset = 0;
          replayStartTime = performance.now();
          replayPaused = false;
          cancelAnimationFrame(replayAnimationId);
          animateReplay();
      });
      
      document.getElementById("stopReplay").addEventListener("click", function(){
          if(!replayPaused){
              replayElapsedOffset += (performance.now() - replayStartTime)/1000;
              cancelAnimationFrame(replayAnimationId);
              replayPaused = true;
              this.textContent = translations[currentLanguage].playReplay;
          } else {
              replayStartTime = performance.now();
              replayPaused = false;
              this.textContent = translations[currentLanguage].stopReplay;
              animateReplay();
          }
      });
      
      // ------------------------------------
      // Live Flight Path in Top View
      // ------------------------------------
      function updateLiveFlightPath() {
          if(flightPathActive && takenOff) {
              flightPathPoints.push(drone.position.clone());
              if(flightPathPoints.length > 500) { flightPathPoints.shift(); }
              if(flightPathLine) { scene.remove(flightPathLine); }
              const geometry = new THREE.BufferGeometry().setFromPoints(flightPathPoints);
              const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
              flightPathLine = new THREE.Line(geometry, material);
              scene.add(flightPathLine);
      
              if(rthActive && drone.position.y < 2) {
                  if(!isLanding) {
                      isLanding = true;
                      if(landingStartTime === null) landingStartTime = totalFlightTime;
                      fixedTopViewZoom = topViewCamera.zoom;
                      fixedTopViewCenter.copy(topViewCamera.position);
                  }
                  topViewCamera.zoom = DEFAULT_TOP_VIEW_ZOOM;
                  topViewCamera.position.copy(fixedTopViewCenter);
                  topViewCamera.updateProjectionMatrix();
              } else if(!isLanding) {
                  let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                  flightPathPoints.forEach(pt=>{
                      if(pt.x < minX) minX = pt.x;
                      if(pt.x > maxX) maxX = pt.x;
                      if(pt.z < minZ) minZ = pt.z;
                      if(pt.z > maxZ) maxZ = pt.z;
                  });
                  const L = Math.max(maxX-minX, maxZ-minZ)||1;
                  const marginFactor = 2.0;
                  let desiredZoom = L<10 ? DEFAULT_TOP_VIEW_ZOOM : (2*d)/(L*marginFactor);
                  topViewCamera.zoom = desiredZoom;
                  fixedTopViewZoom = desiredZoom;
                  let centerX = (minX+maxX)/2;
                  let centerZ = (minZ+maxZ)/2;
                  topViewCamera.position.x = centerX;
                  topViewCamera.position.z = centerZ;
                  fixedTopViewCenter.set(centerX, topViewCamera.position.y, centerZ);
                  topViewCamera.updateProjectionMatrix();
              }
          }
      }
      
      // ------------------------------------
      // Main Animation Loop (Simulation)
      // ------------------------------------
      let horizontalSpeed = 0;
      function animate() {
          requestAnimationFrame(animate);
          const delta = clock.getDelta();
          if(previousPosition){
              const dx = drone.position.x - previousPosition.x;
              const dz = drone.position.z - previousPosition.z;
              horizontalSpeed = Math.sqrt(dx*dx+dz*dz)/delta;
          }
          if(takenOff && !flightEnded) { totalFlightTime += delta; }
          if(previousPosition){
              const dx = drone.position.x - previousPosition.x;
              const dz = drone.position.z - previousPosition.z;
              const dHoriz = Math.sqrt(dx*dx+dz*dz);
              totalDistance += dHoriz;
          } else { previousPosition = drone.position.clone(); }
          previousPosition = drone.position.clone();
      
          document.getElementById("statsBox").innerHTML =
              translations[currentLanguage].totalFlightDistance + totalDistance.toFixed(1) + "<br>" +
              translations[currentLanguage].flightSpeed + horizontalSpeed.toFixed(1) + "<br>" +
              translations[currentLanguage].flightTime + totalFlightTime.toFixed(1) + " s";
      
          if(takenOff){
              recordedFlightPath.push({ pos: drone.position.clone(), t: totalFlightTime });
          }
      
          if(flightEnded && recordedFlightPath.length>0 && recordedDistance===0 && recordedTime===0){
              recordedDistance = totalDistance;
              recordedTime = totalFlightTime;
              if(landingCompleteTime === null) landingCompleteTime = totalFlightTime;
              document.getElementById("replayDistance").textContent = recordedDistance.toFixed(1);
              document.getElementById("replayTime").textContent = recordedTime.toFixed(1) + " s";
          }
      
          const alertMessages = [];
          if(drone.position.y >= 250){
              drone.position.y = 250;
              alertMessages.push(translations[currentLanguage].heightAlert);
          }
          const homeDistance = Math.sqrt(drone.position.x*drone.position.x + drone.position.z*drone.position.z);
          if(homeDistance >= 500 && !manualRTH){
              rthActive = true;
              if(rthActivationTime === null){ rthActivationTime = totalFlightTime; }
              leftJoystickInput.dx = 0; leftJoystickInput.dy = 0;
              document.querySelector("#leftJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
              rightJoystickInput.dx = 0; rightJoystickInput.dy = 0;
              document.querySelector("#rightJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
              alertMessages.push(translations[currentLanguage].distanceAlert);
          }
          const alertEl = document.getElementById("alertMessage");
          if(alertMessages.length > 0){
              alertEl.innerHTML = alertMessages.join("<br>");
              alertEl.style.backgroundColor = "rgba(255, 0, 0, 0.9)";
              alertEl.style.display = "block";
              alertEl.classList.add("blinking");
          } else {
              alertEl.style.display = "none";
              alertEl.classList.remove("blinking");
          }
      
          if(!disableDroneControls && !flightEnded){
              if(rthActive){
                  const hDist = new THREE.Vector2(drone.position.x,drone.position.z).length();
                  if(hDist > 1){
                      const msgDiv = document.getElementById("message");
                      msgDiv.style.backgroundColor = "rgba(0, 128, 0, 0.9)";
                      msgDiv.style.display = "block";
                      msgDiv.innerHTML = manualRTH ? translations[currentLanguage].rthInProgress 
                          : (translations[currentLanguage].rthInProgress+"<br>"+translations[currentLanguage].distanceAlert);
                      if(rth12Audio.paused){
                          rth12Audio.currentTime=0;
                          rth12Audio.play().catch(err=>console.log("Error playing rth12Audio:", err));
                      }
                      if(!land1Audio.paused){
                          land1Audio.pause();
                          land1Audio.currentTime = 0;
                      }
                      const dir = new THREE.Vector3(-drone.position.x,0,-drone.position.z).normalize();
                      drone.yaw = lerp(drone.yaw, Math.atan2(dir.x,dir.z), 0.05);
                      drone.position.x += dir.x * 30 * delta;
                      drone.position.z += dir.z * 30 * delta;
                  } else {
                      const msgDiv = document.getElementById("message");
                      msgDiv.style.display = "block";
                      msgDiv.style.backgroundColor = "rgba(0,128,0,0.9)";
                      msgDiv.innerHTML = translations[currentLanguage].automaticLanding;
                      if(!rth12Audio.paused){ rth12Audio.pause(); rth12Audio.currentTime=0; }
                      if(land1Audio.paused){
                          land1Audio.currentTime=0;
                          land1Audio.play().catch(err=>console.log("Error playing land1Audio:", err));
                      }
                      if(drone.position.y>0.45){ drone.position.y -= 5*delta; }
                      drone.yaw = lerp(drone.yaw, 0, 0.05);
                      drone.pitch = lerp(drone.pitch, 0, 0.1);
                      drone.roll = lerp(drone.roll, 0, 0.1);
                      if(landingStartTime === null) { landingStartTime = totalFlightTime; }
                      if(drone.position.y <= 0.45+0.01){
                          drone.position.y = 0.45;
                          land1Audio.pause();
                          land1Audio.currentTime = 0;
                          if(homeDistance < 10){
                              flightEnded = true;
                              disableDroneControls = true;
                              rthActive = false;
                              manualRTH = false;
                              if(landingCompleteTime === null) { landingCompleteTime = totalFlightTime; }
                              document.getElementById("message").style.display = "none";
                          } else {
                              takenOff = false;
                              document.getElementById("message").style.display = "none";
                          }
                          document.querySelector("#leftJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
                          document.querySelector("#rightJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
                      }
                  }
              } else {
                  syncJoystickWithKeyboard();
                  let rawThrottle = (-leftJoystickInput.dy)+((keys["KeyW"]?1:0)-(keys["KeyS"]?1:0));
                  let throttleInput = (Math.abs(rawThrottle)>= throttleDeadZone)? rawThrottle : 0;
                  drone.position.y += throttleInput * throttleSpeed * delta;
                  if(drone.position.y < 0.45){ drone.position.y = 0.45; }
                  if(!takenOff && throttleInput!==0 && drone.position.y>1.0){
                      takenOff = true;
                      recordedFlightPath = [];
                      recordedDistance = 0;
                      recordedTime = 0;
                  }
                  if(drone.position.y > 0.45){
                      let yawInput = (-leftJoystickInput.dx)+((keys["KeyA"]?1:0)-(keys["KeyD"]?1:0));
                      drone.yaw += yawSpeed*yawInput*delta;
                      let pitchInput = (-rightJoystickInput.dy)+((keys["ArrowUp"]?1:0)-(keys["ArrowDown"]?1:0));
                      let desiredPitch = pitchInput*maxTilt;
                      drone.pitch = lerp(drone.pitch, desiredPitch, 0.1);
                      let rollInput = rightJoystickInput.dx+((keys["ArrowRight"]?1:0)-(keys["ArrowLeft"]?1:0));
                      let desiredRoll = -rollInput*maxTilt;
                      drone.roll = lerp(drone.roll, desiredRoll, 0.1);
                      const forwardDir = new THREE.Vector3(Math.sin(drone.yaw),0,Math.cos(drone.yaw));
                      const rightDir = new THREE.Vector3(Math.cos(drone.yaw),0,-Math.sin(drone.yaw));
                      const horizontalDisplacement = new THREE.Vector3();
                      horizontalDisplacement.add(forwardDir.multiplyScalar(Math.sin(drone.pitch)))
                                             .add(rightDir.multiplyScalar(Math.sin(drone.roll)));
                      horizontalDisplacement.multiplyScalar(translationSpeed*delta);
                      drone.position.add(horizontalDisplacement);
                  } else {
                      drone.yaw = 0; drone.pitch = 0; drone.roll = 0;
                  }
                  if(drone.position.y > 1.0 && takenOff){
                      if(!flyAudioPlaying){
                          flyAudio.currentTime = 0;
                          flyAudio.play().catch(err=>console.log("Error playing flyAudio:", err));
                          flyAudioPlaying = true;
                          flyAudio.volume = 0;
                      }
                      if(flyAudio.volume < 1.0){ flyAudio.volume = Math.min(1.0, flyAudio.volume+delta*0.5); }
                  } else {
                      if(flyAudioPlaying){ flyAudio.pause(); flyAudio.currentTime = 0; flyAudioPlaying = false; }
                  }
              }
          } else {
              if(flyAudioPlaying){ flyAudio.pause(); flyAudio.currentTime = 0; flyAudioPlaying = false; }
          }
          
          if(takenOff && drone.position.y <= 0.46){
              const ddx = drone.position.x - previousPosition.x;
              const ddz = drone.position.z - previousPosition.z;
              const horizDistLanding = Math.sqrt(ddx*ddx+ddz*dz*z);
              if(horizDistLanding < 10){
                  if(homeDistance < 10){
                      flightEnded = true;
                      disableDroneControls = true;
                  } else {
                      takenOff = false;
                  }
                  leftJoystickInput.dx = 0; leftJoystickInput.dy = 0;
                  rightJoystickInput.dx = 0; rightJoystickInput.dy = 0;
                  const leftThumb = document.querySelector("#leftJoystick .joystick-thumb");
                  const rightThumb = document.querySelector("#rightJoystick .joystick-thumb");
                  if(leftThumb) leftThumb.style.transform = "translate(-50%, -50%)";
                  if(rightThumb) rightThumb.style.transform = "translate(-50%, -50%)";
              }
          }
          
          droneGroup.position.copy(drone.position);
          droneGroup.rotation.set(drone.pitch, drone.yaw, -drone.roll);
          
          propellers.forEach(prop=>{
              if(drone.position.y > 0.45){ prop.currentSpinSpeed = prop.spinSpeed; }
              else { prop.currentSpinSpeed = lerp(prop.currentSpinSpeed, 0, 2.0*delta); }
              prop.mesh.rotation.y += prop.currentSpinSpeed*delta;
              const blinkTime = clock.getElapsedTime()*5 + prop.blinkOffset;
              prop.blinkSpot.visible = Math.sin(blinkTime)>0;
          });
          
          hoops.forEach(hoop=>{
              const dToHoop = drone.position.distanceTo(hoop.mesh.position);
              if(!hoop.entered && dToHoop < hoop.mainRadius){ hoop.entered = true; }
              if(hoop.entered && !hoop.passed && dToHoop > hoop.mainRadius*1.1 && takenOff){
                  if(hoop.number === currentExpectedHoop){
                      hoop.passed = true;
                      hoop.mesh.material.color.set(0x00ff00);
                      bonusAudio.pause();
                      bonusAudio.currentTime = 0;
                      setTimeout(()=>{ bonusAudio.play().catch(err=>console.log("Error playing bonusAudio:", err)); },10);
                      currentExpectedHoop++;
                      const cell = document.getElementById("hoopCell-"+hoop.number);
                      if(cell) cell.classList.add("passed");
                      // Update both the main and topview hoop label sprites
                      [hoop.labelSprites.main, hoop.labelSprites.tv].forEach(sprite => {
                          const canvas = sprite.material.map.image;
                          const ctx = canvas.getContext("2d");
                          ctx.clearRect(0,0,canvas.width,canvas.height);
                          ctx.fillStyle = "green";
                          ctx.font = "Bold 80px Arial";
                          ctx.textAlign = "center";
                          ctx.textBaseline = "middle";
                          ctx.fillText(hoop.number.toString(), canvas.width/2, canvas.height/2);
                          sprite.material.map.needsUpdate = true;
                      });
                  }
                  hoop.entered = false;
              }
          });
          
          hoops.forEach(hoop=>{
              if(hoop.type==="square" || hoop.type==="triangle"){
                  hoop.mesh.rotation.z += delta;
              }
          });
          
          if(!allHoopsPassed){
              let count = 0;
              hoops.forEach(hoop=>{ if(hoop.passed) count++; });
              if(count === hoops.length){
                  allHoopsPassed = true;
                  const msgDiv = document.getElementById("message");
                  msgDiv.style.display = "block";
                  msgDiv.innerHTML = translations[currentLanguage].allHoopsPassed;
              }
          }
          
          if(allHoopsPassed && !landedAtHome && homeDistance < 10 && drone.position.y < 1 && takenOff){
              landedAtHome = true;
              flightEnded = true;
              const msgDiv = document.getElementById("message");
              msgDiv.style.display = "block";
              msgDiv.style.backgroundColor = "rgba(0,128,0,0.9)";
              msgDiv.innerHTML = translations[currentLanguage].landingMessage;
              document.getElementById("alertMessage").style.display = "none";
              if(homeMarker && homeMarker.userData && homeMarker.userData.ctx){
                  drawHomeMarker(homeMarker.userData.ctx, "yellow");
                  homeMarker.userData.texture.needsUpdate = true;
              }
              sweetAudio.currentTime = 0;
              sweetAudio.play().catch(err=>console.log("Error playing sweetAudio:", err));
              land1Audio.pause();
              land1Audio.currentTime = 0;
              leftJoystickInput.dx = 0; leftJoystickInput.dy = 0;
              rightJoystickInput.dx = 0; rightJoystickInput.dy = 0;
              document.querySelector("#leftJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
              document.querySelector("#rightJoystick .joystick-thumb").style.transform = "translate(-50%, -50%)";
          }
          
          const cameraOffset = new THREE.Vector3(0,5,-15);
          const quat = new THREE.Quaternion();
          quat.setFromEuler(new THREE.Euler(0,drone.yaw,0));
          const rotatedOffset = cameraOffset.clone().applyQuaternion(quat);
          camera.position.copy(drone.position.clone().add(rotatedOffset));
          camera.lookAt(drone.position);
          const altDisplay = (drone.position.y-0.45).toFixed(1);
          document.getElementById("info").textContent =
              translations[currentLanguage].altitude + ": " + altDisplay + " | " +
              translations[currentLanguage].distance + ": " + homeDistance.toFixed(1);
      
          let leftActiveCommand = "";
          if(keys["KeyW"] || (leftJoystickInput.dy < -0.2 && Math.abs(leftJoystickInput.dy)>= Math.abs(leftJoystickInput.dx))) { leftActiveCommand = "top"; }
          else if(keys["KeyS"] || (leftJoystickInput.dy > 0.2 && Math.abs(leftJoystickInput.dy)>= Math.abs(leftJoystickInput.dx))) { leftActiveCommand = "bottom"; }
          else if(keys["KeyA"] || (leftJoystickInput.dx < -0.2 && Math.abs(leftJoystickInput.dx)>= Math.abs(leftJoystickInput.dy))) { leftActiveCommand = "left"; }
          else if(keys["KeyD"] || (leftJoystickInput.dx > 0.2 && Math.abs(leftJoystickInput.dx)>= Math.abs(leftJoystickInput.dy))) { leftActiveCommand = "right"; }
          document.querySelectorAll("#leftJoystick .joystick-label").forEach(el=>{
              el.style.color = el.classList.contains("label-"+leftActiveCommand) ? "green" : "black";
          });
          
          let rightActiveCommand = "";
          if(keys["ArrowUp"] || (rightJoystickInput.dy < -0.2 && Math.abs(rightJoystickInput.dy)>= Math.abs(rightJoystickInput.dx))) { rightActiveCommand = "top"; }
          else if(keys["ArrowDown"] || (rightJoystickInput.dy > 0.2 && Math.abs(rightJoystickInput.dy)>= Math.abs(rightJoystickInput.dx))) { rightActiveCommand = "bottom"; }
          else if(keys["ArrowLeft"] || (rightJoystickInput.dx < -0.2 && Math.abs(rightJoystickInput.dx)>= Math.abs(rightJoystickInput.dy))) { rightActiveCommand = "left"; }
          else if(keys["ArrowRight"] || (rightJoystickInput.dx > 0.2 && Math.abs(rightJoystickInput.dx)>= Math.abs(rightJoystickInput.dy))) { rightActiveCommand = "right"; }
          document.querySelectorAll("#rightJoystick .joystick-label").forEach(el=>{
              el.style.color = el.classList.contains("label-"+rightActiveCommand) ? "orange" : "black";
          });
          
          if(takenOff){ updateLiveFlightPath(); }
          
          renderer.render(scene, camera);
          topViewRenderer.render(scene, topViewCamera);
      }
      animate();
      
      // ------------------------------------
      // Reset Function
      // ------------------------------------
      function resetDrone(){
          drone.position.set(0,0.45,0);
          drone.yaw = 0; drone.pitch = 0; drone.roll = 0;
          takenOff = false; landedAtHome = false; allHoopsPassed = false; rthActive = false; manualRTH = false;
          currentExpectedHoop = 1;
          recordedFlightPath = []; recordedDistance = 0; recordedTime = 0;
          flightPathPoints = [];
          if(flightPathLine){ scene.remove(flightPathLine); flightPathLine = null; }
          leftJoystickInput.dx = 0; leftJoystickInput.dy = 0;
          const leftThumbReset = document.querySelector("#leftJoystick .joystick-thumb");
          if(leftThumbReset){ leftThumbReset.style.transform = "translate(-50%, -50%)"; }
          rightJoystickInput.dx = 0; rightJoystickInput.dy = 0;
          const rightThumbReset = document.querySelector("#rightJoystick .joystick-thumb");
          if(rightThumbReset){ rightThumbReset.style.transform = "translate(-50%, -50%)"; }
          hoops.forEach(hoop=>{
              hoop.entered = false; hoop.passed = false;
              hoop.mesh.material.color.setHex(hoop.originalColor);
              [hoop.labelSprites.main, hoop.labelSprites.tv].forEach(sprite => {
                  const canvas = sprite.material.map.image;
                  const ctx = canvas.getContext("2d");
                  ctx.clearRect(0,0,canvas.width,canvas.height);
                  ctx.fillStyle = "yellow";
                  ctx.font = "Bold 80px Arial";
                  ctx.textAlign = "center";
                  ctx.textBaseline = "middle";
                  ctx.fillText(hoop.number.toString(), canvas.width/2, canvas.height/2);
                  sprite.material.map.needsUpdate = true;
              });
          });
          if(homeMarker && homeMarker.userData && homeMarker.userData.ctx){
              drawHomeMarker(homeMarker.userData.ctx,"white");
              homeMarker.userData.texture.needsUpdate = true;
          }
          const msgDiv = document.getElementById("message");
          if(msgDiv){ msgDiv.style.display = "none"; msgDiv.innerHTML = ""; }
          const alertElReset = document.getElementById("alertMessage");
          if(alertElReset){ alertElReset.style.display = "none"; alertElReset.classList.remove("blinking"); }
          for(let i=1;i<=hoops.length;i++){
              const cell = document.getElementById("hoopCell-"+i);
              if(cell) cell.classList.remove("passed");
          }
          const rthBtn = document.getElementById("rthBtn");
          if(rthBtn){ rthBtn.style.backgroundColor = "#2196f3"; }
          disableDroneControls = false; flightEnded = false;
          totalDistance = 0; totalFlightTime = 0; previousPosition = null;
          if(flyAudioPlaying){
              flyAudio.pause(); flyAudio.currentTime = 0; flyAudio.volume = 0; flyAudioPlaying = false;
          }
          if(!rth12Audio.paused){ rth12Audio.pause(); rth12Audio.currentTime = 0; }
          if(!land1Audio.paused){ land1Audio.pause(); land1Audio.currentTime = 0; }
          rthActivationTime = null; landingStartTime = null; landingCompleteTime = null;
          updateUIText();
          topViewCamera.zoom = DEFAULT_TOP_VIEW_ZOOM;
          topViewCamera.position.set(0, 1000, 0);
          topViewCamera.updateProjectionMatrix();
          fixedTopViewZoom = topViewCamera.zoom;
          fixedTopViewCenter.copy(topViewCamera.position);
          isLanding = false;
      }
      document.getElementById("btn-reset").addEventListener("click", resetDrone);
      updateUIText();
      
      // ------------------------------------
      // Keyboard - Joystick Sync
      // ------------------------------------
      function syncJoystickWithKeyboard(){
          if(!leftJoystickInput.active){
              let leftKbDx = 0, leftKbDy = 0;
              if(keys["KeyW"]) leftKbDy = -1;
              if(keys["KeyS"]) leftKbDy = 1;
              if(keys["KeyA"]) leftKbDx = -1;
              if(keys["KeyD"]) leftKbDx = 1;
              leftJoystickInput.dx = leftKbDx;
              leftJoystickInput.dy = leftKbDy;
              const leftThumb = document.querySelector("#leftJoystick .joystick-thumb");
              if(leftThumb){
                  leftThumb.style.transform = (leftKbDx!==0 || leftKbDy!==0) ?
                      `translate(${(leftKbDx*40)-40}px, ${(leftKbDy*40)-40}px)` :
                      "translate(-50%, -50%)";
              }
          }
          if(!rightJoystickInput.active){
              let rightKbDx = 0, rightKbDy = 0;
              if(keys["ArrowUp"]) rightKbDy = -1;
              if(keys["ArrowDown"]) rightKbDy = 1;
              if(keys["ArrowLeft"]) rightKbDx = -1;
              if(keys["ArrowRight"]) rightKbDx = 1;
              rightJoystickInput.dx = rightKbDx;
              rightJoystickInput.dy = rightKbDy;
              const rightThumb = document.querySelector("#rightJoystick .joystick-thumb");
              if(rightThumb){
                  rightThumb.style.transform = (rightKbDx!==0 || rightKbDy!==0) ?
                      `translate(${(rightKbDx*40)-40}px, ${(rightKbDy*40)-40}px)` :
                      "translate(-50%, -50%)";
              }
          }
      }
    </script>
  </body>
</html>
