<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Code Simulation</title>
<style>
body {
font-family: Arial, sans-serif;
display: flex;
flex-direction: column;
align-items: center;
padding: 5px;
margin: 3px;
background-color: #f0f0f0;
}
#game-container {
display: flex;
flex-wrap: wrap;
justify-content: left;
gap: 5px;
margin-bottom: 5px;
}
#obstacle-course {
width: 600px;
height: 400px;
border: 2px solid #000;
background-color: #fff;
position: relative;
}
#code-area {
width: 400px;
border: 2px solid #000;
padding: 10px;
background-color: #fff;
}
#command-buttons {
display: flex;
flex-direction: column;
gap: 10px;
margin-bottom: 5px;
}
.button-row {
display: flex;
align-items: center;
gap: 5px;
}
.button-row input, .button-row select {
width: 50px;
padding: 3px;
}
button {
padding: 5px 5px;
cursor: pointer;
font-size: 16px;
color: white;
border: none;
border-radius: 3px;
}
.green-button {
background-color: #4CAF50;
}
.orange-button {
background-color: #FFA500;
}
.blue-button {
background-color: #0000FF;
}
#run-button, #reset-button, #path-preview-button, #centre-button {
margin-top: 10px;
padding: 10px 10px;
font-size: 16px;
}
#run-button {
background-color: #FF0000;
}
#reset-button {
background-color: #FFC0CB;
}
#path-preview-button {
background-color: #0000FF;
color: white;
}
#centre-button {
background-color: #008CBA;
color: white;
}
#code-input {
width: 90%;
height: 150px;
resize: vertical;
}
#message {
margin-top: 5px;
font-weight: bold;
text-align: left;
min-height: 10px;
}
#view-controls {
margin-top: 10px;
display: flex;
gap: 10px;
}
#instructions {
margin-bottom: 20px;
text-align: left;
font-size: 18px;
line-height: 1.5;
}
#view-controls button {
color: #8B4513;
font-size: 16px;
font-weight: bold;
border: 2px solid #8B4513;
background-color: white;
}
@keyframes blink {
0% { opacity: 1; }
50% { opacity: 0; }
100% { opacity: 1; }
}
.blink {
animation: blink 1s infinite;
}
@keyframes colorChange {
0% { color: red; }
33% { color: green; }
66% { color: blue; }
100% { color: red; }
}
.color-change {
animation: colorChange 3s infinite;
}
#language-switch {
position: fixed;
font-size: 18px;
top: 10px;
right: 10px;
padding: 5px 10px;
background-color: #4CAF50;
color: white;
border: none;
border-radius: 3px;
cursor: pointer;
}
#challenge-button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    margin-top: 10px;
    width: 600px; /* Match the width of the obstacle course */
}
</style>
</head>
<body>
<button id="language-switch" onclick="toggleLanguage()">繁體中文</button>
<h2 data-translate="title">Code Performance Simulation</h2>
<p data-translate="instruction">Use the blocks to create a flight path for the drone, then click 'Run Code' to execute the instructions.</p>
<div id="game-container">
    <div style="display: flex; flex-direction: column; align-items: flex-start;">
        <div id="obstacle-course"></div>
        <a href="007_Obstacle.html" style="text-decoration: none;">
            <button id="challenge-button" data-translate="challengeButton">3D Drone Obstacle Course Challenge</button>
        </a>
    </div>

<div id="code-area">

<div id="command-buttons">
    <div class="button-row">
        <button class="green-button" onclick="addCommand('takeOff')" data-translate="takeOff">Take Off</button>
        <button class="green-button" onclick="addCommand('land')" data-translate="land">Land</button>
    </div>
<div class="button-row">
    <button class="green-button" onclick="addCommand('throttleUp')" data-translate="throttleUp">Throttle Up</button>
    <input type="text" id="throttle-distance-up" placeholder="value/var">
    <button class="green-button" onclick="addCommand('throttleDown')" data-translate="throttleDown">Throttle Down</button>
    <input type="text" id="throttle-distance-down" placeholder="value/var">
</div>
<div class="button-row">
    <button class="green-button" onclick="addCommand('yawLeft')" data-translate="yawLeft">Yaw Left</button>
    <input type="text" id="yaw-angle" placeholder="value/var">
    <button class="green-button" onclick="addCommand('yawRight')" data-translate="yawRight">Yaw Right</button>
    <input type="text" id="yaw-angle-right" placeholder="value/var">
</div>
<div class="button-row">
    <button class="orange-button" onclick="addCommand('pitchForward')" data-translate="pitchForward">Pitch Forward</button>
    <input type="text" id="pitch-distance" placeholder="value/var">
    <button class="orange-button" onclick="addCommand('pitchBackward')" data-translate="pitchBackward">Pitch Backward</button>
    <input type="text" id="pitch-distance-back" placeholder="value/var">
</div>
<div class="button-row">
    <button class="orange-button" onclick="addCommand('rollLeft')" data-translate="rollLeft">Roll Left</button>
    <input type="text" id="roll-distance" placeholder="value/var">
    <button class="orange-button" onclick="addCommand('rollRight')" data-translate="rollRight">Roll Right</button>
    <input type="text" id="roll-distance-right" placeholder="value/var">
</div>
    <div class="button-row">
        <button class="blue-button" onclick="addCommand('repeat')" data-translate="repeat">Repeat</button>
        <input type="text" id="repeat-times" placeholder="number or variable">
        <button class="blue-button" onclick="addCommand('setVariable')" data-translate="setVariable">Set</button>
        <input type="text" id="var-name" placeholder="variable name">
        <span>to</span>
        <input type="text" id="var-value" placeholder="value">
    </div>
</div>

<textarea id="code-input"></textarea>
<br>
<div class="button-row">
<button id="run-button" onclick="runCode()" data-translate="runCode">Run Code</button>
<button id="reset-button" onclick="resetSimulation()" data-translate="reset">Reset</button>
<button id="path-preview-button" onclick="previewPath()" data-translate="pathPreview">Path Preview</button>
<button id="centre-button" onclick="centreView()" data-translate="centre">Centre</button>
</div>
</div>
</div>
<div id="message"></div>
<div id="view-controls">
<button onclick="rotateView('left')" data-translate="rotateLeft">Rotate Left</button>
<button onclick="rotateView('right')" data-translate="rotateRight">Rotate Right</button>
<button onclick="moveViewUp()" data-translate="up">Up</button>
<button onclick="moveViewDown()" data-translate="down">Down</button>
<button onclick="zoom('in')" data-translate="zoomIn">Zoom In</button>
<button onclick="zoom('out')" data-translate="zoomOut">Zoom Out</button>
<button onclick="centreView()" data-translate="centre">Centre</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
let isResetPressed = false;
let scene, camera, renderer, drone, obstacles = [], axesHelper, gridHelper;
let goalMarker;
const codeInput = document.getElementById('code-input');
const messageDiv = document.getElementById('message');
const DEFAULT_DRONE_STATE = {
    position: new THREE.Vector3(0, 0, 0),
    rotation: new THREE.Euler(0, 0, 0, 'XYZ'),
    scale: new THREE.Vector3(1, 1, 1)
};


let dronePosition = new THREE.Vector3(0, 0, 0);
let droneRotation = new THREE.Euler(0, 0, 0, 'XYZ');
let goalPosition = new THREE.Vector3(0, 0, 0);

let commandTimeouts = [];
let blinkIntervals = {};

let frontCircles = [];
let rearCircles = [];
let lastBlinkTime = 0;
const blinkDuration = 500;
let blinkState = true;

let commandQueue = [];
let isExecuting = false;

let isThrottling = false;
let isYawing = false;
const yawDuration = 500;

let pathLine = null;
let pathLineBlinkState = true;
let lastPathBlinkToggle = 0;
const pathBlinkInterval = 500;

let controls;

let pathPositions = [];
let isPathPreviewShown = false;

function initGame() {
scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);
renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(600, 400);
const obstacleCourse = document.getElementById('obstacle-course');
obstacleCourse.innerHTML = '';
obstacleCourse.appendChild(renderer.domElement);

camera = new THREE.PerspectiveCamera(75, 600 / 400, 0.1, 1000);
camera.position.set(10, 7, 10);
camera.lookAt(dronePosition);

controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(10, 10, 10);
scene.add(directionalLight);

createDrone();
createCoordinatePlane();
addDirectionIndicators();
addWatermark();
addWatermarkSTEM();
addVerticalLines();

axesHelper = new THREE.AxesHelper(10);
scene.add(axesHelper);

animate();
}

function createDrone() {
const droneGroup = new THREE.Group();

const cubeWidth = 1.5;
const cubeHeight = 0.5;
const cubeDepth = 1.5;
const cubeGeometry = new THREE.BoxGeometry(cubeWidth, cubeHeight, cubeDepth);
const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5 });
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
droneGroup.add(cube);

const circleRadius = 0.225;
const circleHeight = cubeHeight / 2 + 0.01;

const frontCircleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 1 });
const rearCircleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 1 });

const circleGeometry = new THREE.CylinderGeometry(circleRadius, circleRadius, 0.02, 32);

const frontLeft = new THREE.Mesh(circleGeometry, frontCircleMaterial.clone());
frontLeft.position.set(-cubeWidth / 2, circleHeight, cubeDepth / 2);
droneGroup.add(frontLeft);

const frontRight = new THREE.Mesh(circleGeometry, frontCircleMaterial.clone());
frontRight.position.set(cubeWidth / 2, circleHeight, cubeDepth / 2);
droneGroup.add(frontRight);

const rearLeft = new THREE.Mesh(circleGeometry, rearCircleMaterial.clone());
rearLeft.position.set(-cubeWidth / 2, circleHeight, -cubeDepth / 2);
droneGroup.add(rearLeft);

const rearRight = new THREE.Mesh(circleGeometry, rearCircleMaterial.clone());
rearRight.position.set(cubeWidth / 2, circleHeight, -cubeDepth / 2);
droneGroup.add(rearRight);

frontCircles = [frontLeft, frontRight];
rearCircles = [rearLeft, rearRight];

const triangleGeometry = new THREE.ConeGeometry(1, 2, 3);
const triangleMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });
const triangle = new THREE.Mesh(triangleGeometry, triangleMaterial);
triangle.rotation.x = -Math.PI / 2;
triangle.position.set(0, circleHeight + 0, -cubeDepth / 2 - 0);
droneGroup.add(triangle);

    droneGroup.position.copy(DEFAULT_DRONE_STATE.position);
    droneGroup.rotation.copy(DEFAULT_DRONE_STATE.rotation);
    droneGroup.scale.copy(DEFAULT_DRONE_STATE.scale);
scene.add(droneGroup);
drone = droneGroup;
return droneGroup;
}

function createCoordinatePlane() {
const size = 20;
const divisions = 20;
gridHelper = new THREE.GridHelper(size, divisions, 0xcccccc, 0xcccccc);
scene.add(gridHelper);

const fontLoader = new THREE.FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
const textMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

for (let i = -10; i <= 10; i += 2) {
if (i !== 0) {
createText(font, textMaterial, i.toString(), i, 0, -10);
createText(font, textMaterial, i.toString(), -10, 0, i);
}
}

createText(font, textMaterial, 'X', 11, 0, 0);
createText(font, textMaterial, 'Z', 0, 0, 11);
createText(font, textMaterial, 'Y', 0, 11, 0);
});
}

function createText(font, material, text, x, y, z) {
const textGeometry = new THREE.TextGeometry(text, {
font: font,
size: 0.5,
height: 0.1,
});
const textMesh = new THREE.Mesh(textGeometry, material);
textMesh.position.set(x, y, z);
scene.add(textMesh);
}

function addDirectionIndicators() {
addDirectionIndicator(new THREE.Vector3(12, 0, 0), 'Right', 0xff0000);
addDirectionIndicator(new THREE.Vector3(-12, 0, 0), 'Left', 0xff0000);
addDirectionIndicator(new THREE.Vector3(0, 12, 0), 'Up', 0x00ff00);
addDirectionIndicator(new THREE.Vector3(0, -12, 0), 'Down', 0x00ff00);
addDirectionIndicator(new THREE.Vector3(0, 0, 12), 'Rear', 0x0000ff);
addDirectionIndicator(new THREE.Vector3(0, 0, -12), 'Front', 0x0000ff);
}

function addDirectionIndicator(position, text, color) {
const canvas = document.createElement('canvas');
const context = canvas.getContext('2d');
canvas.width = 256;
canvas.height = 256;
context.fillStyle = `rgb(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255})`;
context.font = 'Bold 40px Arial';
context.textAlign = 'center';
context.textBaseline = 'middle';
context.fillText(text, 128, 128);

const texture = new THREE.CanvasTexture(canvas);
const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
const sprite = new THREE.Sprite(spriteMaterial);
sprite.position.copy(position);
sprite.scale.set(2, 2, 2);
scene.add(sprite);
}

function addWatermark() {
const fontLoader = new THREE.FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
const textMaterial = new THREE.MeshBasicMaterial({ color: 0xd3d3d3 });
const watermarkGeometry = new THREE.TextGeometry('EdUHK', {
font: font,
size: 1,
height: 0.05,
});
const watermarkMesh = new THREE.Mesh(watermarkGeometry, textMaterial);
watermarkMesh.rotation.x = -Math.PI / 2;
watermarkMesh.position.set(5, 0.1, 0);
scene.add(watermarkMesh);
});
}

function addWatermarkSTEM() {
const fontLoader = new THREE.FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
const textMaterial = new THREE.MeshBasicMaterial({ color: 0xd3d3d3 });
const stemTextGeometry = new THREE.TextGeometry('STEM Education', {
font: font,
size: 0.7,
height: 0.05,
});
const stemWatermarkMesh = new THREE.Mesh(stemTextGeometry, textMaterial);
stemWatermarkMesh.rotation.y = Math.PI / 2;
stemWatermarkMesh.position.set(0, 0.1, 10);
scene.add(stemWatermarkMesh);
});
}

function addVerticalLines() {
const material = new THREE.LineBasicMaterial({ color: 0xcccccc });
for (let y = 2; y <= 10; y += 2) {
const points = [];
points.push(new THREE.Vector3(-10, y, -10));
points.push(new THREE.Vector3(10, y, -10));
points.push(new THREE.Vector3(10, y, 10));
points.push(new THREE.Vector3(-10, y, 10));
points.push(new THREE.Vector3(-10, y, -10));

const geometry = new THREE.BufferGeometry().setFromPoints(points);
const line = new THREE.Line(geometry, material);
scene.add(line);
}
}

function animate() {
requestAnimationFrame(animate);

const now = Date.now();
if (now - lastBlinkTime > blinkDuration) {
blinkState = !blinkState;
lastBlinkTime = now;

frontCircles.forEach(circle => {
circle.material.opacity = blinkState ? 1 : 0;
});

rearCircles.forEach(circle => {
circle.material.opacity = blinkState ? 1 : 0;
});
}

if (pathLine) {
if (now - lastPathBlinkToggle > pathBlinkInterval) {
pathLine.visible = pathLineBlinkState;
pathLineBlinkState = !pathLineBlinkState;
lastPathBlinkToggle = now;
}
}

controls.update();
renderer.render(scene, camera);
}

function addCommand(commandType) {
    let command = commandType;
    let parameter = '';

    const getParameterValue = (elementId) => {
        const value = document.getElementById(elementId).value.trim();
        if (!value) return null;
        // Allow both numeric values and variable names
        return value;
    };

    switch (commandType) {
        case 'takeOff':
            command = 'takeOff';
            break;
        case 'land':
            command = 'land';
            break;
        case 'throttleUp':
            parameter = getParameterValue('throttle-distance-up');
            if (!parameter) {
                alert('Please enter a value or variable for Throttle Up.');
                return;
            }
            command = `throttleUp ${parameter}`;
            break;
        case 'throttleDown':
            parameter = getParameterValue('throttle-distance-down');
            if (!parameter) {
                alert('Please enter a value or variable for Throttle Down.');
                return;
            }
            command = `throttleDown ${parameter}`;
            break;
        case 'yawLeft':
            parameter = getParameterValue('yaw-angle');
            if (!parameter) {
                alert('Please enter a value or variable for Yaw Left.');
                return;
            }
            command = `yawLeft ${parameter}`;
            break;
        case 'yawRight':
            parameter = getParameterValue('yaw-angle-right');
            if (!parameter) {
                alert('Please enter a value or variable for Yaw Right.');
                return;
            }
            command = `yawRight ${parameter}`;
            break;
        case 'pitchForward':
            parameter = getParameterValue('pitch-distance');
            if (!parameter) {
                alert('Please enter a value or variable for Pitch Forward.');
                return;
            }
            command = `pitchForward ${parameter}`;
            break;
        case 'pitchBackward':
            parameter = getParameterValue('pitch-distance-back');
            if (!parameter) {
                alert('Please enter a value or variable for Pitch Backward.');
                return;
            }
            command = `pitchBackward ${parameter}`;
            break;
        case 'rollLeft':
            parameter = getParameterValue('roll-distance');
            if (!parameter) {
                alert('Please enter a value or variable for Roll Left.');
                return;
            }
            command = `rollLeft ${parameter}`;
            break;
        case 'rollRight':
            parameter = getParameterValue('roll-distance-right');
            if (!parameter) {
                alert('Please enter a value or variable for Roll Right.');
                return;
            }
            command = `rollRight ${parameter}`;
            break;
case 'repeat':
    parameter = getParameterValue('repeat-times');
    if (!parameter) {
        alert('Please enter the number of times or a variable name to repeat.');
        return;
    }
    command = `repeat ${parameter} times\n{\n\n}`;
    break;
case 'setVariable':
    const varName = getParameterValue('var-name');
    const varValue = getParameterValue('var-value');
    if (!varName || !varValue) {
        alert('Please enter both variable name and value.');
        return;
    }
    command = `set ${varName} to ${varValue}`;
    break;

        default:
            console.warn(`Unknown command type: ${commandType}`);
            return;
    }

    addCommandAtCursor(command);
}

function addCommandAtCursor(command) {
const start = codeInput.selectionStart;
const end = codeInput.selectionEnd;
const before = codeInput.value.substring(0, start);
const after = codeInput.value.substring(end, codeInput.value.length);
codeInput.value = before + command + '\n' + after;
const newCursorPosition = start + command.length + 1;
codeInput.selectionStart = codeInput.selectionEnd = newCursorPosition;
codeInput.focus();
}


function parseCode(code) {
    const lines = code.split('\n');
    const commands = [];
    let repeatStack = [];
    let variables = {};

    function processLine(line) {
        if (line.startsWith('set ')) {
            const match = line.match(/set (\w+)\s*(?:=|to)\s*(.+)/);
            if (match) {
                return { type: 'set', varName: match[1], expression: match[2] };
            } else {
                console.warn(`Invalid set command: ${line}`);
                return null;
            }
        } else if (line.startsWith('repeat')) {
            const match = line.match(/repeat (.+) times/);
            if (match) {
                return {
                    type: 'repeat',
                    countExpression: match[1],
                    commands: []
                };
            }
        } else if (line === '}') {
            return { type: 'end-repeat' };
        } else {
            return { type: 'command', value: line };
        }
    }

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line === '') continue;

        const processed = processLine(line);

        if (processed === null) {
            continue;
        } else if (processed.type === 'repeat') {
            repeatStack.push(processed);
        } else if (processed.type === 'end-repeat') {
            if (repeatStack.length > 0) {
                const currentRepeat = repeatStack.pop();
                if (repeatStack.length > 0) {
                    repeatStack[repeatStack.length - 1].commands.push(currentRepeat);
                } else {
                    commands.push(currentRepeat);
                }
            } else {
                console.warn(`Unexpected '}' at line ${i+1}`);
            }
        } else if (repeatStack.length > 0) {
            repeatStack[repeatStack.length - 1].commands.push(processed);
        } else {
            commands.push(processed);
        }
    }

    return commands;
}

function evaluateExpression(expr, variables) {
    const safeEval = (expression) => {
        return Function(...Object.keys(variables), `return ${expression}`)(...Object.values(variables));
    };
    
    try {
        return safeEval(expr);
    } catch (e) {
        console.error(`Error evaluating expression: "${expr}"`, e);
        return 0;
    }
}

function executeCommands(commands) {
    const variables = {};
    const finalCommands = [];

    function executeCommand(cmd) {
        if (cmd.type === 'set') {
            variables[cmd.varName] = evaluateExpression(cmd.expression, variables);
        } else if (cmd.type === 'repeat') {
            const count = Math.round(evaluateExpression(cmd.countExpression, variables));
            for (let i = 0; i < count; i++) {
                cmd.commands.forEach(subCmd => executeCommand(subCmd));
            }
        } else if (cmd.type === 'command') {
            const parts = cmd.value.split(' ');
            const evaluatedParts = parts.map((part, index) => {
                return index === 0 ? part : evaluateExpression(part, variables);
            });
            finalCommands.push(evaluatedParts.join(' '));
        }
    }

    commands.forEach(executeCommand);
    return finalCommands;
}

async function runCode() {
    if (isResetPressed) {
        isResetPressed = false;
        return;
    }

    if (isExecuting) return;

    const parsedCommands = parseCode(codeInput.value);
    const commands = executeCommands(parsedCommands);

    // Check if the code starts with "takeOff" and ends with "land"
    if (commands.length < 2 || commands[0].trim().toLowerCase() !== 'takeoff' || commands[commands.length - 1].trim().toLowerCase() !== 'land') {
        alert(translations[currentLanguage].invalidCodeStructure);
        return;
    }

    isExecuting = true;
    document.getElementById('run-button').disabled = true;

    commandTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
    commandTimeouts = [];

    console.log(`Executing ${commands.length} commands.`);

    for (const command of commands) {
        if (isResetPressed) {
            isResetPressed = false;
            break;
        }
        await executeSingleCommand(command);
    }

    isExecuting = false;
    document.getElementById('run-button').disabled = false;
}


async function executeSingleCommand(command) {
    return new Promise((resolve) => {
        if (isResetPressed) {
            resolve();
            return;
        }

const parts = command.split(' ');
const baseCommand = parts[0];
const param = parts[1] ? parseFloat(parts[1]) : null;

switch (baseCommand.toLowerCase()) {
case 'takeoff':
throttleDrone('up', 2).then(() => {
console.log('Taking off');
resolve();
});
break;
case 'land':
throttleDrone('down', dronePosition.y).then(() => {
console.log('Landing');
resolve();
});
break;
case 'pitchforward':
case 'pitchbackward':
case 'rollleft':
case 'rollright':
case 'throttleup':
case 'throttledown':
case 'yawleft':
case 'yawright':
if (param !== null) {
const commandMatch = baseCommand.toLowerCase().match(/(pitch|roll|throttle|yaw)(left|right|forward|backward|up|down)?/);
if (commandMatch) {
const action = commandMatch[1];
const direction = commandMatch[2];
switch (action) {
case 'pitch':
pitchDrone(direction, param).then(resolve);
break;
case 'roll':
rollDrone(direction, param).then(resolve);
break;
case 'throttle':
throttleDrone(direction, param).then(resolve);
break;
case 'yaw':
yawDrone(direction, param).then(resolve);
break;
default:
console.warn(`Unhandled action: ${action}`);
resolve();
break;
}
} else {
console.warn(`Unknown command format: ${command}`);
resolve();
}
} else {
console.warn(`Missing parameter for command: ${command}`);
resolve();
}
break;
case 'add':
case 'subtract':
case 'multiply':
case 'divide':
console.log(`Arithmetic operation: ${command}`);
resolve();
break;
default:
console.warn(`Unknown command: ${command}`);
resolve();
}
});
}

function pitchDrone(direction, distance) {
return new Promise((resolve) => {
const steps = 20;
const stepDuration = 50;
let currentStep = 0;
const deltaZ = (distance / steps) * (direction === 'forward' ? -1 : 1);

const pitchInterval = setInterval(() => {
if (currentStep < steps) {
moveDrone(0, 0, deltaZ, () => {});
currentStep++;
} else {
clearInterval(pitchInterval);
resolve();
}
}, stepDuration);
});
}

function rollDrone(direction, distance) {
return new Promise((resolve) => {
const steps = 20;
const stepDuration = 50;
let currentStep = 0;
const deltaX = (distance / steps) * (direction === 'left' ? -1 : 1);

const rollInterval = setInterval(() => {
if (currentStep < steps) {
moveDrone(deltaX, 0, 0, () => {});
currentStep++;
} else {
clearInterval(rollInterval);
resolve();
}
}, stepDuration);
});
}

function throttleDrone(direction, distance) {
return new Promise((resolve) => {
if (isThrottling) {
resolve();
return;
}
isThrottling = true;
const duration = 1000;
const steps = 20;
const stepDuration = duration / steps;
let currentStep = 0;
const deltaY = direction === 'up' ? (distance / steps) : (-distance / steps);

const throttleInterval = setInterval(() => {
if (currentStep < steps) {
moveDrone(0, deltaY, 0, () => {});
currentStep++;
} else {
clearInterval(throttleInterval);
isThrottling = false;
resolve();
}
}, stepDuration);
});
}

function yawDrone(direction, angle) {
return new Promise((resolve) => {
if (isYawing) {
resolve();
return;
}
isYawing = true;
const steps = 30;
const stepDuration = yawDuration / steps;
let currentStep = 0;
const deltaAngle = direction === 'left' ? (angle * Math.PI / 180) / steps : -(angle * Math.PI / 180) / steps;

const yawInterval = setInterval(() => {
if (currentStep < steps) {
drone.rotation.y += deltaAngle;
currentStep++;
} else {
clearInterval(yawInterval);
isYawing = false;
resolve();
}
}, stepDuration);
});
}

function moveDrone(x, y, z, callback) {
const movement = new THREE.Vector3(x, y, z);
movement.applyEuler(drone.rotation);
dronePosition.add(movement);
drone.position.copy(dronePosition);
if (callback) callback();
}

function resetSimulation() {
    isResetPressed = true;
    
    // Immediately stop code execution
    if (isExecuting) {
        commandTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
        commandTimeouts = [];
        isExecuting = false;
        document.getElementById('run-button').disabled = false;
    }

    // Clear all intervals
    Object.values(blinkIntervals).forEach(intervalId => clearInterval(intervalId));
    blinkIntervals = {};

    // Reset drone to initial position immediately
    dronePosition = new THREE.Vector3(0, 0, 0);
    drone.position.copy(dronePosition);
    drone.rotation.set(0, 0, 0, 'XYZ');
    drone.updateMatrix();

    // Reset camera and controls immediately
    camera.position.set(10, 7, 10);
    camera.lookAt(dronePosition);
    controls.target.copy(dronePosition);
    controls.update();

    // Clear message
    messageDiv.textContent = '';
    messageDiv.classList.remove('blink', 'color-change');

    // Remove path preview if it exists
    if (pathLine) {
        scene.remove(pathLine);
        pathLine = null;
        isPathPreviewShown = false;
    }

    // Reset Grid
    if (gridHelper) {
        scene.remove(gridHelper);
    }
    gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xcccccc);
    scene.add(gridHelper);

    // Reset all variables and states
    commandQueue = [];
    isThrottling = false;
    isYawing = false;
    pathPositions = [];

    // Force an immediate re-render of the scene
    renderer.render(scene, camera);

    console.log("Simulation reset. Drone restored to default position and orientation.");
}	

function homePosition() {
commandTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
commandTimeouts = [];

Object.values(blinkIntervals).forEach(intervalId => clearInterval(intervalId));
blinkIntervals = {};

if (pathLine) {
scene.remove(pathLine);
pathLine = null;
isPathPreviewShown = false;
}

commandQueue = [];
isExecuting = false;

document.getElementById('run-button').disabled = false;

dronePosition.set(0, 0, 0);
drone.rotation.set(0, 0, 0, 'XYZ');
drone.position.copy(dronePosition);
drone.quaternion.setFromEuler(drone.rotation);
camera.position.set(10, 7, 10);
camera.lookAt(drone.position);
controls.target.copy(dronePosition);
controls.update();
messageDiv.textContent = '';
messageDiv.classList.remove('blink', 'color-change');

// Reset Grid
if (gridHelper) {
scene.remove(gridHelper);
}
gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xcccccc);
scene.add(gridHelper);
}

function rotateView(direction) {
const rotationAngle = direction === 'left' ? Math.PI / 18 : -Math.PI / 18;
const currentPosition = camera.position.clone().sub(dronePosition);
currentPosition.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationAngle);
camera.position.copy(dronePosition).add(currentPosition);
camera.lookAt(dronePosition);
}

function moveViewUp() {
camera.position.y += 1;
camera.lookAt(dronePosition);
}

function moveViewDown() {
if (camera.position.y > 1) {
camera.position.y -= 1;
camera.lookAt(dronePosition);
}
}

function zoom(direction) {
const zoomFactor = direction === 'in' ? 0.9 : 1.1;
const currentPosition = camera.position.clone().sub(dronePosition);
currentPosition.multiplyScalar(zoomFactor);
camera.position.copy(dronePosition).add(currentPosition);
camera.lookAt(dronePosition);
}

function centreView() {
camera.position.set(10, 7, 10);
camera.lookAt(dronePosition);
controls.target.copy(dronePosition);
controls.update();
}

function previewPath() {
    if (isPathPreviewShown) {
        if (pathLine) {
            scene.remove(pathLine);
            pathLine = null;
        }
        isPathPreviewShown = false;
        return;
    }

    const parsedCommands = parseCode(codeInput.value);
    const commands = executeCommands(parsedCommands);

    let simulatedPosition = new THREE.Vector3(0, 2, 0); // Start at 2 units high
    let simulatedRotation = new THREE.Euler(0, 0, 0, 'YXZ'); // Use YXZ order for proper yaw rotation
    const positions = [new THREE.Vector3(0, 0, 0), simulatedPosition.clone()]; // Start from ground

    let minX = 0, maxX = 0, minY = 0, maxY = 2, minZ = 0, maxZ = 0;

    commands.forEach(command => {
        const parts = command.split(' ');
        const baseCommand = parts[0].toLowerCase();
        const param = parts[1] ? parseFloat(parts[1]) : null;

        switch (baseCommand) {
            case 'throttleup':
                if (param !== null) {
                    simulatedPosition.y += param;
                }
                break;
            case 'throttledown':
                if (param !== null) {
                    simulatedPosition.y = Math.max(0, simulatedPosition.y - param);
                }
                break;
            case 'yawleft':
            case 'yawright':
                if (param !== null) {
                    const yawAngle = baseCommand === 'yawleft' ? param : -param;
                    simulatedRotation.y += THREE.MathUtils.degToRad(yawAngle);
                }
                break;
            case 'pitchforward':
            case 'pitchbackward':
                if (param !== null) {
                    const pitchDistance = baseCommand === 'pitchforward' ? param : -param;
                    const forward = new THREE.Vector3(0, 0, -pitchDistance);
                    forward.applyEuler(simulatedRotation);
                    simulatedPosition.add(forward);
                }
                break;
            case 'rollleft':
            case 'rollright':
                if (param !== null) {
                    const rollDistance = baseCommand === 'rollleft' ? -param : param;
                    const side = new THREE.Vector3(rollDistance, 0, 0);
                    side.applyEuler(simulatedRotation);
                    simulatedPosition.add(side);
                }
                break;
        }

        // Update min and max values
        minX = Math.min(minX, simulatedPosition.x);
        maxX = Math.max(maxX, simulatedPosition.x);
        minY = Math.min(minY, simulatedPosition.y);
        maxY = Math.max(maxY, simulatedPosition.y);
        minZ = Math.min(minZ, simulatedPosition.z);
        maxZ = Math.max(maxZ, simulatedPosition.z);

        if (baseCommand !== 'takeoff' && baseCommand !== 'land') {
            positions.push(simulatedPosition.clone());
        }
    });

    // Add final landing position
    positions.push(new THREE.Vector3(simulatedPosition.x, 0, simulatedPosition.z));

    if (positions.length < 2) {
        alert(translations[currentLanguage].noValidCommands);
        return;
    }

    const geometry = new THREE.BufferGeometry().setFromPoints(positions);
    const material = new THREE.LineBasicMaterial({
        color: 0x0000ff,
        linewidth: 2,
    });

    const line = new THREE.Line(geometry, material);
    scene.add(line);
    pathLine = line;
    isPathPreviewShown = true;

    // Calculate bounding box with padding
    const padding = 5;
    const sizeX = maxX - minX;
    const sizeZ = maxZ - minZ;
    const maxSize = Math.max(sizeX, sizeZ, 10); // Ensure minimum size
    const gridSize = Math.ceil((maxSize + padding) * 1.2); // 20% larger than the path with padding

    // Remove existing grid
    if (gridHelper) {
        scene.remove(gridHelper);
    }

    // Add new grid
    gridHelper = new THREE.GridHelper(gridSize, gridSize, 0xcccccc, 0xcccccc);
    scene.add(gridHelper);

    // Recalculate center
    const centerX = (minX + maxX) / 2;
    const centerZ = (minZ + maxZ) / 2;

    // Position the camera to encompass the entire grid
    camera.position.set(centerX + gridSize / 2, gridSize / 2, centerZ + gridSize / 2);
    camera.lookAt(new THREE.Vector3(centerX, 0, centerZ));

    // Update controls target
    controls.target.set(centerX, 0, centerZ);
    controls.update();

    // Render the scene
    renderer.render(scene, camera);
}

const translations = {
en: {
title: "Code Performance Simulation",
instruction: "Use the blocks to create a flight path for the drone, then click 'Run Code' to execute the instructions.",
takeOff: "Take Off",
land: "Land",
throttleUp: "Throttle Up",
throttleDown: "Throttle Down",
yawLeft: "Yaw Left",
yawRight: "Yaw Right",
pitchForward: "Pitch Forward",
pitchBackward: "Pitch Backward",
rollLeft: "Roll Left",
rollRight: "Roll Right",
repeat: "Repeat",
setVariable: "Set",
runCode: "Run Code",
reset: "Reset",
pathPreview: "Path Preview",
centre: "Centre",
challengeButton: "3D Drone Obstacle Course Challenge",
rotateLeft: "Rotate Left",
rotateRight: "Rotate Right",
up: "Up",
down: "Down",
zoomIn: "Zoom In",
zoomOut: "Zoom Out",
noValidCommands: "No valid commands to preview the path.",
invalidCodeStructure: "The code must start with 'Take Off' and end with 'Land'."
},
zh: {
title: "編程表現模擬",
instruction: "使用方塊創建無人機的飛行路徑，然後點擊「執行編程」以執行指令。",
takeOff: "起飛",
land: "著陸",
throttleUp: "上升",
throttleDown: "下降",
yawLeft: "左偏航",
yawRight: "右偏航",
pitchForward: "前俯仰",
pitchBackward: "後俯仰",
rollLeft: "左滾轉",
rollRight: "右滾轉",
repeat: "重複",
setVariable: "設置",
runCode: "執行編程",
reset: "重置",
pathPreview: "路徑預覽",
centre: "居中",
challengeButton: "3D 無人機障礙挑戰",
rotateLeft: "向左旋轉",
rotateRight: "向右旋轉",
up: "向上",
down: "向下",
zoomIn: "放大",
zoomOut: "縮小",
noValidCommands: "沒有有效的指令來預覽路徑。",
invalidCodeStructure: "代碼必須以「起飛」開始，以「著陸」結束。"
}
};

let currentLanguage = 'en';

function toggleLanguage() {
currentLanguage = currentLanguage === 'en' ? 'zh' : 'en';
updateLanguage();
}

function updateLanguage() {
const elements = document.querySelectorAll('[data-translate]');
elements.forEach(element => {
const key = element.getAttribute('data-translate');
if (translations[currentLanguage][key]) {
element.textContent = translations[currentLanguage][key];
}
});

const languageSwitch = document.getElementById('language-switch');
languageSwitch.textContent = currentLanguage === 'en' ? '繁體中文' : 'English';
}

initGame();
updateLanguage();
</script>
</body>
</html>