<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>3D Drone Obstacle Course Challenge</title>
<style>
body {
font-family: Arial, sans-serif;
display: flex;
flex-direction: column;
align-items: center;
padding: 5px;
margin: 3px;
background-color: #f0f0f0;
}
#game-container {
display: flex;
flex-wrap: wrap;
justify-content: left;
gap: 5px;
margin-bottom: 5px;
}
#obstacle-course {
width: 600px;
height: 400px;
border: 2px solid #000;
background-color: #fff;
position: relative;
}
#code-area {
width: 400px;
border: 2px solid #000;
padding: 10px;
background-color: #fff;
}
#command-buttons {
display: flex;
flex-direction: column;
gap: 10px;
margin-bottom: 5px;
}
.button-row {
display: flex;
align-items: center;
gap: 5px;
}
.button-row input {
width: 50px;
padding: 3px;
}
button {
padding: 5px 5px;
cursor: pointer;
font-size: 16px;
color: white;
border: none;
border-radius: 3px;
}
.green-button {
background-color: #4CAF50;
}
.orange-button {
background-color: #FFA500;
}
#run-button, #home-button, #path-preview-button, #centre-button, #level-select {
margin-top: 10px;
padding: 10px 10px;
font-size: 16px;
}
#run-button {
background-color: #FF0000;
}
#home-button {
background-color: #FFC0CB;
}
#path-preview-button {
background-color: #0000FF;
color: white;
}
#centre-button {
background-color: #008CBA;
color: white;
}
#level-select {
background-color: #0000FF;
color: white;
border: none;
border-radius: 3px;
cursor: pointer;
}
#code-input {
width: 90%;
height: 150px;
resize: vertical;
}
#message {
margin-top: 5px;
font-weight: bold;
text-align: left;
min-height: 10px;
}
#view-controls {
margin-top: 10px;
display: flex;
gap: 10px;
}
#instructions {
margin-bottom: 20px;
text-align: left;
font-size: 18px;
line-height: 1.5;
}
#view-controls button {
color: #8B4513;
font-size: 16px;
font-weight: bold;
border: 2px solid #8B4513;
background-color: white;
}
@keyframes blink {
0% { opacity: 1; }
50% { opacity: 0; }
100% { opacity: 1; }
}
.blink {
animation: blink 1s infinite;
}
@keyframes colorChange {
0% { color: red; }
33% { color: green; }
66% { color: blue; }
100% { color: red; }
}
.color-change {
animation: colorChange 3s infinite;
}
/* Additional styles for Level Select */
#level-container {
display: flex;
flex-direction: column;
align-items: center;
gap: 10px;
margin-top: 10px;
}
#counters {
margin-top: 10px;
display: flex;
gap: 20px;
}
#counters span {
font-weight: bold;
}
/* Style for the language switch button */
#language-switch {
position: fixed;
font-size: 18px;
top: 10px;
right: 10px;
padding: 5px 10px;
background-color: #4CAF50;
color: white;
border: none;
border-radius: 3px;
cursor: pointer;
}
#simulation-button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    margin-top: 10px;
    width: 600px; /* Match the width of the obstacle course */
}
</style>
</head>
<body>
<button id="language-switch" onclick="toggleLanguage()">ÁπÅÈ´î‰∏≠Êñá</button>
<h2 data-translate="title">3D Drone Obstacle Course Challenge (upgraded ver.)</h2>
<p data-translate="instruction">Use the command buttons to add movement instructions with parameters, then click 'Run Code' to navigate the drone through the obstacle course.</p>
<div id="game-container">
    <div style="display: flex; flex-direction: column; align-items: flex-start;">
        <div id="obstacle-course"></div>
        <a href="007a_Code_simulation.html" style="text-decoration: none;">
            <button id="simulation-button" data-translate="simulationButton">Code Performance Simulation</button>
        </a>
    </div>
<div id="code-area">
<div id="command-buttons">
<div class="button-row">
<button class="green-button" onclick="addCommand('throttleUp')" data-translate="throttleUp">Throttle Up</button>
<input type="number" id="throttle-distance-up" placeholder="units" min="0">
<button class="green-button" onclick="addCommand('throttleDown')" data-translate="throttleDown">Throttle Down</button>
<input type="number" id="throttle-distance-down" placeholder="units" min="0">
</div>
<div class="button-row">
<button class="green-button" onclick="addCommand('yawLeft')" data-translate="yawLeft">Yaw Left</button>
<input type="number" id="yaw-angle" placeholder="¬∞" min="0" max="360">
<button class="green-button" onclick="addCommand('yawRight')" data-translate="yawRight">Yaw Right</button>
<input type="number" id="yaw-angle-right" placeholder="¬∞" min="0" max="360">
</div>
<div class="button-row">
<button class="orange-button" onclick="addCommand('pitchForward')" data-translate="pitchForward">Pitch Forward</button>
<input type="number" id="pitch-distance" placeholder="units" min="0">
<button class="orange-button" onclick="addCommand('pitchBackward')" data-translate="pitchBackward">Pitch Backward</button>
<input type="number" id="pitch-distance-back" placeholder="units" min="0">
</div>
<div class="button-row">
<button class="orange-button" onclick="addCommand('rollLeft')" data-translate="rollLeft">Roll Left</button>
<input type="number" id="roll-distance" placeholder="units" min="0">
<button class="orange-button" onclick="addCommand('rollRight')" data-translate="rollRight">Roll Right</button>
<input type="number" id="roll-distance-right" placeholder="units" min="0">
</div>
</div>
<textarea id="code-input"></textarea>
<br>
<div class="button-row">
<button id="run-button" onclick="runCode()" data-translate="runCode">Run Code</button>
<button id="home-button" onclick="homePosition()" data-translate="home">Home</button>
<button id="path-preview-button" onclick="previewPath()" data-translate="pathPreview">Path Preview</button>
<button id="centre-button" onclick="centreView()" data-translate="centre">Centre</button>
<select id="level-select" onchange="changeLevel()">
<option value="1" selected data-translate="level1">Level 1</option>
<option value="2" data-translate="level2">Level 2</option>
<option value="3" data-translate="level3">Level 3</option>
</select>
</div>
<div id="counters">
<span data-translate="attemptsLabel">No. of Attempts:</span> <span id="attempts-count">0</span>
<span data-translate="stepsLabel">No. of Steps:</span> <span id="steps-count">0</span>
</div>
</div>
</div>
<div id="message"></div>
<div id="view-controls">
<button onclick="rotateView('right')" data-translate="rotateLeft">Rotate Left</button>
<button onclick="rotateView('left')" data-translate="rotateRight">Rotate Right</button>
<button onclick="moveViewUp()" data-translate="up">Up</button>
<button onclick="moveViewDown()" data-translate="down">Down</button>
<button onclick="zoom('in')" data-translate="zoomIn">Zoom In</button>
<button onclick="zoom('out')" data-translate="zoomOut">Zoom Out</button>
<button onclick="centreView()" data-translate="centre">Centre</button>
</div>

<!-- Audio Elements -->
<script>
// Preload audio files with explicit preload attribute
const hoopSound = document.createElement('audio');
hoopSound.src = 'bonus.mp3';
hoopSound.preload = 'auto';
hoopSound.volume = 0.5;

const goalSound = document.createElement('audio');
goalSound.src = 'sweet.mp3';
goalSound.preload = 'auto';
goalSound.volume = 0.5;

const warn1Sound = document.createElement('audio');
warn1Sound.src = 'warn1.mp3';
warn1Sound.preload = 'auto';
warn1Sound.volume = 0.5;

const warn2Sound = document.createElement('audio');
warn2Sound.src = 'warn2.mp3';
warn2Sound.preload = 'auto';
warn2Sound.volume = 0.5;

const startSound = document.createElement('audio');
startSound.src = 'start.mp3';
startSound.preload = 'auto';
startSound.volume = 0.5;

// Add event listeners to log loading status
[hoopSound, goalSound, warn1Sound, warn2Sound, startSound].forEach((audio, index) => {
audio.addEventListener('canplaythrough', () => {
console.log(`${audio.src} loaded successfully.`);
}, { once: true });

audio.addEventListener('error', (e) => {
console.error(`Error loading ${audio.src}:`, e);
}, { once: true });
});

// Unlock audio on first user interaction to ensure sounds play on iPad
function unlockAudio() {
// Play each audio silently to unlock their ability to play
[hoopSound, goalSound, warn1Sound, warn2Sound, startSound].forEach(audio => {
audio.muted = true;
const playPromise = audio.play();
if (playPromise !== undefined) {
playPromise.then(() => {
audio.pause();
audio.currentTime = 0;
audio.muted = false;
}).catch((error) => {
console.warn(`Audio unlock failed for ${audio.src}:`, error);
});
}
});

// Remove the event listeners after unlocking
document.body.removeEventListener('click', unlockAudio);
document.body.removeEventListener('touchstart', unlockAudio);
}

// Add event listeners to unlock audio on user interaction
document.body.addEventListener('click', unlockAudio, { once: true });
document.body.addEventListener('touchstart', unlockAudio, { once: true });

// Array to track cloned sounds
const clonedSounds = [];

// Helper function to play sounds with cloning
function playSound(audio, track=true) {
const clone = audio.cloneNode();
clone.play().catch((error) => {
console.warn(`Playback failed for ${audio.src}:`, error);
});
if (track) {
clonedSounds.push(clone);
clone.addEventListener('ended', () => {
const index = clonedSounds.indexOf(clone);
if (index > -1) {
clonedSounds.splice(index, 1);
}
});
}
}
</script>

<!-- Three.js Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- OrbitControls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
// Initialize variables
let scene, camera, renderer, drone, obstacles = [], axesHelper;
let goalMarker;
const codeInput = document.getElementById('code-input');
const messageDiv = document.getElementById('message');

let dronePosition = new THREE.Vector3(0, 0, 0);
let droneRotation = new THREE.Euler(0, 0, 0, 'XYZ'); // Upright
let goalPosition = new THREE.Vector3(0, 0, 0); // Will be set in generateGoalPosition()
let currentHoop = 1;

// Global variables to manage timeouts and intervals
let commandTimeouts = [];
let blinkIntervals = {};

// Counters for Attempts and Steps
let attemptsCount = 0;
let stepsCount = 0;
let attemptsDisplay;
let stepsDisplay;

// Current Level
let currentLevel = 1;

// Alert flag to ensure alert message is shown only once per out-of-order pass
let alertShown = false;

// Level configurations
const levelConfigs = {
1: { vertical: 1, horizontal: 0 }, // Level 1: one vertical hoop
2: { vertical: 1, horizontal: 1 }, // Level 2: one vertical and one horizontal hoop
3: { vertical: 2, horizontal: 1 } // Level 3: two vertical and one horizontal hoop
// Levels 4 and 5 are deleted
};

// Constants for minimum distances
const MIN_DISTANCE_FROM_HOOPS = 4; // Minimum distance between hoops
const MIN_DISTANCE_FROM_START = 5; // Minimum distance from start
const MIN_DISTANCE_TO_GOAL_FOR_HOOP = 5; // Minimum distance from any hoop when placing goal

// Blinking variables
let frontCircles = [];
let rearCircles = [];
let lastBlinkTime = 0;
const blinkDuration = 500; // milliseconds
let blinkState = true;

// Command Queue
let commandQueue = [];
let isExecuting = false;

// Throttle Animation Variables
let isThrottling = false;

// Yaw Animation Variables
let isYawing = false;
const yawDuration = 500; // milliseconds per 90 degrees

// Path Preview Variables
let pathLine = null;
let pathLineBlinkState = true;
let lastPathBlinkToggle = 0;
const pathBlinkInterval = 500; // milliseconds

// OrbitControls
let controls;

// Array of stored positions for Path Preview
let pathPositions = [];
let isPathPreviewShown = false; // Flag to track Path Preview visibility

function initGame() {
scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);
renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(600, 400);
const obstacleCourse = document.getElementById('obstacle-course');
obstacleCourse.innerHTML = '';
obstacleCourse.appendChild(renderer.domElement);

// Set default camera position
camera = new THREE.PerspectiveCamera(75, 600 / 400, 0.1, 1000);
camera.position.set(10, 7, 10); // Adjusted for closer view
camera.lookAt(dronePosition);

// Initialize OrbitControls
controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; // for smoother experience
controls.dampingFactor = 0.05;

const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(10, 10, 10);
scene.add(directionalLight);

createDrone();
createHulaHoops(currentLevel);
createCoordinatePlane();
addDirectionIndicators();
addWatermark();
addWatermarkSTEM();
addVerticalLines();

axesHelper = new THREE.AxesHelper(10);
scene.add(axesHelper);

// Assign the counter display elements
attemptsDisplay = document.getElementById('attempts-count');
stepsDisplay = document.getElementById('steps-count');

// Initialize display counts
attemptsDisplay.textContent = attemptsCount;
stepsDisplay.textContent = stepsCount;

// Start blinking the first hoop
if (obstacles.length > 0) {
blinkHoop(obstacles[0]);
}

animate();

// Play startSound when the game initializes
playSound(startSound, false); // Do not track startSound clones

// Add event listener to update steps when code changes
codeInput.addEventListener('input', updateStepsCount);
}

function createDrone() {
const droneGroup = new THREE.Group();

// 1. Create a blue, semi-transparent cube with adjusted dimensions
const cubeWidth = 1.5; // Increased to 1.5 from 1
const cubeHeight = 0.5; // Assuming y-axis is height and remains the same
const cubeDepth = 1.5; // Reduced to half from 3
const cubeGeometry = new THREE.BoxGeometry(cubeWidth, cubeHeight, cubeDepth);
const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5 });
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
droneGroup.add(cube);

// 2. Create four circles with swapped colors
const circleRadius = 0.225; // Enlarged by 1.5x from 0.15
const circleHeight = cubeHeight / 2 + 0.01; // slightly above the cube

const frontCircleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 1 }); // Swapped to green
const rearCircleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 1 }); // Swapped to red

const circleGeometry = new THREE.CylinderGeometry(circleRadius, circleRadius, 0.02, 32);

// Front Left Circle
const frontLeft = new THREE.Mesh(circleGeometry, frontCircleMaterial.clone());
frontLeft.position.set(-cubeWidth / 2, circleHeight, cubeDepth / 2);
droneGroup.add(frontLeft);

// Front Right Circle
const frontRight = new THREE.Mesh(circleGeometry, frontCircleMaterial.clone());
frontRight.position.set(cubeWidth / 2, circleHeight, cubeDepth / 2);
droneGroup.add(frontRight);

// Rear Left Circle
const rearLeft = new THREE.Mesh(circleGeometry, rearCircleMaterial.clone());
rearLeft.position.set(-cubeWidth / 2, circleHeight, -cubeDepth / 2);
droneGroup.add(rearLeft);

// Rear Right Circle
const rearRight = new THREE.Mesh(circleGeometry, rearCircleMaterial.clone());
rearRight.position.set(cubeWidth / 2, circleHeight, -cubeDepth / 2);
droneGroup.add(rearRight);

// Store references for blinking
frontCircles = [frontLeft, frontRight];
rearCircles = [rearLeft, rearRight];

// 3. Add a triangle pointing to the rear
const triangleGeometry = new THREE.ConeGeometry(1, 2, 3);
const triangleMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });
const triangle = new THREE.Mesh(triangleGeometry, triangleMaterial);
triangle.rotation.x = -Math.PI / 2; // Pointing backward
triangle.position.set(0, circleHeight + 0, -cubeDepth / 2 - 0); // Positioned at the rear
droneGroup.add(triangle);

// 4. Integrate the Start Marker (Green Spot with 'S' Label) into the Drone
const startGeometry = new THREE.SphereGeometry(0.5, 32, 32);
const startMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
const startMarker = new THREE.Mesh(startGeometry, startMaterial);
startMarker.position.set(0, circleHeight + 0.25, 0); // Positioned at the top center of the drone
droneGroup.add(startMarker);

addLabel(startMarker, 'S', 0, 0.8, 0, 'green'); // Bold "S" inside the start marker
addShadow(startMarker);

droneGroup.rotation.x = 0; // Ensure upright position

scene.add(droneGroup);
drone = droneGroup;
}

function createHulaHoops(level) {
obstacles = []; // Clear existing obstacles

for (let i = 1; i <= levelConfigs[level].vertical; i++) {
const position = generateNonOverlappingPosition();
const radius = getRandomRadius(2, 3);
createHulaHoop(position.x, position.y, position.z, radius, i, 'vertical');
}
for (let i = 1; i <= levelConfigs[level].horizontal; i++) {
const position = generateNonOverlappingPosition();
const radius = getRandomRadius(1.5, 2.5);
createHulaHoop(position.x, position.y, position.z, radius, levelConfigs[level].vertical + i, 'horizontal');
}
createGoalMarker(); // Generate goal after hoops are placed
}

function createHulaHoop(x, y, z, radius, number, orientation) {
const hoopGroup = new THREE.Group();
const hoopGeometry = new THREE.TorusGeometry(radius, 0.1, 16, 100);
const hoopMaterial = new THREE.MeshPhongMaterial({ color: 0xff8c00, transparent: true, opacity: 0.7 });
const hoop = new THREE.Mesh(hoopGeometry, hoopMaterial);

// Set orientation based on level
if (orientation === 'vertical') {
hoop.rotation.x = Math.PI / 2;
} else if (orientation === 'horizontal') {
hoop.rotation.x = 0;
}

hoopGroup.add(hoop);
hoopGroup.position.set(x, y, z);
scene.add(hoopGroup);
obstacles.push(hoopGroup);

const canvas = document.createElement('canvas');
const context = canvas.getContext('2d');
canvas.width = 128;
canvas.height = 128;
context.fillStyle = 'white';
context.fillRect(0, 0, 128, 128);
context.fillStyle = 'black';
context.font = 'Bold 64px Arial';
context.textAlign = 'center';
context.textBaseline = 'middle';
context.fillText(number.toString(), 64, 64);

const numberTexture = new THREE.CanvasTexture(canvas);
const numberMaterial = new THREE.SpriteMaterial({ map: numberTexture });
const numberSprite = new THREE.Sprite(numberMaterial);
numberSprite.scale.set(1, 1, 1);
numberSprite.position.set(0, radius + 0.5, 0);
hoopGroup.add(numberSprite);
}

function generateNonOverlappingPosition() {
const maxAttempts = 100;
let attempt = 0;
let position;

while (attempt < maxAttempts) {
const x = THREE.MathUtils.randFloatSpread(14); // Increased spread to -7 to 7 for better spacing
const y = THREE.MathUtils.randFloat(2, 5); // 2 to 5 to avoid ground level
const z = THREE.MathUtils.randFloatSpread(14); // -7 to 7

position = new THREE.Vector3(x, y, z);

// Ensure the hoop is within boundaries (-10 to 10 on X and Z)
if (Math.abs(x) > 10 || Math.abs(z) > 10) continue;

// Check for overlap with existing hoops
let overlapping = false;
for (let hoop of obstacles) {
if (position.distanceTo(hoop.position) < MIN_DISTANCE_FROM_HOOPS) {
overlapping = true;
break;
}
}

// Check for minimum distance from start
if (position.distanceTo(new THREE.Vector3(0, 0, 0)) < MIN_DISTANCE_FROM_START) {
overlapping = true;
}

// Check for minimum distance from goal (if goal is already placed)
if (goalMarker && position.distanceTo(goalMarker.position) < MIN_DISTANCE_TO_GOAL_FOR_HOOP) {
overlapping = true;
}

if (!overlapping) {
return position;
}

attempt++;
}

// Fallback position if no non-overlapping position is found
return new THREE.Vector3(0, 2, 0);
}

function getRandomRadius(min, max) {
return THREE.MathUtils.randFloat(min, max);
}

function createCoordinatePlane() {
const size = 20;
const divisions = 20;
const gridHelper = new THREE.GridHelper(size, divisions, 0xcccccc, 0xcccccc);
scene.add(gridHelper);

const fontLoader = new THREE.FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
const textMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

for (let i = -10; i <= 10; i += 2) {
if (i !== 0) {
createText(font, textMaterial, i.toString(), i, 0, -10);
createText(font, textMaterial, i.toString(), -10, 0, i);
}
}

createText(font, textMaterial, 'X', 11, 0, 0);
createText(font, textMaterial, 'Z', 0, 0, 11);
createText(font, textMaterial, 'Y', 0, 11, 0);
});
}

function createText(font, material, text, x, y, z) {
const textGeometry = new THREE.TextGeometry(text, {
font: font,
size: 0.5,
height: 0.1,
});
const textMesh = new THREE.Mesh(textGeometry, material);
textMesh.position.set(x, y, z);
scene.add(textMesh);
}

function addDirectionIndicators() {
addDirectionIndicator(new THREE.Vector3(12, 0, 0), 'Right', 0xff0000);
addDirectionIndicator(new THREE.Vector3(-12, 0, 0), 'Left', 0xff0000);
addDirectionIndicator(new THREE.Vector3(0, 12, 0), 'Up', 0x00ff00);
addDirectionIndicator(new THREE.Vector3(0, -12, 0), 'Down', 0x00ff00);
addDirectionIndicator(new THREE.Vector3(0, 0, 12), 'Rear', 0x0000ff);
addDirectionIndicator(new THREE.Vector3(0, 0, -12), 'Front', 0x0000ff);
}

function addDirectionIndicator(position, text, color) {
const canvas = document.createElement('canvas');
const context = canvas.getContext('2d');
canvas.width = 256;
canvas.height = 256;
context.fillStyle = `rgb(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255})`;
context.font = 'Bold 40px Arial';
context.textAlign = 'center';
context.textBaseline = 'middle';
context.fillText(text, 128, 128);

const texture = new THREE.CanvasTexture(canvas);
const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
const sprite = new THREE.Sprite(spriteMaterial);
sprite.position.copy(position);
sprite.scale.set(2, 2, 2);
scene.add(sprite);
}

function createStartAndGoalMarkers() {
// Goal Marker
createGoalMarker();
}

function createGoalMarker() {
// Remove existing goalMarker if it exists
if (goalMarker) {
scene.remove(goalMarker);
goalMarker = null;
}

// Generate a non-overlapping position for the goal based on the current level
let position = generateGoalPosition(currentLevel);
goalPosition.copy(position); // Update the goalPosition vector

const goalGeometry = new THREE.SphereGeometry(0.5, 32, 32);
const goalMaterial = new THREE.MeshPhongMaterial({ color: 0xff8c00, transparent: true, opacity: 0.5 });
goalMarker = new THREE.Mesh(goalGeometry, goalMaterial);
goalMarker.position.copy(position);
scene.add(goalMarker);

// Place the "G" label inside the goal marker
addLabel(goalMarker, 'G', 0, 0.8, 0.5, 'orange'); // Bold "G" inside the goal marker

addShadow(goalMarker);
}

function addShadow(object) {
const shadowGeometry = new THREE.CircleGeometry(0.5, 32);
const shadowMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
const shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
shadow.rotation.x = -Math.PI / 2;
shadow.position.y = 0.01;
object.add(shadow);
}

function addLabel(object, text, x, y, z, color) {
const canvas = document.createElement('canvas');
const context = canvas.getContext('2d');
canvas.width = 256;
canvas.height = 256;
context.fillStyle = 'transparent';
context.clearRect(0, 0, canvas.width, canvas.height);
context.fillStyle = color;
context.font = `Bold 200px Arial`;
context.textAlign = 'center';
context.textBaseline = 'middle';
context.fillText(text, 128, 128);

const texture = new THREE.CanvasTexture(canvas);
const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
const sprite = new THREE.Sprite(spriteMaterial);
sprite.position.set(x, y, z);
sprite.scale.set(1, 1, 1);
object.add(sprite);
}

function addWatermark() {
const fontLoader = new THREE.FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
const textMaterial = new THREE.MeshBasicMaterial({ color: 0xd3d3d3 }); // Light grey color
const watermarkGeometry = new THREE.TextGeometry('EdUHK', {
font: font,
size: 1,
height: 0.05,
});
const watermarkMesh = new THREE.Mesh(watermarkGeometry, textMaterial);
watermarkMesh.rotation.x = -Math.PI / 2;
watermarkMesh.position.set(5, 0.1, 0); // Position along positive X-axis at ground level
scene.add(watermarkMesh);
});
}

// Added function to include "STEM Education" watermark
function addWatermarkSTEM() {
const fontLoader = new THREE.FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
const textMaterial = new THREE.MeshBasicMaterial({ color: 0xd3d3d3 }); // Light grey color
const stemTextGeometry = new THREE.TextGeometry('STEM Education', {
font: font,
size: 0.7,
height: 0.05,
});
const stemWatermarkMesh = new THREE.Mesh(stemTextGeometry, textMaterial);
stemWatermarkMesh.rotation.y = Math.PI / 2;
stemWatermarkMesh.position.set(0, 0.1, 10); // Position along positive Z-axis at ground level
scene.add(stemWatermarkMesh);
});
}

function addVerticalLines() {
const material = new THREE.LineBasicMaterial({ color: 0xcccccc });
for (let y = 2; y <= 10; y += 2) { // Start from y=2 to match hoop elevation
const points = [];
points.push(new THREE.Vector3(-10, y, -10));
points.push(new THREE.Vector3(10, y, -10));
points.push(new THREE.Vector3(10, y, 10));
points.push(new THREE.Vector3(-10, y, 10));
points.push(new THREE.Vector3(-10, y, -10));

const geometry = new THREE.BufferGeometry().setFromPoints(points);
const line = new THREE.Line(geometry, material);
scene.add(line);
}
}

function animate() {
requestAnimationFrame(animate);

// Blinking logic
const now = Date.now();
if (now - lastBlinkTime > blinkDuration) {
blinkState = !blinkState;
lastBlinkTime = now;

frontCircles.forEach(circle => {
circle.material.opacity = blinkState ? 1 : 0;
});

rearCircles.forEach(circle => {
circle.material.opacity = blinkState ? 1 : 0;
});
}

// Path Preview Blinking
if (pathLine) {
if (now - lastPathBlinkToggle > pathBlinkInterval) {
pathLine.visible = pathLineBlinkState;
pathLineBlinkState = !pathLineBlinkState;
lastPathBlinkToggle = now;
}
}

controls.update(); // Update OrbitControls
renderer.render(scene, camera);
}

// Modify addCommand to insert at cursor position with parameters
function addCommand(commandType) {
let command = commandType;
let parameter = '';

switch (commandType) {
case 'yawLeft':
parameter = document.getElementById('yaw-angle').value;
if (!parameter) {
alert('Please enter an angle for Yaw Left.');
return;
}
command = `yawLeft ${parameter}`;
break;
case 'yawRight':
parameter = document.getElementById('yaw-angle-right').value;
if (!parameter) {
alert('Please enter an angle for Yaw Right.');
return;
}
command = `yawRight ${parameter}`;
break;
case 'pitchForward':
parameter = document.getElementById('pitch-distance').value;
if (!parameter) {
alert('Please enter a distance for Pitch Forward.');
return;
}
command = `pitchForward ${parameter}`;
break;
case 'pitchBackward':
parameter = document.getElementById('pitch-distance-back').value;
if (!parameter) {
alert('Please enter a distance for Pitch Backward.');
return;
}
command = `pitchBackward ${parameter}`;
break;
case 'rollLeft':
parameter = document.getElementById('roll-distance').value;
if (!parameter) {
alert('Please enter a distance for Roll Left.');
return;
}
command = `rollLeft ${parameter}`;
break;
case 'rollRight':
parameter = document.getElementById('roll-distance-right').value;
if (!parameter) {
alert('Please enter a distance for Roll Right.');
return;
}
command = `rollRight ${parameter}`;
break;
case 'throttleUp':
parameter = document.getElementById('throttle-distance-up').value;
if (!parameter) {
alert('Please enter a distance for Throttle Up.');
return;
}
command = `throttleUp ${parameter}`;
break;
case 'throttleDown':
parameter = document.getElementById('throttle-distance-down').value;
if (!parameter) {
alert('Please enter a distance for Throttle Down.');
return;
}
command = `throttleDown ${parameter}`;
break;
default:
console.warn(`Unknown command type: ${commandType}`);
return;
}

addCommandAtCursor(command);
}

// Insert the command at the cursor position in the textarea
function addCommandAtCursor(command) {
const start = codeInput.selectionStart;
const end = codeInput.selectionEnd;
const before = codeInput.value.substring(0, start);
const after = codeInput.value.substring(end, codeInput.value.length);
codeInput.value = before + command + '\n' + after;
// Move the cursor to after the inserted command
const newCursorPosition = start + command.length + 1; // +1 for the newline
codeInput.selectionStart = codeInput.selectionEnd = newCursorPosition;
codeInput.focus();
updateStepsCount();
}

async function runCode() {
if (isExecuting) return; // Prevent multiple executions at the same time
isExecuting = true;

// **Increment the Attempts Counter Here**
attemptsCount++;
attemptsDisplay.textContent = attemptsCount;
console.log(`Run Code pressed. Attempt #${attemptsCount}`);

// **Disable the "Run Code" button after it's pressed**
document.getElementById('run-button').disabled = true;

// Clear previous timeouts
commandTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
commandTimeouts = [];

// Parse commands
const commands = codeInput.value.trim().split('\n').filter(cmd => cmd.trim() !== '');
console.log(`Executing ${commands.length} commands.`);

// Execute commands sequentially
for (const command of commands) {
await executeSingleCommand(command.trim());
}

checkGoal();
isExecuting = false;

// **Re-enable the "Run Code" button after execution**
document.getElementById('run-button').disabled = false;
}

async function executeSingleCommand(command) {
return new Promise((resolve) => {
const parts = command.split(' ');
const baseCommand = parts[0];
const param = parts[1] ? parseFloat(parts[1]) : null;

switch (baseCommand) {
case 'pitchForward':
if (param !== null) {
pitchDrone('forward', param).then(() => {
resolve();
});
} else {
console.warn(`Missing parameter for command: ${command}`);
resolve();
}
break;
case 'pitchBackward':
if (param !== null) {
pitchDrone('backward', param).then(() => {
resolve();
});
} else {
console.warn(`Missing parameter for command: ${command}`);
resolve();
}
break;
case 'rollLeft':
if (param !== null) {
rollDrone('left', param).then(() => {
resolve();
});
} else {
console.warn(`Missing parameter for command: ${command}`);
resolve();
}
break;
case 'rollRight':
if (param !== null) {
rollDrone('right', param).then(() => {
resolve();
});
} else {
console.warn(`Missing parameter for command: ${command}`);
resolve();
}
break;
case 'throttleUp':
if (param !== null) {
throttleDrone('up', param).then(() => {
resolve();
});
} else {
console.warn(`Missing parameter for command: ${command}`);
resolve();
}
break;
case 'throttleDown':
if (param !== null) {
throttleDrone('down', param).then(() => {
resolve();
});
} else {
console.warn(`Missing parameter for command: ${command}`);
resolve();
}
break;
case 'yawLeft':
if (param !== null) {
yawDrone('left', param).then(() => {
resolve();
});
} else {
console.warn(`Missing parameter for command: ${command}`);
resolve();
}
break;
case 'yawRight':
if (param !== null) {
yawDrone('right', param).then(() => {
resolve();
});
} else {
console.warn(`Missing parameter for command: ${command}`);
resolve();
}
break;
default:
console.warn(`Unknown command: ${command}`);
resolve();
}
});
}

// Function to handle pitching the drone
function pitchDrone(direction, distance) {
return new Promise((resolve) => {
const steps = 20;
const stepDuration = 50; // Total duration: 20 * 50ms = 1000ms
let currentStep = 0;
const deltaZ = (distance / steps) * (direction === 'forward' ? -1 : 1);

const pitchInterval = setInterval(() => {
if (currentStep < steps) {
moveDrone(0, 0, deltaZ, () => {});
currentStep++;
} else {
clearInterval(pitchInterval);
resolve();
}
}, stepDuration);
});
}

// Function to handle rolling the drone
function rollDrone(direction, distance) {
return new Promise((resolve) => {
const steps = 20;
const stepDuration = 50; // Total duration: 20 * 50ms = 1000ms
let currentStep = 0;
const deltaX = (distance / steps) * (direction === 'left' ? -1 : 1);

const rollInterval = setInterval(() => {
if (currentStep < steps) {
moveDrone(deltaX, 0, 0, () => {});
currentStep++;
} else {
clearInterval(rollInterval);
resolve();
}
}, stepDuration);
});
}

function throttleDrone(direction, distance) {
return new Promise((resolve) => {
if (isThrottling) {
// If already throttling, ignore new throttle commands
resolve();
return;
}
isThrottling = true;
const duration = 1000; // Total time for the movement in ms (slower)
const steps = 20;
const stepDuration = duration / steps;
let currentStep = 0;
const deltaY = direction === 'up' ? (distance / steps) : (-distance / steps);

const throttleInterval = setInterval(() => {
if (currentStep < steps) {
moveDrone(0, deltaY, 0, () => {});
currentStep++;
} else {
clearInterval(throttleInterval);
isThrottling = false;
resolve();
}
}, stepDuration);
});
}

function yawDrone(direction, angle) {
return new Promise((resolve) => {
if (isYawing) {
// If already yawing, ignore new yaw commands
resolve();
return;
}
isYawing = true;
const steps = 30; // More steps for smoother rotation
const stepDuration = yawDuration / steps;
let currentStep = 0;
const deltaAngle = direction === 'left' ? (angle * Math.PI / 180) / steps : -(angle * Math.PI / 180) / steps;

const yawInterval = setInterval(() => {
if (currentStep < steps) {
drone.rotation.y += deltaAngle;
currentStep++;
// Update dronePosition based on new rotation if necessary
// moveDrone can be added here if yaw affects position
} else {
clearInterval(yawInterval);
isYawing = false;
resolve();
}
}, stepDuration);
});
}

function moveDrone(x, y, z, callback) {
const movement = new THREE.Vector3(x, y, z);
movement.applyEuler(drone.rotation);
dronePosition.add(movement);
drone.position.copy(dronePosition);
checkHulaHoops();
if (callback) callback();
}

function checkHulaHoops() {
obstacles.forEach((hoop, index) => {
const distance = dronePosition.distanceTo(hoop.position);
const requiredDistance = (hoop.children[0].geometry.parameters.radius + 0.5); // Extra buffer

if (distance < requiredDistance) {
if (index + 1 === currentHoop) {
hoop.children[0].material.color.setHex(0x00ff00); // Change color to green
hoop.children[0].material.opacity = 0.7; // Ensure no blinking

// Stop blinking
if (blinkIntervals[index]) {
clearInterval(blinkIntervals[index]);
delete blinkIntervals[index];
}

messageDiv.textContent = translations[currentLanguage].congratsHoop + currentHoop;
messageDiv.classList.add('blink');
playSound(hoopSound);
setTimeout(() => {
messageDiv.classList.remove('blink');
}, 3000);
currentHoop++;
alertShown = false; // Reset alert flag for next hoop
if (currentHoop <= obstacles.length) {
obstacles[currentHoop - 1].children[0].material.transparent = true;
obstacles[currentHoop - 1].children[0].material.opacity = 0.7;
blinkHoop(obstacles[currentHoop -1]);
}
} else {
// Ensure alert is shown only when n > currentHoop
const hoopNumber = index + 1;
if (hoopNumber > currentHoop && !alertShown) {
alert(translations[currentLanguage].warnWrongHoop + currentHoop + translations[currentLanguage].warnWrongHoopFirst);
playSound(warn1Sound);
alertShown = true;
}
// If not the correct hoop, do not turn it green and allow the user to continue
}
}
});
}

function blinkHoop(hoop) {
const hoopId = obstacles.indexOf(hoop);
if (blinkIntervals[hoopId]) return; // Prevent multiple intervals on the same hoop
blinkIntervals[hoopId] = setInterval(() => {
if (hoop.children[0].material.opacity === 0.7) {
hoop.children[0].material.opacity = 0.3;
} else {
hoop.children[0].material.opacity = 0.7;
}
}, 500);
}

function checkGoal() {
if (dronePosition.distanceTo(goalPosition) < 1.5) { // Adjusted distance threshold
if (currentHoop <= obstacles.length) {
alert(translations[currentLanguage].warnGoalWithoutHoops);
playSound(warn2Sound);
} else {
messageDiv.textContent = translations[currentLanguage].congratsFinal;
messageDiv.classList.add('blink', 'color-change');
goalMarker.material.color.setHex(0x00ff00);
playSound(goalSound);
blinkGoal();
setTimeout(() => {
messageDiv.classList.remove('blink', 'color-change');
}, 5000);
}
} else {
messageDiv.textContent = translations[currentLanguage].aimForGoal;
}
}

function blinkGoal() {
let blinkCount = 0;
const maxBlinks = 10;
const originalColor = goalMarker.material.color.getHex();

const blinkInterval = setInterval(() => {
goalMarker.material.color.setHex(goalMarker.material.color.getHex() === 0x00ff00 ? 0xff0000 : 0x00ff00);
blinkCount++;
if (blinkCount >= maxBlinks) {
clearInterval(blinkInterval);
goalMarker.material.color.setHex(originalColor);
}
}, 300);
}

function homePosition() {
// Stop all scheduled commands
commandTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
commandTimeouts = [];

// Stop all blinking intervals
Object.values(blinkIntervals).forEach(intervalId => clearInterval(intervalId));
blinkIntervals = {};

// Remove Path Preview line if exists
if (pathLine) {
scene.remove(pathLine);
pathLine = null;
isPathPreviewShown = false; // Reset Path Preview flag
}

// Reset command queue and execution flag
commandQueue = [];
isExecuting = false;

// **Re-enable the "Run Code" button when "Home" is pressed**
document.getElementById('run-button').disabled = false;

// Reset drone position and rotation
dronePosition.set(0, 0, 0);
drone.rotation.set(0, 0, 0, 'XYZ');
drone.position.copy(dronePosition);
drone.quaternion.setFromEuler(drone.rotation);
camera.position.set(10, 7, 10); // Reset to the default zoomed-in position
camera.lookAt(drone.position);
messageDiv.textContent = '';
messageDiv.classList.remove('blink', 'color-change');

// Restore hula hoop colors and opacities
obstacles.forEach(hoop => {
hoop.children[0].material.color.setHex(0xff8c00);
hoop.children[0].material.opacity = 0.7;
});
currentHoop = 1;
alertShown = false; // Reset alert flag

// Reset goal color
if (goalMarker) {
goalMarker.material.color.setHex(0xff8c00);
}

// **Do NOT reset Attempts and Steps here unless intended**
// If you want to reset attempts and steps on returning home, uncomment the following lines:
// attemptsCount = 0;
// attemptsDisplay.textContent = attemptsCount;
// stepsCount = 0;
// stepsDisplay.textContent = stepsCount;

// **Reset Steps count is handled via code area input listener**
// **Reset audio clones**
clonedSounds.forEach(clone => {
clone.pause();
});
clonedSounds.length = 0;

// Start blinking the first hoop again
if (obstacles.length > 0) {
blinkHoop(obstacles[0]);
}
}

function rotateView(direction) {
const rotationAngle = direction === 'left' ? Math.PI / 18 : -Math.PI / 18;
const currentPosition = camera.position.clone().sub(dronePosition);
currentPosition.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationAngle);
camera.position.copy(dronePosition).add(currentPosition);
camera.lookAt(dronePosition);
}

function moveViewUp() {
camera.position.y += 1;
camera.lookAt(dronePosition);
}

function moveViewDown() {
if (camera.position.y > 1) { // Prevent camera from going below ground
camera.position.y -= 1;
camera.lookAt(dronePosition);
}
}

function zoom(direction) {
const zoomFactor = direction === 'in' ? 0.9 : 1.1;
const currentPosition = camera.position.clone().sub(dronePosition);
currentPosition.multiplyScalar(zoomFactor);
camera.position.copy(dronePosition).add(currentPosition);
camera.lookAt(dronePosition);
}

// Centre Button Functionality
function centreView() {
// Reset camera to default position
camera.position.set(10, 7, 10);
camera.lookAt(dronePosition);
controls.target.copy(dronePosition);
controls.update();
}

function changeLevel() {
const levelSelect = document.getElementById('level-select');
const selectedLevel = parseInt(levelSelect.value);
if (selectedLevel !== currentLevel) {
currentLevel = selectedLevel;
// **Clear the code input when selecting a new level**
codeInput.value = '';
updateStepsCount(); // Update steps count accordingly
// Reset the game for the new level
resetGameForNewLevel();
// **Unlock the "Run Code" button when a new level is selected**
document.getElementById('run-button').disabled = false;
// **Play startSound when a new level is entered**
playSound(startSound, false); // Do not track startSound clones
}
}

function resetGameForNewLevel() {
// Stop all scheduled commands
commandTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
commandTimeouts = [];

// Stop all blinking intervals
Object.values(blinkIntervals).forEach(intervalId => clearInterval(intervalId));
blinkIntervals = {};

// Remove existing hoops from the scene
obstacles.forEach(hoop => scene.remove(hoop));
obstacles = [];
// Remove goalMarker if exists
if (goalMarker) {
scene.remove(goalMarker);
goalMarker = null;
}

// Remove Path Preview line if exists
if (pathLine) {
scene.remove(pathLine);
pathLine = null;
isPathPreviewShown = false; // Reset Path Preview flag
}

// Create new hoops based on the selected level
createHulaHoops(currentLevel);

// Generate a new goal position
createGoalMarker();

// Reset drone position and rotation
dronePosition.set(0, 0, 0);
drone.rotation.set(0, 0, 0, 'XYZ');
drone.position.copy(dronePosition);
drone.quaternion.setFromEuler(drone.rotation);
camera.position.set(10, 7, 10); // Reset to the default zoomed-in position
camera.lookAt(drone.position);
messageDiv.textContent = '';
messageDiv.classList.remove('blink', 'color-change');

// Restore hula hoop colors and opacities
obstacles.forEach(hoop => {
hoop.children[0].material.color.setHex(0xff8c00);
hoop.children[0].material.opacity = 0.7;
});
currentHoop = 1;
alertShown = false; // Reset alert flag

// Reset goal color
if (goalMarker) {
goalMarker.material.color.setHex(0xff8c00);
}

// **Reset counters when changing levels**
attemptsCount = 0;
attemptsDisplay.textContent = attemptsCount;

stepsCount = 0;
stepsDisplay.textContent = stepsCount;

// Start blinking the first hoop again
if (obstacles.length > 0) {
blinkHoop(obstacles[0]);
}
}

function generateGoalPosition(level) {
// Define goal positions based on level for consistency
const predefinedGoals = {
1: new THREE.Vector3(7, 3, 7),
2: new THREE.Vector3(-7, 3, 7),
3: new THREE.Vector3(7, 3, -7)
// Levels 4 and 5 are deleted
};

// If predefined position exists for the level, use it
if (predefinedGoals[level]) {
// Ensure it's within boundaries and not overlapping with hoops
const position = predefinedGoals[level].clone();
let tooClose = false;
const minDistanceToHoop = MIN_DISTANCE_TO_GOAL_FOR_HOOP; // Minimum distance from any hoop
obstacles.forEach(hoop => {
if (position.distanceTo(hoop.position) < minDistanceToHoop) {
tooClose = true;
}
});
if (!tooClose) {
return position;
}
}

// Fallback: Random position if predefined is too close
const maxAttempts = 100;
let attempt = 0;
let position;
const minDistanceToHoop = MIN_DISTANCE_TO_GOAL_FOR_HOOP; // Minimum distance from any hoop

while (attempt < maxAttempts) {
const x = THREE.MathUtils.randFloatSpread(14); // -7 to 7
const y = THREE.MathUtils.randFloat(2, 5); // 2 to 5 to avoid ground level
const z = THREE.MathUtils.randFloatSpread(14); // -7 to 7

position = new THREE.Vector3(x, y, z);

// Ensure the goal is not too close to any hoops or the start
let tooClose = false;
for (let hoop of obstacles) {
if (position.distanceTo(hoop.position) < minDistanceToHoop) {
tooClose = true;
break;
}
}

if (position.distanceTo(new THREE.Vector3(0, 0, 0)) < MIN_DISTANCE_FROM_START) {
tooClose = true;
}

if (!tooClose) {
return position;
}

attempt++;
}

// Fallback position if no suitable position is found
return new THREE.Vector3(0, 3, 9);
}

initGame();

// Function to update "No. of Steps" based on the current code in the textarea
function updateStepsCount() {
const commands = codeInput.value.trim().split('\n').filter(cmd => cmd.trim() !== '');
stepsCount = commands.length;
stepsDisplay.textContent = stepsCount;
console.log(`Steps updated. Total steps: ${stepsCount}`);
}

// **Ensure steps count updates when code is changed manually**
codeInput.addEventListener('input', updateStepsCount);

// **New Functionality: Path Preview**
function previewPath() {
if (isPathPreviewShown) {
// Hide the path
if (pathLine) {
scene.remove(pathLine);
pathLine = null;
}
isPathPreviewShown = false;
} else {
// Show the path
// Remove existing path line if present
if (pathLine) {
scene.remove(pathLine);
pathLine = null;
}

// Parse commands and simulate the path
const commands = codeInput.value.trim().split('\n').filter(cmd => cmd.trim() !== '');
let simulatedPosition = new THREE.Vector3(0, 0, 0);
let simulatedRotation = new THREE.Euler(0, 0, 0, 'XYZ');
const positions = [simulatedPosition.clone()];

commands.forEach(commandLine => {
const parts = commandLine.trim().split(' ');
const command = parts[0];
const param = parts[1] ? parseFloat(parts[1]) : null;
switch (command) {
case 'throttleUp':
if (param !== null) {
simulatedPosition.y += param;
}
break;
case 'throttleDown':
if (param !== null) {
simulatedPosition.y -= param;
}
break;
case 'yawLeft':
if (param !== null) {
simulatedRotation.y += THREE.MathUtils.degToRad(param);
}
break;
case 'yawRight':
if (param !== null) {
simulatedRotation.y -= THREE.MathUtils.degToRad(param);
}
break;
case 'pitchForward':
if (param !== null) {
const forward = new THREE.Vector3(0, 0, -param);
forward.applyEuler(simulatedRotation);
simulatedPosition.add(forward);
}
break;
case 'pitchBackward':
if (param !== null) {
const backward = new THREE.Vector3(0, 0, param);
backward.applyEuler(simulatedRotation);
simulatedPosition.add(backward);
}
break;
case 'rollLeft':
if (param !== null) {
const left = new THREE.Vector3(-param, 0, 0);
left.applyEuler(simulatedRotation);
simulatedPosition.add(left);
}
break;
case 'rollRight':
if (param !== null) {
const right = new THREE.Vector3(param, 0, 0);
right.applyEuler(simulatedRotation);
simulatedPosition.add(right);
}
break;
// Add other commands if necessary
default:
console.warn(`Unknown command: ${command}`);
break;
}
positions.push(simulatedPosition.clone());
});

if (positions.length < 2) {
alert(translations[currentLanguage].noValidCommands);
return;
}

const geometry = new THREE.BufferGeometry().setFromPoints(positions);

const material = new THREE.LineDashedMaterial({
color: 0x0000ff,
dashSize: 0.5,
gapSize: 0.3,
linewidth: 2,
});

const line = new THREE.Line(geometry, material);
line.computeLineDistances(); // Required for dashed lines
scene.add(line);
pathLine = line;
isPathPreviewShown = true;
}
}

// Language switching functionality
const translations = {
en: {
title: "3D Drone Obstacle Course Challenge (upgraded ver.)",
instruction: "Use the command buttons to add movement instructions with parameters, then click 'Run Code' to navigate the drone through the obstacle course.",
throttleUp: "Throttle Up",
throttleDown: "Throttle Down",
yawLeft: "Yaw Left",
yawRight: "Yaw Right",
pitchForward: "Pitch Forward",
pitchBackward: "Pitch Backward",
rollLeft: "Roll Left",
rollRight: "Roll Right",
runCode: "Run Code",
home: "Home",
pathPreview: "Path Preview",
centre: "Centre",
level1: "Level 1",
level2: "Level 2",
level3: "Level 3",
attemptsLabel: "No. of Attempts:",
stepsLabel: "No. of Steps:",
simulationButton: "Code Performance Simulation",
rotateLeft: "Rotate Left",
rotateRight: "Rotate Right",
up: "Up",
down: "Down",
zoomIn: "Zoom In",
zoomOut: "Zoom Out",
congratsHoop: "Congratulations! You've passed through hoop ",
warnWrongHoop: "Please pass through hoop ",
warnWrongHoopFirst: " first!",
warnGoalWithoutHoops: "You've reached the goal without passing all hoops! Please complete all hoops first.",
congratsFinal: "üéâ Congratulations! You've successfully navigated all hoops and reached the goal! üéâ",
aimForGoal: "üõ∏ Aim for the goal! Navigate carefully through all the hoops.",
noValidCommands: "No valid commands to preview the path."
},
zh: {
title: "3D ÁÑ°‰∫∫Ê©üÈöúÁ§ôË™≤Á®ãÊåëÊà∞ÔºàÂçáÁ¥öÁâàÔºâ",
instruction: "‰ΩøÁî®ÂëΩ‰ª§ÊåâÈàïÊ∑ªÂä†Â∏∂ÂèÉÊï∏ÁöÑÁßªÂãïÊåá‰ª§ÔºåÁÑ∂ÂæåÈªûÊìä„ÄåÂü∑Ë°åÁ∑®Á®ã„Äç‰ª•ÂºïÂ∞éÁÑ°‰∫∫Ê©üÈÄöÈÅéÈöúÁ§ôË™≤Á®ã„ÄÇ",
throttleUp: "‰∏äÂçá",
throttleDown: "‰∏ãÈôç",
yawLeft: "Â∑¶ÂÅèËà™",
yawRight: "Âè≥ÂÅèËà™",
pitchForward: "Ââç‰øØ‰ª∞",
pitchBackward: "Âæå‰øØ‰ª∞",
rollLeft: "Â∑¶ÊªæËΩâ",
rollRight: "Âè≥ÊªæËΩâ",
runCode: "Âü∑Ë°åÁ∑®Á®ã",
home: "ËøîÂõûËµ∑Èªû",
pathPreview: "Ë∑ØÂæëÈ†êË¶Ω",
centre: "Â±Ö‰∏≠",
level1: "Á¨¨‰∏ÄÈóú",
level2: "Á¨¨‰∫åÈóú",
level3: "Á¨¨‰∏âÈóú",
attemptsLabel: "ÂòóË©¶Ê¨°Êï∏Ôºö",
stepsLabel: "Ê≠•È©üÊï∏ÁõÆÔºö",
simulationButton: "Á∑®Á®ãË°®ÁèæÊ®°Êì¨",
rotateLeft: "ÂêëÂ∑¶ÊóãËΩâ",
rotateRight: "ÂêëÂè≥ÊóãËΩâ",
up: "Âêë‰∏ä",
down: "Âêë‰∏ã",
zoomIn: "ÊîæÂ§ß",
zoomOut: "Á∏ÆÂ∞è",
congratsHoop: "ÊÅ≠ÂñúÔºÅ‰Ω†Â∑≤Á∂ìÈÄöÈÅé‰∫ÜÂúàÂúà ",
warnWrongHoop: "Ë´ãÂÖàÈÄöÈÅéÂúàÂúà ",
warnWrongHoopFirst: "ÔºÅ",
warnGoalWithoutHoops: "‰Ω†Âà∞ÈÅî‰∫ÜÁµÇÈªû‰ΩÜÊ≤íÊúâÈÄöÈÅéÊâÄÊúâÂúàÂúàÔºÅË´ãÂÖàÂÆåÊàêÊâÄÊúâÂúàÂúà„ÄÇ",
congratsFinal: "üéâ ÊÅ≠ÂñúÔºÅ‰Ω†Â∑≤ÊàêÂäüÈÄöÈÅéÊâÄÊúâÂúàÂúà‰∏¶Âà∞ÈÅîÁµÇÈªûÔºÅüéâ",
aimForGoal: "üõ∏ ÁûÑÊ∫ñÁµÇÈªûÔºÅÂ∞èÂøÉÈÄöÈÅéÊâÄÊúâÂúàÂúà„ÄÇ",
noValidCommands: "Ê≤íÊúâÊúâÊïàÁöÑÊåá‰ª§‰æÜÈ†êË¶ΩË∑ØÂæë„ÄÇ"
}
};

let currentLanguage = 'en';

function toggleLanguage() {
currentLanguage = currentLanguage === 'en' ? 'zh' : 'en';
updateLanguage();
}

function updateLanguage() {
const elements = document.querySelectorAll('[data-translate]');
elements.forEach(element => {
const key = element.getAttribute('data-translate');
if (translations[currentLanguage][key]) {
element.textContent = translations[currentLanguage][key];
}
});

// Update language switch button text
const languageSwitch = document.getElementById('language-switch');
languageSwitch.textContent = currentLanguage === 'en' ? 'ÁπÅÈ´î‰∏≠Êñá' : 'English';

// Update dynamic content
if (messageDiv.textContent.includes("Congratulations") || messageDiv.textContent.includes("ÊÅ≠Âñú")) {
if (messageDiv.textContent.includes("goal")) {
messageDiv.textContent = translations[currentLanguage].congratsFinal;
} else {
const hoopNumber = messageDiv.textContent.match(/\d+/);
if (hoopNumber) {
messageDiv.textContent = translations[currentLanguage].congratsHoop + hoopNumber[0];
}
}
} else if (messageDiv.textContent.includes("Aim for the goal") || messageDiv.textContent.includes("ÁûÑÊ∫ñÁµÇÈªû")) {
messageDiv.textContent = translations[currentLanguage].aimForGoal;
}
}
// Call updateLanguage() at the end of your script to set initial language
updateLanguage();
</script>
</body>
</html>
