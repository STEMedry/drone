<!DOCTYPE html>
<html>
<head>
  <title>Drone Camera Angle of View (AOV) Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
      font-family: Arial, sans-serif;
    }
    canvas { display: block; }

    #title {
      position: fixed;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 1001;
      width: 90%;
      max-width: 600px;
      text-align: center;
    }
    #title h1 {
      margin: 0;
      font-size: 32px;
    }

    #controls {
      font-size: 0.9rem;
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 1000;
      width: 240px;
      box-sizing: border-box;
    }
    .droneAltitudeContainer {
      margin-bottom: 10px;
    }
    #controls button {
      display: block;
      width: 100%;
      margin: 5px 0;
      padding: 8px;
      background: #4CAF50;
      border: none;
      color: white;
      cursor: pointer;
      border-radius: 3px;
    }
    #controls button:hover {
      background: #45a049;
    }

    #additionalControls {
      position: fixed;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      width: 280px;
      box-sizing: border-box;
      overflow-y: visible;
      -webkit-overflow-scrolling: touch;
      top: 10px;
      right: 10px;
      max-height: calc(100vh - 20px);
      font-size: 14px;
    }

    #rightTopButtons {
      display: flex;
      gap: 10px;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    #rightTopButtons button {
      flex: 1;
      padding: 5px 10px;
      font-size: 14px;
      background: #4CAF50;
      border: none;
      color: white;
      border-radius: 3px;
      cursor: pointer;
      transition: background 0.3s;
    }
    #rightTopButtons button:hover,
    #rightTopButtons button:focus {
      background: #45a049;
    }
    #additionalControls h3 {
      font-size: 20px;
      margin: 0px 0 5px;
    }
    #additionalControls label {
      display: block;
      margin-top: 5px;
    }
    #additionalControls input[type="range"] {
      width: 90%;
      height: 10px;
      padding: 7.5px;
      margin: 2px 0 8px;
      font-size: 12px;
    }
    #additionalControls p {
      margin: 5px 0;
    }
    hr {
      border: none;
      border-bottom: 1px solid #555;
      margin: 15px 0;
    }
    @media (max-width: 768px) {
      #additionalControls {
        width: 45%;
        max-width: none;
        font-size: 12px;
        top: 50px;
        right: 2.5%;
      }
      #additionalControls h3 {
        font-size: 14px;
      }
      #additionalControls input[type="range"] {
        font-size: 12px;
        padding: 5px;
        height: 22.5px;
      }
    }
    button {
      background: #4CAF50;
      color: white;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.3s;
    }
    button:hover, button:focus { background: #45a049; }
    button:active { background: #3d8b40; }
    label {
      display: block;
      margin-top: 10px;
      font-weight: bold;
    }
    h3 {
      margin-top: 15px;
      margin-bottom: 5px;
      border-bottom: 1px solid #555;
      padding-bottom: 5px;
    }
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 22.5px;
      background: #d3d3d3;
      outline: none;
      opacity: 0.7;
      transition: opacity 0.2s;
      border-radius: 12px;
      margin: 8px 0;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 22.5px;
      height: 22.5px;
      background: #4CAF50;
      cursor: pointer;
      border-radius: 50%;
    }
    input[type="range"]::-moz-range-thumb {
      width: 22.5px;
      height: 22.5px;
      background: #4CAF50;
      cursor: pointer;
      border-radius: 50%;
    }
    #viewControls {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 90%;
    }
    .viewButton {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .aspectRatioButtons {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    #controls .aspectRatioButtons button,
    #additionalControls .aspectRatioButtons button {
      flex: 1;
      margin: 0 5px;
      padding: 5px;
      font-size: 13px;
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    #controls .aspectRatioButtons button:hover,
    #additionalControls .aspectRatioButtons button:hover {
      background-color: #45a049;
    }
    #controls .aspectRatioButtons button.active,
    #additionalControls .aspectRatioButtons button.active {
      background-color: #FFA500;
    }
    .toggle-building {
      background-color: #4CAF50;
      font-size: 14px;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-top: 2px;
      width: 100%;
    }
    .toggle-building.active {
      background-color: grey !important;
    }
    #tutorialOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }
    #tutorialContent {
      background-color: #fff;
      color: #000;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 600px;
      position: relative;
      box-sizing: border-box;
    }
    #tutorialContent h2 { margin-top: 0; }
    #tutorialContent p { margin: 10px 0; }
    #tutorialContent .step { display: none; }
    #tutorialContent .step.active { display: block; }
    #tutorialOverlay .closeTutorial {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 20px;
      cursor: pointer;
      background: none;
      border: none;
    }
    #tutorialNavigation {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    #tutorialNavigation button {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #tutorialNavigation button:hover {
      background-color: #45a049;
    }
    #highlightBox {
      position: fixed;
      border: 3px solid #FFA500;
      border-radius: 5px;
      z-index: 2500;
      pointer-events: none;
      box-sizing: border-box;
      display: none;
      transition: all 0.3s ease;
      background: transparent;
    }
    #tutorialOverlay.active {
      background-color: rgba(0, 0, 0, 0.8);
    }
    #calc1Results .aovRow {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    #calc1Results .labels span,
    #calc1Results .values span {
      flex: 2;
      text-align: center;
      font-size: 15px;
    }
    @media (max-width: 768px) {
      #calc1Results .labels span,
      #calc1Results .values span {
        font-size: 12px;
      }
    }
    @media (max-width: 768px) {
      #tutorialContent {
        width: 90%;
      }
    }
    #calc2Results {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
    }
    #calc2Results label {
      flex: 1;
      font-size: 14px;
    }
    #calc2Results span {
      flex: 1;
      text-align: right;
      font-size: 15px;
    }
    @media (max-width: 768px) {
      #calc2Results label,
      #calc2Results span {
        font-size: 12px;
      }
    }
    /* Hint icon style */
    .hint-icon {
      cursor: pointer;
      margin-left: 5px;
      font-size: 1em;
      vertical-align: middle;
    }
    /* Pop-up modal for hints */
    .hint-modal-overlay {
      display: none;
      position: fixed;
      z-index: 3000;
      left: 0; top: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }
    .hint-modal-overlay.active {
      display: flex;
    }
    .hint-modal {
      background: #fff;
      color: #222;
      padding: 28px 22px 18px 22px;
      border-radius: 10px;
      max-width: 90vw;
      width: 370px;
      box-shadow: 0 2px 24px rgba(0,0,0,0.19);
      position: relative;
      text-align: left;
      font-size: 1em;
    }
    .hint-modal .closeHint {
      position: absolute;
      top: 8px;
      right: 13px;
      font-size: 20px;
      color: #666;
      cursor: pointer;
      background: none;
      border: none;
    }
    .hint-modal h4 {
      margin-top: 0;
      font-size: 1.15em;
      margin-bottom: 5px;
    }
    .hint-modal p {
      margin: 0;
      font-size: 1em;
    }
    @media (max-width:500px) {
      .hint-modal { width: 95vw; font-size: 0.98em; }
    }

#altitudeAreaCurveBox {
  width: 100%;
  max-width: 370px;
  min-width: 180px;
  margin: 38px auto 0 auto;
  background: #232323;
  border-radius: 12px;
  box-shadow: 0 2px 8px #0005;
  padding: 0 0 10px 0;
  position: relative;
  z-index: 3;
}

.altitude-area-curve-params {
  text-align: center;
  color: #FFD700;
  font-size: 12px;
  font-family: Arial, sans-serif;
  letter-spacing: 0.04em;
  padding-top: 7px;
  padding-bottom: 0px;
  font-weight: bold;
  min-height: 18px;
}

.altitude-area-curve-canvas-container {
  background: #181818;
  padding: 0;
  border-radius: 6px;
  box-shadow: 0 1px 2px #0004;
  margin: 5px 16px 0 32px;
  position: relative;
  overflow: visible;
  min-height: 180px;
}

#altitudeAreaCurve {
  display: block;
  width: 100%;
  height: 180px;
  background: #181818;
  border-radius: 6px;
  margin: 0;
  z-index: 1;
  box-shadow: 0 0 0 0;
}

/* X label below the graph */
.altitude-area-curve-xlabel {
  color: #bbb;
  font-size: 13px;
  text-align: center;
  margin: 5px 0 0 38px;
  font-family: Arial, sans-serif;
}

/* Y label just left of y-axis, vertically centered, 90° anticlockwise (bottom-to-top) */
.altitude-area-curve-ylabel {
  position: absolute;
  left: -12px;
  top: 85%;
  color: #bbb;
  font-size: 13px;
  font-family: Arial, sans-serif;
  transform: translateY(-50%) rotate(-90deg);
  transform-origin: left center;
  width: 125px;
  text-align: right;
  pointer-events: none;
  line-height: 1;
}

@media (max-width: 480px) {
  #altitudeAreaCurveBox {
    max-width: 99vw;
    margin-top: 24px;
    padding-left: 0;
    padding-right: 0;
  }
  .altitude-area-curve-canvas-container { margin-left: 14px; margin-right: 10px;}
  .altitude-area-curve-xlabel { margin-left: 14px;}
  .altitude-area-curve-ylabel { left: -24px; width: 90px; }
}

.altitude-area-curve-author-label {
  color: #FFD700;
  font-size: 12px;
  font-family: Arial, sans-serif;
  margin: 12px 18px 0 0;
  text-align: right;
  letter-spacing: 0.03em;
  font-weight: bold;
}
@media (max-width: 480px) {
  .altitude-area-curve-author-label {
    font-size: 15px;
    margin-right: 8px;
  }
}

  </style>
</head>
<body>
  <!-- Title -->
  <div id="title">
    <h1 data-i18n="Dronography AOV Simulation" data-i18n-zh="航拍視角模擬">Dronography AOV Simulation</h1>
  </div>
  <!-- Left Panel Controls -->
  <div id="controls">
<h2>
  <span class="heading-text" data-i18n="1. Calculate Area" data-i18n-zh="1. 計算面積">1. Calculate Area</span>
</h2>
    <h3 data-i18n="Aspect Ratio" data-i18n-zh="畫幅比例">Aspect Ratio</h3>
    <div class="aspectRatioButtons">
      <button class="aspectRatioBtn" data-ratio="1.5" data-i18n="3:2" data-i18n-zh="3:2">3:2</button>
      <button class="aspectRatioBtn" data-ratio="1.333" data-i18n="4:3" data-i18n-zh="4:3">4:3</button>
      <button class="aspectRatioBtn" data-ratio="1.778" data-i18n="16:9" data-i18n-zh="16:9">16:9</button>
    </div>

    <div class="droneAltitudeContainer">
      <label for="droneAltitudeSlider">
        <span data-i18n="Drone Altitude:" data-i18n-zh="無人機高度：">Drone Altitude:</span>
        <input type="number" id="droneAltitudeValue" value="0" step="0.1" style="width:50px; height:30px;"> m
      </label>
      <input type="range" id="droneAltitudeSlider" min="0" max="500" value="0" step="0.1">
    </div>
    <div>
      <label for="aov">
        <span data-i18n="Horizontal AOV:" data-i18n-zh="水平視角:">Horizontal AOV:</span>
        <input type="number" id="aovValue" value="70" step="0.1" style="width:50px; height:30px;"> °
      </label>
      <input type="range" id="aov" min="30" max="120" value="70" step="0.1">
    </div>
    <div id="verticalDiagonalAOV">
      <label>
        <span data-i18n="Vertical AOV:" data-i18n-zh="垂直視角:">Vertical AOV:</span>
        <span id="vaovValue">0.0</span> °
      </label>
      <label>
        <span data-i18n="Diagonal AOV:" data-i18n-zh="對角視角:">Diagonal AOV:</span>
        <span id="daovValue">0.0</span> °
      </label>
    </div>

<div id="altitudeFOVMeasurements">
  <label>
    <span data-i18n="Drone Altitude:" data-i18n-zh="無人機高度:">Drone Altitude:</span>
    <span id="altitudeValue">0</span> m
  </label>
  <label>
    <span data-i18n="FOV Width:" data-i18n-zh="視野寬度:">FOV Width:</span>
    <span id="widthValue">0</span> m
    <button type="button" id="showFOVWidthBtn" style="display:inline-block;width:auto;padding:2px 10px;font-size:12px;margin-left:6px;">Show</button>
  </label>
  <label>
    <span data-i18n="FOV Height:" data-i18n-zh="視野高度:">FOV Height:</span>
    <span id="heightValue">0</span> m
    <button type="button" id="showFOVHeightBtn" style="display:inline-block;width:auto;padding:2px 10px;font-size:12px;margin-left:6px;">Show</button>
  </label>
  <label>
    <span data-i18n="Area Captured:" data-i18n-zh="捕捉面積:">Area Captured:</span>
    <span id="areaValue">0</span> m²
  </label>
</div>

    <hr>
    <div>
      <button id="toggleSchoolBuilding" class="toggle-building">
        <span data-i18n="School Building" data-i18n-zh="學校建築">School Building</span>
      </button>
    </div>
    <div>
      <button id="toggleTridentBlocks" class="toggle-building">
        <span data-i18n="Trident Blocks" data-i18n-zh="Y-型大廈">Trident Blocks</span>
      </button>
    </div>
    <div>
      <button id="toggleBankTower" class="toggle-building">
        <span data-i18n="Bank Tower" data-i18n-zh="銀行大廈">Bank Tower</span>
      </button>
    </div>
  </div>

  <!-- Right Panel Calculation Controls -->
  <div id="additionalControls">
    <div id="rightTopButtons">
      <button id="languageToggle">繁體中文</button>
      <button id="startTutorial" data-i18n="Start Tutorial" data-i18n-zh="開始教程">Start Tutorial</button>
    </div>
<h3>
  <span class="heading-text" data-i18n="2. Calculate AOV" data-i18n-zh="2. 計算視角">2. Calculate AOV</span>
</h3>
    <div class="aspectRatioButtons">
      <button class="aspectRatioBtn" data-ratio="1.5" data-i18n="3:2" data-i18n-zh="3:2">3:2</button>
      <button class="aspectRatioBtn" data-ratio="1.333" data-i18n="4:3" data-i18n-zh="4:3">4:3</button>
      <button class="aspectRatioBtn" data-ratio="1.778" data-i18n="16:9" data-i18n-zh="16:9">16:9</button>
    </div>
    <div>
      <label for="calc1Altitude">
        <span data-i18n="Drone Altitude:" data-i18n-zh="無人機高度：">Drone Altitude:</span>
        <input type="number" id="calc1AltitudeValue" value="0" step="0.1" style="width:50px; height:30px;"> m
      </label>
      <input type="range" id="calc1Altitude" min="0" max="500" value="0" step="0.1" tabindex="0">
    </div>
    <div>
      <label for="calc1FOVWidth">
        <span data-i18n="FOV Width:" data-i18n-zh="視角寬度：">FOV Width:</span>
        <input type="number" id="calc1FOVWidthValue" value="0" step="0.1" style="width:50px; height:30px;"> m
      </label>
      <input type="range" id="calc1FOVWidth" min="0" max="1732" value="0" step="0.1" tabindex="0">
    </div>
    <div id="calc1Results">
      <div class="aovRow labels">
        <span data-i18n="Horizontal AOV:" data-i18n-zh="水平視角：">Horizontal AOV:</span>
        <span data-i18n="Vertical AOV:" data-i18n-zh="垂直視角：">Vertical AOV:</span>
        <span data-i18n="Diagonal AOV:" data-i18n-zh="對角視角：">Diagonal AOV:</span>
      </div>
      <div class="aovRow values">
        <span id="calc1HorizontalAOV">0.0</span>°
        <span id="calc1VerticalAOV">0.0</span>°
        <span id="calc1DiagonalAOV">0.0</span>°
      </div>
    </div>




<!-- Altitude vs Area Curve Box (insert after #calc1Results) -->
<div id="altitudeAreaCurveBox">
  <div class="altitude-area-curve-params" id="curveParams"></div>
  <div class="altitude-area-curve-canvas-container">
    <canvas id="altitudeAreaCurve" width="340" height="180" aria-label="Graph of Area vs Altitude"></canvas>
    <div class="altitude-area-curve-ylabel">Area Captured (m²)</div>
  </div>
  <div class="altitude-area-curve-xlabel">Drone Altitude (m)</div>
  <div class="altitude-area-curve-author-label">C Y YEUNG, EDUHK</div>
</div>

  <!-- View Control Buttons -->
  <div id="viewControls">
    <button class="viewButton" id="tiltUp" aria-label="Tilt Up">↑</button>
    <button class="viewButton" id="tiltDown" aria-label="Tilt Down">↓</button>
    <button class="viewButton" id="rotateLeft" aria-label="Rotate Left">←</button>
    <button class="viewButton" id="rotateRight" aria-label="Rotate Right">→</button>
    <button class="viewButton" id="zoomIn" aria-label="Zoom In">+</button>
    <button class="viewButton" id="zoomOut" aria-label="Zoom Out">-</button>
    <button class="viewButton" id="homeView" aria-label="Home View">⌂</button>
    <button class="viewButton" id="moveUp" aria-label="Move Up">▲</button>
    <button class="viewButton" id="moveDown" aria-label="Move Down">▼</button>
    <button class="viewButton" id="moveForward" aria-label="Move Forward">↥</button>
    <button class="viewButton" id="moveBackward" aria-label="Move Backward">↧</button>
  </div>

  <!-- Tutorial Overlay -->
  <div id="tutorialOverlay">
    <div id="tutorialContent">
      <button class="closeTutorial" aria-label="Close Tutorial">×</button>
      <div class="step active" data-step="1">
        <h2 data-i18n="Welcome to the Tutorial" data-i18n-zh="歡迎來到教程">Welcome to the Tutorial</h2>
        <p data-i18n="This tutorial will guide you through the various features of the Dronography AOV Simulation. Let's get started!" data-i18n-zh="本教程將引導您了解航拍視角模擬的各種功能。讓我們開始吧！">
          This tutorial will guide you through the various features of the Dronography AOV Simulation. Let's get started!
        </p>
      </div>
      <div class="step" data-step="2">
        <h2 data-i18n="Aspect Ratio Selection" data-i18n-zh="畫幅比例選擇">Aspect Ratio Selection</h2>
        <p data-i18n="Use the Aspect Ratio buttons to select the desired aspect ratio. This changes how the camera view is proportioned." data-i18n-zh="使用畫幅比例按鈕選擇所需的畫幅比例。這將改變相機視圖的比例。">
          Use the Aspect Ratio buttons to select the desired aspect ratio. This changes how the camera view is proportioned.
        </p>
        <p data-i18n="Available options: 3:2, 4:3, 16:9." data-i18n-zh="可用選項：3:2，4:3，16:9。">
          Available options: 3:2, 4:3, 16:9.
        </p>
      </div>
      <div class="step" data-step="3">
        <h2 data-i18n="Adjusting Horizontal AOV" data-i18n-zh="調整水平視角">Adjusting Horizontal AOV</h2>
        <p data-i18n="The Horizontal AOV slider allows you to adjust the horizontal angle of view of the drone's camera. Drag the slider to increase or decrease the angle." data-i18n-zh="水平視角滑桿允許您調整無人機相機的水平視角。拖動滑桿以增加或減少角度。">
          The Horizontal AOV slider allows you to adjust the horizontal angle of view of the drone's camera. Drag the slider to increase or decrease the angle.
        </p>
        <p data-i18n="Current AOV value is displayed next to the slider." data-i18n-zh="當前視角值顯示在滑桿旁邊。">
          Current AOV value is displayed next to the slider.
        </p>
      </div>
      <div class="step" data-step="4">
        <h2 data-i18n="Vertical and Diagonal AOV" data-i18n-zh="垂直與對角視角">Vertical and Diagonal AOV</h2>
        <p data-i18n="Based on the Horizontal AOV and selected Aspect Ratio, the simulation calculates the Vertical AOV automatically and mirrors it on the right panel." data-i18n-zh="根據水平視角和選定的畫幅比例，模擬會自動計算垂直視角，並在右側面板同步更新。">
          Based on the Horizontal AOV and selected Aspect Ratio, the simulation calculates the Vertical AOV automatically and mirrors it on the right panel.
        </p>
      </div>
      <div class="step" data-step="5">
        <h2 data-i18n="Altitude and FOV Measurements" data-i18n-zh="高度與視野測量">Altitude and FOV Measurements</h2>
        <p data-i18n="The simulation displays the drone's altitude, the width and height of the field of view (FOV), and the area captured. These metrics update in real-time as you adjust settings." data-i18n-zh="模擬顯示無人機的高度、視野的寬度與高度以及捕捉面積。這些指標會隨著您調整設置而實時更新。">
          The simulation displays the drone's altitude, the width and height of the field of view (FOV), and the area captured. These metrics update in real-time as you adjust settings.
        </p>
      </div>
      <div class="step" data-step="6">
        <h2 data-i18n="Toggling Buildings" data-i18n-zh="切換建築物">Toggling Buildings</h2>
        <p data-i18n="Use the toggle buttons to show or hide different buildings in the simulation. This helps in visualizing how buildings affect the camera's field of view." data-i18n-zh="使用切換按鈕選擇顯示或隱藏模擬中的不同建築物，幫助您觀察建築物如何影響相機視角。">
          Use the toggle buttons to show or hide different buildings in the simulation. This helps in visualizing how buildings affect the camera's field of view.
        </p>
      </div>
      <div class="step" data-step="7">
        <h2 data-i18n="Calculation Controls" data-i18n-zh="計算控制">Calculation Controls</h2>

<div class="step" data-step="7">
  <h2 data-i18n="Calculation Controls" data-i18n-zh="計算控制">Calculation Controls</h2>
  <p data-i18n="The right panel displays the horizontal and vertical AOV values along with the FOV Width and Diagonal AOV. These values synchronize with the drone altitude and FOV measurements shown in section 1 and 2." 
     data-i18n-zh="右側面板自動顯示水平與垂直視角、視角寬度與對角視角，並與第1與第2部分顯示的無人機高度與FOV測量數據同步。">
    The right panel displays the horizontal and vertical AOV values along with the FOV Width and Diagonal AOV. These values synchronize with the drone altitude and FOV measurements shown in section 1 and 2.
  </p>
</div>

      <div class="step" data-step="8">
        <h2 data-i18n="View Controls" data-i18n-zh="視圖控制">View Controls</h2>
        <p data-i18n="Use the view control buttons at the bottom to manipulate the camera view. You can tilt, rotate, zoom, and move the camera to better observe the simulation." data-i18n-zh="使用底部的視圖控制按鈕移動相機。您可以傾斜、旋轉、縮放及移動相機，以更好地觀察模擬。">
          Use the view control buttons at the bottom to manipulate the camera view. You can tilt, rotate, zoom, and move the camera to better observe the simulation.
        </p>
      </div>
      <div class="step" data-step="9">
        <h2 data-i18n="Language Toggle" data-i18n-zh="語言切換">Language Toggle</h2>
        <p data-i18n="Click the language toggle button to switch between English and Traditional Chinese." data-i18n-zh="點擊語言切換按鈕來切換英文與繁體中文。">
          Click the language toggle button to switch between English and Traditional Chinese.
        </p>
      </div>
      <div class="step" data-step="10">
        <h2 data-i18n="Tutorial Complete" data-i18n-zh="教程完成">Tutorial Complete</h2>
        <p data-i18n="You are now ready to explore the simulation. Experiment with different settings to see how they affect the camera's field of view." data-i18n-zh="您現在可以開始使用模擬。嘗試不同設置以觀察其如何影響相機視角。">
          You are now ready to explore the simulation. Experiment with different settings to see how they affect the camera's field of view.
        </p>
      </div>
      <div id="tutorialNavigation">
        <button id="prevStep" data-i18n="Previous" data-i18n-zh="上一頁">Previous</button>
        <button id="nextStep" data-i18n="Next" data-i18n-zh="下一頁">Next</button>
      </div>
    </div>
  </div>

  <!-- Highlight Box for Tutorial -->
  <div id="highlightBox"></div>

  
  <!-- Three.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    /*******************************************************
     * Global Variables Declaration
     *******************************************************/
    let scene, camera, renderer;
    let drone; 
    let propellers = [];
    let blinkingLights = [];
    let blinkState = true;
    let lastBlinkTime = 0;
    const BLINK_INTERVAL = 500;
    let verticalLine, fovLines, diagonals;
    let cornerLabels = [];
    let dimensionLabels = [];
    let centerLabel = null;
    let fovArea;

    let cameraDistance = 100;
    let cameraAngle = Math.PI / 2;
    let cameraTilt = 0.5;
    let cameraTargetY = 0; 
    
    let schoolBuilding, bankTower, tridentBlocks;
    
    const warnSound = new Audio('warn2.mp3');
    warnSound.preload = 'auto';
    
    // Global variables for dragging (for view orientation and building dragging)
    let isDragging = false;
    let dragStartPosition = { x: 0, y: 0 };
    let mouse = new THREE.Vector2();
    let raycaster = new THREE.Raycaster();
    let draggedBuilding = null;
    let buildingDragStartX = 0;
    let mouseStartX = 0;
    
    let showFOVWidthLabel = false;
    let showFOVHeightLabel = false;


    /*******************************************************
     * Helper Functions
     *******************************************************/
    function playWarnSound() {
      warnSound.currentTime = 0;
      warnSound.play().catch(error => console.error("Error playing warning sound:", error));
    }
    
    function getMaxDiagonalAOV(aspectRatio) {
      const maxHorizontalAOV = 120;
      const horizontalAOVRad = THREE.MathUtils.degToRad(maxHorizontalAOV);
      const verticalAOVRad = 2 * Math.atan(Math.tan(horizontalAOVRad / 2) / aspectRatio);
      const horizontalTan = Math.tan(THREE.MathUtils.degToRad(maxHorizontalAOV) / 2);
      const verticalTan = Math.tan(verticalAOVRad / 2);
      const diagonalTan = Math.sqrt(horizontalTan * horizontalTan + verticalTan * verticalTan);
      const diagonalAOVRad = 2 * Math.atan(diagonalTan);
      return THREE.MathUtils.radToDeg(diagonalAOVRad);
    }
    
    let currentMaxDiagonalAOV = getMaxDiagonalAOV(1.5);
    
    function createDottedLine(points, color = 0x000000) {
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineDashedMaterial({
        color: color,
        dashSize: 1,
        gapSize: 2
      });
      const line = new THREE.Line(geometry, material);
      line.computeLineDistances();
      return line;
    }
    
    function createPropeller(color) {
      const geometry = new THREE.BoxGeometry(3, 0.2, 0.4);
      const material = new THREE.MeshBasicMaterial({ color: color });
      return new THREE.Mesh(geometry, material);
    }
    
    function createBlinkingLight() {
      const geometry = new THREE.SphereGeometry(0.3, 16, 16);
      const material = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 1 });
      return new THREE.Mesh(geometry, material);
    }
    
    function createCornerLabel(text, position) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const context = canvas.getContext('2d');
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.font = 'bold 30px Arial';
      context.fillStyle = '#00FF00';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, 128, 128);
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.position.copy(position);
      sprite.scale.set(30, 30, 1);
      return sprite;
    }
    
function createDimensionLabel(text, position, scale) {
  // Estimate required font size (px) based on scale
  const fontPx = Math.round(scale * 0.25); // 0.45 is a good ratio for 3D sprite scaling
  // Measure text width to decide canvas size
  let tmpCanvas = document.createElement('canvas');
  let ctx = tmpCanvas.getContext('2d');
  ctx.font = `bold ${fontPx}px Arial`;
  const metrics = ctx.measureText(text);
  const textW = Math.ceil(metrics.width);
  const textH = Math.ceil(metrics.width);

  // Canvas: add margin to avoid clipping
  const pad = 16;
  const canvasW = textW + pad * 2;
  const canvasH = textH + pad * 2;

  const canvas = document.createElement('canvas');
  canvas.width = canvasW;
  canvas.height = canvasH;
  const context = canvas.getContext('2d');
  context.clearRect(0, 0, canvasW, canvasH);
  context.font = `bold ${fontPx}px Arial`;
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.lineWidth = 4;
  context.strokeStyle = 'rgba(0,0,0,0.8)';
  // Shadow for better contrast
  context.shadowColor = "black";
  context.shadowBlur = 4;
  context.strokeText(text, canvasW / 2, canvasH / 2);
  context.shadowBlur = 0;
  context.fillStyle = 'white';
  context.fillText(text, canvasW / 2, canvasH / 2);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(spriteMaterial);
  sprite.position.copy(position);

  // Set sprite scale so that its width in world units ≈ scale argument
  // (Sprite default is 1x1 units for 256x256 px, so scale accordingly)
  const ratio = canvasW / canvasH;
  sprite.scale.set(scale * ratio, scale, 1);

  return sprite;
}
    
    function createCenterLabel(text, position) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const context = canvas.getContext('2d');
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.font = 'bold 24px Arial';
      context.fillStyle = '#00FF00';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, 128, 128);
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.position.copy(position);
      sprite.scale.set(30, 30, 1);
      return sprite;
    }
    
    /*****************
     * FOV Width Synchronization
     *****************/
    // New helper function to synchronize the FOV width value across all sections.
function syncFOVWidth(width) {
  document.getElementById('calc1FOVWidth').value = width.toFixed(1);
  document.getElementById('calc1FOVWidthValue').value = width.toFixed(1);
}
    
    /*****************
     * Building & Court Functions
     *****************/
    // (The building and court functions remain unchanged.)
    
    function createCourt() {
      // ... [Court creation code remains unchanged] ...
      const courtGroup = new THREE.Group();
      const courtLength = 94;
      const courtWidth = 50;
      const sideAreaWidth = 8;
      const endAreaLength = 8;
      const mainGeometry = new THREE.PlaneGeometry(courtWidth, courtLength);
      const mainMaterial = new THREE.MeshBasicMaterial({ color: 0x2e8b57, side: THREE.DoubleSide });
      const mainCourt = new THREE.Mesh(mainGeometry, mainMaterial);
      mainCourt.rotation.x = -Math.PI/2;
      mainCourt.position.y = 0.01;
      courtGroup.add(mainCourt);
    
      const sideGeometry = new THREE.PlaneGeometry(sideAreaWidth, courtLength+(2*endAreaLength));
      const sideMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500, side: THREE.DoubleSide });
      const leftSide = new THREE.Mesh(sideGeometry, sideMaterial);
      leftSide.rotation.x = -Math.PI/2;
      leftSide.position.x = -(courtWidth/2 + sideAreaWidth/2);
      courtGroup.add(leftSide);
    
      const rightSide = new THREE.Mesh(sideGeometry, sideMaterial);
      rightSide.rotation.x = -Math.PI/2;
      rightSide.position.x = (courtWidth/2 + sideAreaWidth/2);
      courtGroup.add(rightSide);
    
      const endGeometry = new THREE.PlaneGeometry(courtWidth+(2*sideAreaWidth), endAreaLength);
      const endMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500, side: THREE.DoubleSide });
      const frontEnd = new THREE.Mesh(endGeometry, endMaterial);
      frontEnd.rotation.x = -Math.PI/2;
      frontEnd.position.z = -(courtLength/2+endAreaLength/2);
      courtGroup.add(frontEnd);
    
      const backEnd = new THREE.Mesh(endGeometry, endMaterial);
      backEnd.rotation.x = -Math.PI/2;
      backEnd.position.z = (courtLength/2+endAreaLength/2);
      courtGroup.add(backEnd);
    
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
      function addLine(points) {
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, lineMaterial);
        courtGroup.add(line);
      }
    
      addLine([
        new THREE.Vector3(-courtWidth/2, 0.01, -courtLength/2),
        new THREE.Vector3(courtWidth/2, 0.01, -courtLength/2),
        new THREE.Vector3(courtWidth/2, 0.01, courtLength/2),
        new THREE.Vector3(-courtWidth/2, 0.01, courtLength/2),
        new THREE.Vector3(-courtWidth/2, 0.01, -courtLength/2)
      ]);
    
      addLine([
        new THREE.Vector3(-courtWidth/2, 0.01, 0),
        new THREE.Vector3(courtWidth/2, 0.01, 0)
      ]);
    
      const centerCircle = new THREE.CircleGeometry(10, 32);
      const circleEdges = new THREE.EdgesGeometry(centerCircle);
      const centerCircleLine = new THREE.LineSegments(circleEdges, lineMaterial);
      centerCircleLine.rotation.x = -Math.PI/2;
      centerCircleLine.position.y = 0.01;
      courtGroup.add(centerCircleLine);
    
      [-courtLength/2+19, courtLength/2-19].forEach(z => {
        addLine([
          new THREE.Vector3(-6, 0.01, z),
          new THREE.Vector3(6, 0.01, z)
        ]);
        addLine([
          new THREE.Vector3(-6, 0.01, z),
          new THREE.Vector3(-6, 0.01, z+(z<0?-19:19))
        ]);
        addLine([
          new THREE.Vector3(6, 0.01, z),
          new THREE.Vector3(6, 0.01, z+(z<0?-19:19))
        ]);
        for(let i=0;i<=360;i++){
          const angle = Math.PI*i/180;
          const x = 6*Math.cos(angle);
          const zOffset = 6*Math.sin(angle);
          if(Math.abs(x)>6 || (z<0 && zOffset>0)||(z>0 && zOffset<0)){
            addLine([
              new THREE.Vector3(x, 0.01, z+zOffset),
              new THREE.Vector3(6*Math.cos((i+1)*Math.PI/180),0.01, z+6*Math.sin((i+1)*Math.PI/180))
            ]);
          } else if(i%10<5){
            addLine([
              new THREE.Vector3(x, 0.01, z+zOffset),
              new THREE.Vector3(6*Math.cos((i+2)*Math.PI/180),0.01, z+6*Math.sin((i+2)*Math.PI/180))
            ]);
          }
        }
      });
    
      [1,-1].forEach(sign=>{
        const z = sign*(courtLength/2);
        const points = [];
        for(let i=0; i<=180; i++){
          const angle = Math.PI + (i*Math.PI/180);
          points.push(new THREE.Vector3(Math.cos(angle)*23.75, 0.01, z + (sign*(Math.sin(angle)*25.25))));
        }
        addLine(points);
      });
    
      function createBackboardAndHoop(posZ, rotation) {
        const backboardGroup = new THREE.Group();
        const standGeometry = new THREE.BoxGeometry(0.5,12,0.5);
        const standMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
        const stand = new THREE.Mesh(standGeometry, standMaterial);
        stand.position.y = 6;
        stand.position.z = posZ + (rotation===0?-4:4);
        backboardGroup.add(stand);
        const beamGeometry = new THREE.BoxGeometry(0.5,0.5,4);
        const beam = new THREE.Mesh(beamGeometry, standMaterial);
        beam.position.y = 10;
        beam.position.z = posZ + (rotation===0?-2:2);
        backboardGroup.add(beam);
        const backboardGeometry = new THREE.BoxGeometry(6,3.5,0.2);
        const backboardMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);
        const blackRectGeometry = new THREE.BoxGeometry(2,1.5,0.21);
        const blackRectMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackRect = new THREE.Mesh(blackRectGeometry, blackRectMaterial);
        blackRect.position.z = 0.1;
        backboard.add(blackRect);
        backboard.position.y = 10;
        backboard.position.z = posZ;
        backboard.rotation.y = rotation;
        backboardGroup.add(backboard);
        const hoopGeometry = new THREE.TorusGeometry(0.75,0.1,16,100);
        const hoopMaterial = new THREE.MeshBasicMaterial({ color: 0xff4500 });
        const hoop = new THREE.Mesh(hoopGeometry, hoopMaterial);
        hoop.position.y = 10;
        hoop.position.z = posZ + (rotation===0?1:-1);
        hoop.rotation.x = Math.PI/2;
        backboardGroup.add(hoop);
        const netMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        for(let i=0;i<12;i++){
          const angle = (i/12)*Math.PI*2;
          const netGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0.75*Math.cos(angle),0,0.75*Math.sin(angle)),
            new THREE.Vector3(0.4*Math.cos(angle),-1.5,0.4*Math.sin(angle))
          ]);
          const netLine = new THREE.Line(netGeometry,netMaterial);
          netLine.position.y = 10;
          netLine.position.z = posZ + (rotation===0?1:-1);
          backboardGroup.add(netLine);
        }
        return backboardGroup;
      }
    
      courtGroup.add(createBackboardAndHoop(courtLength/2, Math.PI));
      courtGroup.add(createBackboardAndHoop(-courtLength/2, 0));
      return courtGroup;
    }
    
    function createSchoolBuilding() {
      const building = new THREE.Group();
      const mainGeometry = new THREE.BoxGeometry(65,31,10);
      const mainMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
      const mainBlock = new THREE.Mesh(mainGeometry, mainMaterial);
      mainBlock.position.y = 15.5;
      building.add(mainBlock);
      const mainEdges = new THREE.EdgesGeometry(mainGeometry);
      const mainOutline = new THREE.LineSegments(mainEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
      mainBlock.add(mainOutline);
      const accentGeometry = new THREE.BoxGeometry(3,31,1);
      const accentMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const accentPositions = [-15, -5, 5, 15];
      accentPositions.forEach(xPos=>{
        const accent = new THREE.Mesh(accentGeometry, accentMaterial);
        accent.position.set(xPos,15.5,5.1);
        building.add(accent);
        const accentEdges = new THREE.EdgesGeometry(accentGeometry);
        const accentOutline = new THREE.LineSegments(accentEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
        accent.add(accentOutline);
      });
      const windowRows = 7;
      const windowCols = 15;
      const windowGeometry = new THREE.BoxGeometry(2,1.5,0.1);
      const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
      for(let i=0;i<windowRows;i++){
        for(let j=0;j<windowCols;j++){
          const win = new THREE.Mesh(windowGeometry, windowMaterial);
          win.position.x = -17 + (j*3);
          win.position.y = -6 + (i*3) + 15;
          win.position.z = 5.05;
          building.add(win);
        }
      }
      const hallGeometry = new THREE.BoxGeometry(20,16,24);
      const hallMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
      const hall = new THREE.Mesh(hallGeometry, hallMaterial);
      hall.position.set(22.5,-7+16,17.1);
      building.add(hall);
      const hallEdges = new THREE.EdgesGeometry(hallGeometry);
      const hallOutline = new THREE.LineSegments(hallEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
      hall.add(hallOutline);
      const leftblockGeometry = new THREE.BoxGeometry(23,31,20);
      const leftblockMaterial = new THREE.MeshPhongMaterial({ color: 0x1E90FF });
      const leftblock = new THREE.Mesh(leftblockGeometry, leftblockMaterial);
      leftblock.position.set(-21,-13.5+29,5);
      building.add(leftblock);
      const leftblockEdges = new THREE.EdgesGeometry(leftblockGeometry);
      const leftblockOutline = new THREE.LineSegments(leftblockEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
      leftblock.add(leftblockOutline);
      const leftWndRows = 7;
      const leftWndCols = 8;
      const leftWndGeometry = new THREE.BoxGeometry(3,1.5,0.3);
      const leftWndMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
      for(let i=0;i<leftWndRows;i++){
        for(let j=0;j<leftWndCols;j++){
          const win = new THREE.Mesh(leftWndGeometry, leftWndMaterial);
          win.position.x = -30 + (j*2.5);
          win.position.y = -11 + (i*3) + 20;
          win.position.z = 15.05;
          building.add(win);
        }
      }
      const columnGeometry = new THREE.BoxGeometry(0.5,3,0.5);
      const columnMaterial = new THREE.MeshPhongMaterial({ color: 0xDDDDDD });
      for(let i=6;i<10;i++){
        const col = new THREE.Mesh(columnGeometry, columnMaterial);
        col.position.set(-20,-13.5+15,-18+(i*3));
        building.add(col);
      }
      building.children.forEach(child=>{
        if(child !== mainBlock && child !== hall && child !== leftblock && child.geometry){
          const edges = new THREE.EdgesGeometry(child.geometry);
          const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
          child.add(outline);
        }
      });
      const frontCourtPositions = [
        { x: -10, z: 24 },
        { x: -10, z: 44 }
      ];
      frontCourtPositions.forEach(pos=>{
        const court = createCourt();
        court.position.set(pos.x,0,pos.z);
        building.add(court);
        court.rotation.y += Math.PI/2;
        court.scale.set(0.3,0.3,0.3);
      });
      const shape = new THREE.Shape();
      shape.moveTo(0,0);
      shape.lineTo(8,0);
      shape.lineTo(8,8);
      shape.lineTo(1.5,8);
      shape.lineTo(0,0);
      const extrudeSettings = { steps: 1, depth: 5, bevelEnabled: false };
      const trapezoidGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      const trapezoidMaterial = new THREE.MeshPhongMaterial({ color: 0xA0A0A0 });
      const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
      trapezoid.rotation.y = -Math.PI/2;
      trapezoid.rotation.z = -Math.PI/2;
      trapezoid.position.set(-2,20+0.1,-5);
      const trapezoidEdges = new THREE.EdgesGeometry(trapezoidGeometry);
      const trapezoidOutline = new THREE.LineSegments(trapezoidEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
      trapezoid.add(trapezoidOutline);
      leftblock.add(trapezoid);
      return building;
    }
    
    function createBankGridTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ADD8E6';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.strokeStyle = '#ADD8E6';
      ctx.lineWidth = 5;
      const majorGridSize = 64;
      ctx.globalAlpha = 0.8;
      for(let i=0; i<=canvas.width; i+=majorGridSize) {
        ctx.beginPath();
        ctx.moveTo(i,0);
        ctx.lineTo(i,canvas.height);
        ctx.stroke();
      }
      for(let i=0; i<=canvas.height; i+=majorGridSize) {
        ctx.beginPath();
        ctx.moveTo(0,i);
        ctx.lineTo(canvas.width,i);
        ctx.stroke();
      }
      const minorGridSize = 32;
      ctx.globalAlpha = 0.4;
      ctx.lineWidth = 1;
      for(let i=0; i<=canvas.width; i+=minorGridSize) {
        if(i % majorGridSize !== 0) {
          ctx.beginPath();
          ctx.moveTo(i,0);
          ctx.lineTo(i,canvas.height);
          ctx.stroke();
        }
      }
      for(let i=0; i<=canvas.height; i+=minorGridSize) {
        if(i % majorGridSize !== 0) {
          ctx.beginPath();
          ctx.moveTo(0,i);
          ctx.lineTo(canvas.width,i);
          ctx.stroke();
        }
      }
      return new THREE.CanvasTexture(canvas);
    }
    
    function createBankInclinedTriangularPrism(baseSize, height) {
      const group = new THREE.Group();
      const gridTexture = createBankGridTexture();
      const vertices = new Float32Array([
        -baseSize, 0, baseSize,
         baseSize, 0, baseSize,
         0,0,-baseSize,
         -baseSize*0.7, height, baseSize*0.7,
         baseSize*0.7, height, baseSize*0.7,
         0, height, -baseSize*0.7,
      ]);
      const indices = new Uint16Array([
        0,1,2,
        3,4,5,
        0,1,4,
        0,4,3,
        1,2,5,
        1,5,4,
        2,0,3,
        2,3,5,
      ]);
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      geometry.computeVertexNormals();
      const material = new THREE.MeshPhongMaterial({
        map: gridTexture,
        color: 0xFFFFFF,
        specular: 0x666666,
        shininess: 80,
        side: THREE.DoubleSide
      });
      const prism = new THREE.Mesh(geometry, material);
      group.add(prism);
      const edges = new THREE.EdgesGeometry(geometry);
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 3, opacity: 1 });
      const lineSegments = new THREE.LineSegments(edges, lineMaterial);
      group.add(lineSegments);
      return group;
    }
    
    function createBankAntennas() {
      const antennaGroup = new THREE.Group();
      const antennaPositions = [
        [-5,0,0],
        [0,0,0],
        [5,0,0]
      ];
      antennaPositions.forEach(position=>{
        const poleGeometry = new THREE.CylinderGeometry(0.2,0.2,65,12);
        const poleMaterial = new THREE.MeshPhongMaterial({
          color: 0xffff00,
          emissive: 0xffff00,
          emissiveIntensity: 1,
          specular: 0x666666,
          shininess: 60
        });
        const pole = new THREE.Mesh(poleGeometry, poleMaterial);
        pole.position.set(position[0],15,position[2]);
        const crossGeometry = new THREE.CylinderGeometry(0.2,0.2,5,50);
        const cross1 = new THREE.Mesh(crossGeometry, poleMaterial);
        cross1.rotation.z = Math.PI/4;
        cross1.position.y = 10;
        pole.add(cross1);
        const cross2 = new THREE.Mesh(crossGeometry, poleMaterial);
        cross2.rotation.z = -Math.PI/4;
        cross2.position.y = 5;
        pole.add(cross2);
        antennaGroup.add(pole);
      });
      return antennaGroup;
    }
    
    function createBankTower() {
      const buildingGroup = new THREE.Group();
      const baseSize = 60;
      const scale = 0.28;
      const sections = [
        { height: 420, offset: [0,0,0] },
        { height: 680, offset: [baseSize*scale*0.5,0, -baseSize*scale*0.866] },
        { height: 850, offset: [-baseSize*scale*0.5,0, -baseSize*scale*0.866] },
        { height: 1130, offset: [0,0, -baseSize*scale*1.732] }
      ];
      sections.forEach(section=>{
        const prism = createBankInclinedTriangularPrism(baseSize*scale, section.height*scale);
        prism.position.set(...section.offset);
        buildingGroup.add(prism);
      });
      const antennas = createBankAntennas();
      const lastSection = sections[sections.length-1];
      const midHeight = lastSection.height*scale;
      antennas.position.set(lastSection.offset[0], midHeight, lastSection.offset[2]);
      buildingGroup.add(antennas);
      buildingGroup.rotation.y = Math.PI/4;
      return buildingGroup;
    }
    
    function createTridentBlocks() {
      const trident = new THREE.Group();
      const buildingMaterial = new THREE.MeshPhongMaterial({
        color: 0xA3A3A3,
        flatShading: true
      });
      const windowMaterial = new THREE.MeshPhongMaterial({
        color: 0x2266aa,
        opacity: 0.7,
        transparent: true
      });
      const centroidMaterial = new THREE.MeshPhongMaterial({
        color: 0xff0000
      });
    
      function createWing() {
        const wing = new THREE.Group();
        const mainGeometry = new THREE.BoxGeometry(23,110,55);
        const mainBlock = new THREE.Mesh(mainGeometry, buildingMaterial);
        mainBlock.position.z = 27.5;
        wing.add(mainBlock);
        const windowRows = 35;
        const windowCols = 8;
        const windowGeometry = new THREE.BoxGeometry(0.5,2,4);
        for(let row=0; row<windowRows; row++){
          for(let col=0; col<windowCols; col++){
            const win = new THREE.Mesh(windowGeometry, windowMaterial);
            win.position.set(11.6, -50+row*3, 7.5+col*6);
            wing.add(win);
            const backWin = win.clone();
            backWin.position.set(-11.6, -50+row*3, 7.5+col*6);
            wing.add(backWin);
          }
        }
        const roofGeometry = new THREE.BoxGeometry(23,10,20);
        const roofStructure = new THREE.Mesh(roofGeometry, buildingMaterial);
        roofStructure.position.y = 60;
        roofStructure.position.z = 27.5;
        wing.add(roofStructure);
        return wing;
      }
    
      function createCentroidMarker() {
        const geometry = new THREE.SphereGeometry(2,32,32);
        const sphere = new THREE.Mesh(geometry, centroidMaterial);
        sphere.position.y = 55;
        return sphere;
      }
    
      function createBuilding() {
        const building = new THREE.Group();
        const angles = [0, 120, 240];
        for(let i=0; i<3; i++){
          const wing = createWing();
          const angle = angles[i]*Math.PI/180;
          wing.rotation.y = -angle;
          building.add(wing);
        }
        const centroidMarker = createCentroidMarker();
        building.add(centroidMarker);
        return building;
      }
    
      const building = createBuilding();
      building.children.forEach(wing=>{
        wing.children.forEach(child=>{
          if(child instanceof THREE.Mesh){
            const edges = new THREE.EdgesGeometry(child.geometry);
            const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
            child.add(outline);
          }
        });
      });
      building.children.forEach(child=>{
        if(child instanceof THREE.Mesh && child.material.color.getHex()===0xff0000){
          const edges = new THREE.EdgesGeometry(child.geometry);
          const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
          child.add(outline);
        }
      });
      trident.add(building);
      trident.position.set(-150,55,-10);
      return trident;
    }
    
    /*****************
     * Utility & Sync Functions
     *****************/
    
    // The syncAltitude function (used by section 1, 2 and 3) sets the drone’s altitude and updates all related displays.

function syncAltitude(newAltitude) {
  // Clamp altitude between 0 and 500
  newAltitude = Math.max(0, Math.min(500, newAltitude));
  drone.position.y = newAltitude;

  // Panel 1 controls
  const altSlider = document.getElementById('droneAltitudeSlider');
  if (altSlider) {
    altSlider.value = newAltitude;
    const altNumberInput = document.getElementById('droneAltitudeValue');
    if (altNumberInput) altNumberInput.value = newAltitude.toFixed(1);
  }
  document.getElementById('altitudeValue').textContent = newAltitude.toFixed(1);

  // Panel 2 controls (but DO NOT trigger calculations!)
  const calcAltSlider = document.getElementById('calc1Altitude');
  const calcAltNumber = document.getElementById('calc1AltitudeValue');
  if (calcAltSlider) calcAltSlider.value = newAltitude;
  if (calcAltNumber) calcAltNumber.value = newAltitude.toFixed(1);

  // Update visuals (Panel 1)
  updateFOV();
  updateCamera();
  // No updateCalc1AOV here!
}
    
    // This function updates the right panel (Section 2) displays.
    function updateRightPanelSync(horizontalAOV, verticalAOV, diagonalAOV, width, altitude) {
      document.getElementById('calc1HorizontalAOV').textContent = horizontalAOV.toFixed(1);
      document.getElementById('calc1VerticalAOV').textContent = verticalAOV.toFixed(1);
      document.getElementById('calc1DiagonalAOV').textContent = diagonalAOV.toFixed(1);
    }
    
   
    // Modified updateRequiredAltitude:
    // It calculates the required altitude from Section 3 inputs and then updates Section 1 and Section 2.

 
    // updateCalc1AOV updates the calculations in Section 2 using its own inputs.
function updateCalc1AOV() {
  // Get values from Section 2 inputs.
  const altitude = parseFloat(document.getElementById('calc1Altitude').value);
  const fovWidth = parseFloat(document.getElementById('calc1FOVWidth').value);

  // Synchronize FOV width inputs.
  syncFOVWidth(fovWidth);

  // Reflect the changes in Section 2 number inputs.
  document.getElementById('calc1AltitudeValue').value = altitude.toFixed(1);

  // DO NOT call syncAltitude() here! Only update Panel 1's controls if you really want to.
  // Instead, update Panel 1's altitude controls directly (optional):
  document.getElementById('droneAltitudeSlider').value = altitude;
  document.getElementById('droneAltitudeValue').value = altitude.toFixed(1);
  document.getElementById('altitudeValue').textContent = altitude.toFixed(1);
  drone.position.y = altitude;

  // Update Section 1 FOV Width display.
  document.getElementById('widthValue').textContent = fovWidth.toFixed(1);

  const aspectRatio = parseFloat(
    document.querySelector('#controls .aspectRatioBtn.active').getAttribute('data-ratio')
  );

  // Calculate horizontal, vertical and diagonal AOV using current altitude and fovWidth.
  let horizontalAOV = 0, verticalAOV = 0, diagonalAOV = 0;
  if (altitude > 0 && fovWidth > 0) {
    horizontalAOV = THREE.MathUtils.radToDeg(2 * Math.atan(fovWidth / (2 * altitude)));
    verticalAOV   = THREE.MathUtils.radToDeg(2 * Math.atan(Math.tan(THREE.MathUtils.degToRad(horizontalAOV)/2) / aspectRatio));
    const hTan = Math.tan(THREE.MathUtils.degToRad(horizontalAOV)/2);
    const vTan = Math.tan(THREE.MathUtils.degToRad(verticalAOV)/2);
    diagonalAOV   = THREE.MathUtils.radToDeg(2 * Math.atan(Math.sqrt(hTan * hTan + vTan * vTan)));
  }

  // Update Section 2 displays.
  document.getElementById('calc1HorizontalAOV').textContent = horizontalAOV.toFixed(1);
  document.getElementById('calc1VerticalAOV').textContent = verticalAOV.toFixed(1);
  document.getElementById('calc1DiagonalAOV').textContent = diagonalAOV.toFixed(1);

  // Synchronize Section 1 horizontal AOV slider and input.
  document.getElementById('aov').value = horizontalAOV.toFixed(1);
  document.getElementById('aovValue').value = horizontalAOV.toFixed(1);

  // Recalculate vertical and diagonal AOV for Section 1 FOV drawing.
  const currentHorizontalAOV = horizontalAOV;
  const currentVerticalAOV = THREE.MathUtils.radToDeg(2 * Math.atan(Math.tan(THREE.MathUtils.degToRad(currentHorizontalAOV)/2) / aspectRatio));
  const currentHorTan = Math.tan(THREE.MathUtils.degToRad(currentHorizontalAOV)/2);
  const currentVertTan = Math.tan(THREE.MathUtils.degToRad(currentVerticalAOV)/2);
  const currentDiagonalAOV = THREE.MathUtils.radToDeg(2 * Math.atan(Math.sqrt(currentHorTan * currentHorTan + currentVertTan * currentVertTan)));

  document.getElementById('vaovValue').textContent = currentVerticalAOV.toFixed(1);
  document.getElementById('daovValue').textContent = currentDiagonalAOV.toFixed(1);

  // Update the FOV drawing.
  updateFOV();
  updateAltitudeAreaCurve();
}
    
    document.getElementById('calc1FOVWidth').addEventListener('input', function() {
      const newWidth = parseFloat(this.value);
      syncFOVWidth(newWidth);
      updateCalc1AOV();
    });
    document.getElementById('calc1Altitude').addEventListener('input', updateCalc1AOV);
    
    /*****************
     * Initialization and Event Listeners
     *****************/
    
    function initAspectRatioButtons() {
      const aspectButtonsControls = document.querySelectorAll('#controls .aspectRatioBtn');
      const aspectButtonsAdditional = document.querySelectorAll('#additionalControls .aspectRatioBtn');
      const allAspectButtons = [...aspectButtonsControls, ...aspectButtonsAdditional];
      allAspectButtons.forEach(button => {


button.addEventListener('click', function() {
  const aspectRatio = parseFloat(this.getAttribute('data-ratio'));
  currentMaxDiagonalAOV = getMaxDiagonalAOV(aspectRatio);
  allAspectButtons.forEach(btn => btn.classList.remove('active'));
  const activeButtons = allAspectButtons.filter(btn => parseFloat(btn.getAttribute('data-ratio')) === aspectRatio);
  activeButtons.forEach(btn => btn.classList.add('active'));
  
  // Only update Section 1 values at the current altitude/AOV.
  updateFOV();          // This updates Panel 1 at the current altitude.
  updateAltitudeAreaCurve();

  // Do NOT call updateCalc1AOV() here. Only call it when user changes Section 2.
});

      });
    }
    
    function init() {
      initAspectRatioButtons();
      document.querySelector('#controls .aspectRatioBtn[data-ratio="1.5"]').click();
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setClearColor(0x000000, 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
    
  const gridHelper = new THREE.GridHelper(5000, 200);
  gridHelper.material.opacity = 1;
  gridHelper.material.transparent = false;
  scene.add(gridHelper);
    
      const axesLength = 200;
      const axesGeometry = new THREE.BufferGeometry();
      const vertices = new Float32Array([
        -axesLength, 0, 0,
         axesLength, 0, 0,
         0, 0, -axesLength,
         0, 0, axesLength
      ]);
      axesGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      const axesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
      const axes = new THREE.LineSegments(axesGeometry, axesMaterial);
      scene.add(axes);
    
      const labelDirections = [
        { text: "REAR", position: new THREE.Vector3(0, 0, axesLength + 5) },
        { text: "FRONT", position: new THREE.Vector3(0, 0, -axesLength - 5) },
        { text: "LEFT", position: new THREE.Vector3(-axesLength - 5, 0, 0) },
        { text: "RIGHT", position: new THREE.Vector3(axesLength + 5, 0, 0) }
      ];
      labelDirections.forEach(label => {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.font = 'bold 72px Arial';
        context.fillStyle = 'white';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(label.text, 128, 128);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(label.position);
        sprite.scale.set(30, 30, 1);
        scene.add(sprite);
      });
    
      const droneGeometry = new THREE.BoxGeometry(4, 1, 4);
      const droneMaterial = new THREE.MeshBasicMaterial({ color: 0x87CEFA, transparent: true, opacity: 0.5 });
      drone = new THREE.Mesh(droneGeometry, droneMaterial);
      drone.position.y = 0;
      scene.add(drone);
      const edges = new THREE.EdgesGeometry(droneGeometry);
      const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
      const edgeLines = new THREE.LineSegments(edges, edgesMaterial);
      drone.add(edgeLines);
    
      const propellerPositions = [
        { x: 2.5, y: 0.5, z: 2.5, color: 0x00ff00, clockwise: false },
        { x: -2.5, y: 0.5, z: 2.5, color: 0x00ff00, clockwise: true },
        { x: 2.5, y: 0.5, z: -2.5, color: 0xff0000, clockwise: true },
        { x: -2.5, y: 0.5, z: -2.5, color: 0xff0000, clockwise: false }
      ];
      propellerPositions.forEach(pos => {
        const propeller = createPropeller(pos.color);
        propeller.position.set(pos.x, pos.y, pos.z);
        propeller.userData.clockwise = pos.clockwise;
        drone.add(propeller);
        propellers.push(propeller);
        const light = createBlinkingLight();
        light.position.set(pos.x, pos.y + 0.2, pos.z);
        drone.add(light);
        blinkingLights.push(light);
      });
    
      const fovGeometry = new THREE.PlaneGeometry(1, 1);
const fovMaterial = new THREE.MeshBasicMaterial({ color: 0x2196F3, transparent: true, opacity: 0.22, side: THREE.DoubleSide,depthWrite: false, depthTest: false 
 });

fovArea = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), fovMaterial);
fovArea.rotation.x = -Math.PI/2;
scene.add(fovArea);

const outlineGeom = new THREE.EdgesGeometry(new THREE.PlaneGeometry(1,1));
const outlineMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
const outline = new THREE.LineSegments(outlineGeom, outlineMat);
fovArea.add(outline);
    
      verticalLine = new THREE.Group();
      fovLines = new THREE.Group();
      diagonals = new THREE.Group();
      scene.add(verticalLine);
      scene.add(fovLines);
      scene.add(diagonals);
    
      updateCamera();
    
      schoolBuilding = createSchoolBuilding();
      schoolBuilding.position.set(-50, 0, -20);
      schoolBuilding.visible = false;
      scene.add(schoolBuilding);
    
      bankTower = createBankTower();
      bankTower.position.set(50, 0, 10);
      bankTower.visible = false;
      scene.add(bankTower);
    
      tridentBlocks = createTridentBlocks();
      tridentBlocks.visible = false;
      scene.add(tridentBlocks);
    
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
    
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 50, 50);
      scene.add(directionalLight);
    
      window.addEventListener('resize', onWindowResize, false);
      renderer.domElement.addEventListener('mousedown', onMouseDown, false);
      renderer.domElement.addEventListener('mousemove', onMouseMove, false);
      renderer.domElement.addEventListener('mouseup', onMouseUp, false);
      renderer.domElement.addEventListener('wheel', onWheel, false);
      renderer.domElement.addEventListener('contextmenu', e => e.preventDefault(), false);
    
      function initBuildingButtons() {
        document.getElementById('toggleSchoolBuilding').classList.toggle('active', schoolBuilding.visible);
        document.getElementById('toggleBankTower').classList.toggle('active', bankTower.visible);
        document.getElementById('toggleTridentBlocks').classList.toggle('active', tridentBlocks.visible);
      }
      initBuildingButtons();
    
      // When the horizontal AOV slider changes
      document.getElementById('aov').addEventListener('input', updateFOV);
      
      // Drone Altitude number input event.
      document.getElementById('droneAltitudeValue').addEventListener('change', function(){
        const val = parseFloat(this.value);
        const min = 0, max = 500;
        if(val < min || val > max) {
          alert(getTranslation("Value out-of-range. Please enter a value between " + min + " and " + max + ".", "輸入數值超出範圍，請輸入介於 " + min + " 與 " + max + " 之間的值。"));
          this.value = Math.min(Math.max(val, min), max).toFixed(1);
        }
        let newAlt = parseFloat(this.value);
        document.getElementById('droneAltitudeSlider').value = newAlt;
        syncAltitude(newAlt);
      });
      
      // Horizontal AOV number input event.
      document.getElementById('aovValue').addEventListener('change', function(){
        const val = parseFloat(this.value);
        const min = 30, max = 120;
        if(val < min || val > max) {
          alert(getTranslation("Value out-of-range. Please enter a value between " + min + " and " + max + ".", "輸入數值超出範圍，請輸入介於 " + min + " 與 " + max + " 之間的值。"));
          this.value = Math.min(Math.max(val, min), max).toFixed(1);
        }
        const newAOV = parseFloat(this.value);
        document.getElementById('aov').value = newAOV;
        updateFOV();
      });
      
      // Calc1 Altitude number input event.
      document.getElementById('calc1AltitudeValue').addEventListener('change', function(){
        const val = parseFloat(this.value);
        const min = 0, max = 500;
        if(val < min || val > max){
          alert(getTranslation("Value out-of-range. Please enter a value between " + min + " and " + max + ".", "輸入數值超出範圍，請輸入介於 " + min + " 與 " + max + " 之間的值。"));
          this.value = Math.min(Math.max(val, min), max).toFixed(1);
        }
        const newAlt = parseFloat(this.value);
        document.getElementById('calc1Altitude').value = newAlt;
        updateCalc1AOV();
      });
      
      // Calc1 FOV Width number input event.
      document.getElementById('calc1FOVWidthValue').addEventListener('change', function(){
        const val = parseFloat(this.value);
        const min = 0, max = 1732;
        if(val < min || val > max){
          alert(getTranslation("Value out-of-range. Please enter a value between " + min + " and " + max + ".", "輸入數值超出範圍，請輸入介於 " + min + " 與 " + max + " 之間的值。"));
          this.value = Math.min(Math.max(val, min), max).toFixed(1);
        }
        const newWidth = parseFloat(this.value);
        document.getElementById('calc1FOVWidth').value = newWidth;
        syncFOVWidth(newWidth);
        updateCalc1AOV();
      });
      
      
      // Also update altitude slider from Section 1 to keep Section 2 in sync.
      if(document.getElementById('droneAltitudeSlider')) {
        document.getElementById('droneAltitudeSlider').addEventListener('input', function() {
          const newAlt = parseFloat(this.value);
          syncAltitude(newAlt);
          document.getElementById('calc1Altitude').value = newAlt;
          document.getElementById('calc1AltitudeValue').value = newAlt.toFixed(1);
          updateCalc1AOV();
        });
      }
      
      document.querySelector('.aspectRatioBtn[data-ratio="1.5"]').click();
    
      updateFOV();
    }
    
    function toggleBuilding(buildingType) {
      let building, button;
      switch(buildingType) {
        case 'school':
          building = schoolBuilding;
          button = document.getElementById('toggleSchoolBuilding');
          break;
        case 'bank':
          building = bankTower;
          button = document.getElementById('toggleBankTower');
          break;
        case 'trident':
          building = tridentBlocks;
          button = document.getElementById('toggleTridentBlocks');
          break;
      }
      if(building && button) {
        button.classList.toggle('active');
        building.visible = button.classList.contains('active');
      }
    }
    
    document.getElementById('toggleSchoolBuilding').addEventListener('click', () => toggleBuilding('school'));
    document.getElementById('toggleBankTower').addEventListener('click', () => toggleBuilding('bank'));
    document.getElementById('toggleTridentBlocks').addEventListener('click', () => toggleBuilding('trident'));
    
function updateCamera() {
  // Always use user zoom (cameraDistance), regardless of drone altitude
  const minY = 0;
  const maxY = drone.position.y;
  const lookY = (minY + maxY) / 2;

  // Camera direction: maintain angle and tilt, use cameraDistance
  const x = Math.cos(cameraAngle) * Math.cos(cameraTilt) * cameraDistance;
  const z = Math.sin(cameraAngle) * Math.cos(cameraTilt) * cameraDistance;
  const y = lookY + cameraDistance * Math.sin(cameraTilt);

  camera.position.set(
    drone.position.x + x,
    y,
    drone.position.z + z
  );

  camera.lookAt(
    drone.position.x,
    lookY,
    drone.position.z
  );
}
    
    function updateBlinkingLights() {
      const currentTime = Date.now();
      if(currentTime - lastBlinkTime > BLINK_INTERVAL) {
        blinkState = !blinkState;
        blinkingLights.forEach(light => {
          light.material.opacity = blinkState ? 1 : 0.3;
        });
        lastBlinkTime = currentTime;
      }
    }
    
    function onWheel(event) {
      event.preventDefault();
      cameraDistance += event.deltaY * 0.1;
      cameraDistance = Math.max(10, Math.min(1000, cameraDistance));
      updateCamera();
    }
    
    function onMouseDown(event) {
      isDragging = true;
      dragStartPosition.x = event.clientX;
      dragStartPosition.y = event.clientY;
      const button = event.button;
      if(button === 0){
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersectsSchool = schoolBuilding.visible ? raycaster.intersectObject(schoolBuilding, true) : [];
        const intersectsBank = bankTower.visible ? raycaster.intersectObject(bankTower, true) : [];
        const intersectsTrident = tridentBlocks.visible ? raycaster.intersectObject(tridentBlocks, true) : [];
        if(intersectsSchool.length > 0){
          draggedBuilding = 'school';
          buildingDragStartX = schoolBuilding.position.x;
          mouseStartX = event.clientX;
        } else if(intersectsBank.length > 0){
          draggedBuilding = 'bank';
          buildingDragStartX = bankTower.position.x;
          mouseStartX = event.clientX;
        } else if(intersectsTrident.length > 0){
          draggedBuilding = 'trident';
          buildingDragStartX = tridentBlocks.position.x;
          mouseStartX = event.clientX;
        } else {
          draggedBuilding = null;
        }
      }
    }
    
function onMouseMove(event) {
  if(isDragging){
    const deltaX = event.clientX - dragStartPosition.x;
    const deltaY = event.clientY - dragStartPosition.y;
    if(draggedBuilding){
      const movementX = (event.clientX - mouseStartX) * 0.5;
      if(draggedBuilding === 'school'){
        schoolBuilding.position.x = buildingDragStartX + movementX;
      } else if(draggedBuilding === 'bank'){
        bankTower.position.x = buildingDragStartX + movementX;
      } else if(draggedBuilding === 'trident'){
        tridentBlocks.position.x = buildingDragStartX + movementX;
      }
    } else {
      if(event.buttons & 1){
        let newAltitude = parseFloat(drone.position.y) - deltaY * 0.5;
        newAltitude = Math.max(0, Math.min(500, newAltitude)); // Clamp
        syncAltitude(newAltitude);
	updateAltitudeAreaCurve();
      } else if(event.buttons & 2){
        if(event.shiftKey){
          drone.position.x += deltaX * 0.5;
          drone.position.z += deltaY * 0.5;
          updateFOV();
        } else {
          cameraAngle -= deltaX * 0.01;
          cameraTilt += deltaY * 0.01;
          cameraTilt = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraTilt));
          updateCamera();
        }
      }
    }
    dragStartPosition.x = event.clientX;
    dragStartPosition.y = event.clientY;
  }
}
    
    function onMouseUp(event) {
      isDragging = false;
      draggedBuilding = null;
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function updateFOV() {
      const altitude = drone.position.y;
      const aov = parseFloat(document.getElementById('aov').value);
      const aspectRatio = parseFloat(document.querySelector('#controls .aspectRatioBtn.active').getAttribute('data-ratio'));
      let width = 0, height = 0, verticalAOV = 0, diagonalAOV = 0;
      if(altitude > 0){
        width = 2 * altitude * Math.tan(THREE.MathUtils.degToRad(aov) / 2);
        height = width / aspectRatio;
        verticalAOV = 2 * THREE.MathUtils.radToDeg(Math.atan(Math.tan(THREE.MathUtils.degToRad(aov)/2)/aspectRatio));
        const horizontalTan = Math.tan(THREE.MathUtils.degToRad(aov)/2);
        const verticalTan = Math.tan(THREE.MathUtils.degToRad(verticalAOV)/2);
        diagonalAOV = 2 * THREE.MathUtils.radToDeg(Math.atan(Math.sqrt(horizontalTan*horizontalTan + verticalTan*verticalTan)));
      }
      document.getElementById('widthValue').textContent = width.toFixed(1);
syncFOVWidth(width);
      document.getElementById('heightValue').textContent = height.toFixed(1);
      const area = width * height;
      document.getElementById('areaValue').textContent = area.toFixed(1);
      
      fovArea.scale.set(width, height, 1);
fovArea.position.copy(drone.position);
fovArea.position.y = 0.05;  // 5cm above ground

      
      verticalLine.clear();
      const centerPoint = new THREE.Vector3(drone.position.x, 0, drone.position.z);
      const verticalLineGeometry = createDottedLine([drone.position.clone(), centerPoint], 0xFFFFFF);
      verticalLine.add(verticalLineGeometry);
      
      fovLines.clear();
      const halfWidth = width / 2;
      const halfHeight = height / 2;
      const corners = [
        new THREE.Vector3(drone.position.x + halfWidth, 0, drone.position.z + halfHeight),
        new THREE.Vector3(drone.position.x - halfWidth, 0, drone.position.z + halfHeight),
        new THREE.Vector3(drone.position.x - halfWidth, 0, drone.position.z - halfHeight),
        new THREE.Vector3(drone.position.x + halfWidth, 0, drone.position.z - halfHeight)
      ];
      corners.forEach(corner=>{
        const line = createDottedLine([drone.position.clone(), corner], 0xFFFFFF);
        fovLines.add(line);
      });
      
      diagonals.clear();
      if(altitude > 0){
        const diagonalAC = createDottedLine([corners[0], corners[2]], 0xFFFF00);
        const diagonalBD = createDottedLine([corners[1], corners[3]], 0xFFFF00);
        diagonals.add(diagonalAC);
        diagonals.add(diagonalBD);
      }
      
      cornerLabels.forEach(label => scene.remove(label));
      cornerLabels = [];
      const lbl = ['A', 'B', 'C', 'D'];
      corners.forEach((corner, index)=>{
        const label = createCornerLabel(lbl[index], corner);
        scene.add(label);
        cornerLabels.push(label);
      });
      


dimensionLabels.forEach(label => scene.remove(label));
dimensionLabels = [];
if (altitude > 0) {
  // Compute common label scale
  let labelScale = Math.max(2, Math.min(Math.max(width, height) * 1, 220));

  // Label for AB (Width)
  if (showFOVWidthLabel) {
    const abMid = new THREE.Vector3(
      (corners[0].x + corners[1].x) / 2,
      0,
      (corners[0].z + corners[1].z) / 2
    );
    const abVec = new THREE.Vector3(
      corners[1].x - corners[0].x, 0, corners[1].z - corners[0].z
    ).normalize();
    const abPerp = new THREE.Vector3(-abVec.z, 0, abVec.x);
    const abOffset = Math.max(width, height) / 15;
    const abPos = abMid.clone().add(abPerp.clone().multiplyScalar(abOffset));
    const abLength = Math.sqrt(
      Math.pow(corners[1].x - corners[0].x, 2) +
      Math.pow(corners[1].z - corners[0].z, 2)
    );
    const abLabel = createDimensionLabel(
      `FOV Width: ${abLength.toFixed(1)}m`, abPos, labelScale
    );
    scene.add(abLabel);
    dimensionLabels.push(abLabel);
  }

  // Label for BC (Height)
  if (showFOVHeightLabel) {
    const bcMid = new THREE.Vector3(
      (corners[1].x + corners[2].x) / 2,
      0,
      (corners[1].z + corners[2].z) / 2
    );
    const bcVec = new THREE.Vector3(
      corners[2].x - corners[1].x, 0, corners[2].z - corners[1].z
    ).normalize();
    const bcPerp = new THREE.Vector3(-bcVec.z, 0, bcVec.x);
    const bcOffset = Math.max(width, height) / 15;
    const bcPos = bcMid.clone().add(bcPerp.clone().multiplyScalar(bcOffset));
    const bcLength = Math.sqrt(
      Math.pow(corners[2].x - corners[1].x, 2) +
      Math.pow(corners[2].z - corners[1].z, 2)
    );
    const bcLabel = createDimensionLabel(
      `FOV Height: ${bcLength.toFixed(1)}m`, bcPos, labelScale
    );
    scene.add(bcLabel);
    dimensionLabels.push(bcLabel);
  }
}
      


      if(centerLabel) scene.remove(centerLabel);
      const centerPosition = new THREE.Vector3(drone.position.x, 0, drone.position.z);
      centerLabel = createCenterLabel('O', centerPosition);
      scene.add(centerLabel);
      
      document.getElementById('aovValue').value = aov.toFixed(1);
      document.getElementById('vaovValue').textContent = altitude > 0 ? verticalAOV.toFixed(1) : '0.0';
      document.getElementById('daovValue').textContent = diagonalAOV.toFixed(1);
      
      updateRightPanelSync(aov, verticalAOV, diagonalAOV, width, altitude);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      propellers.forEach(propeller => {
        propeller.rotation.y += propeller.userData.clockwise ? 0.3 : -0.3;
      });
      updateBlinkingLights();
      renderer.render(scene, camera);
    }
    
    init();

// Add the event listeners for the "Show" buttons for Panel 1 FOV Width and Height
document.getElementById('showFOVWidthBtn').addEventListener('click', function() {
  showFOVWidthLabel = !showFOVWidthLabel;
  this.textContent = showFOVWidthLabel ? 'Hide' : 'Show';
  updateFOV();
});
document.getElementById('showFOVHeightBtn').addEventListener('click', function() {
  showFOVHeightLabel = !showFOVHeightLabel;
  this.textContent = showFOVHeightLabel ? 'Hide' : 'Show';
  updateFOV();
});

    animate();
    updateAltitudeAreaCurve();
    
    let isTouchMoving = false;
    document.body.addEventListener('touchstart', function(event) {
      isTouchMoving = false;
    }, { passive: false });
    document.body.addEventListener('touchmove', function(event) {
      isTouchMoving = true;
    }, { passive: false });
    document.body.addEventListener('touchend', function(event) {
      if (!isTouchMoving) event.preventDefault();
    }, { passive: false });
    
    function getTouchPos(touchEvent) {
      const rect = renderer.domElement.getBoundingClientRect();
      return {
        x: ((touchEvent.touches[0].clientX - rect.left) / rect.width) * 2 - 1,
        y: -((touchEvent.touches[0].clientY - rect.top) / rect.height) * 2 + 1
      };
    }
    

    
    document.querySelectorAll('button').forEach(button => {
      button.addEventListener('touchstart', function(e) {
        e.preventDefault();
        this.click();
      });
    });
    
   
    // View Control Functions
    function tiltUp() {
      cameraTilt = Math.min(cameraTilt + 0.1, Math.PI / 2 - 0.1);
      updateCamera();
    }
    
    function tiltDown() {
      cameraTilt = Math.max(cameraTilt - 0.1, -Math.PI / 2 + 0.1);
      updateCamera();
    }
    
    function rotateLeft() {
      cameraAngle += 0.1;
      updateCamera();
    }
    
    function rotateRight() {
      cameraAngle -= 0.1;
      updateCamera();
    }
    
    function zoomIn() {
      cameraDistance = Math.max(cameraDistance - 2, 10);
      updateCamera();
    }
    
    function zoomOut() {
      cameraDistance = Math.min(cameraDistance + 2, 1000);
      updateCamera();
    }
    
    function resetView() {
      cameraAngle = Math.PI / 2;
      cameraTilt = 0.5;
      cameraDistance = 100;
      drone.position.set(0, 0, 0);
      updateFOV();
      updateCamera();
      document.getElementById('aov').value = 70;
      document.getElementById('aov').dispatchEvent(new Event('input'));
    }
    
    function moveUp() {
      const newAltitude = Math.min(500, drone.position.y + 0.1);
      syncAltitude(newAltitude);
    }
    
    function moveDown() {
      const newAltitude = Math.max(0, drone.position.y - 0.1);
      syncAltitude(newAltitude);
    }
    
    function moveForward() {
      const moveDistance = 1;
      drone.position.z -= moveDistance;
      updateFOV();
      updateCamera();
    }
    
    function moveBackward() {
      const moveDistance = 1;
      drone.position.z += moveDistance;
      updateFOV();
      updateCamera();
    }
    
    document.getElementById('tiltUp').addEventListener('click', tiltUp);
    document.getElementById('tiltDown').addEventListener('click', tiltDown);
    document.getElementById('rotateLeft').addEventListener('click', rotateLeft);
    document.getElementById('rotateRight').addEventListener('click', rotateRight);
    document.getElementById('zoomIn').addEventListener('click', zoomIn);
    document.getElementById('zoomOut').addEventListener('click', zoomOut);
    document.getElementById('homeView').addEventListener('click', resetView);
    document.getElementById('moveUp').addEventListener('click', moveUp);
    document.getElementById('moveDown').addEventListener('click', moveDown);
    document.getElementById('moveForward').addEventListener('click', moveForward);
    document.getElementById('moveBackward').addEventListener('click', moveBackward);
    
    // Language Switching
const elements = document.querySelectorAll('[data-i18n], [data-i18n-zh]');

languageToggle.addEventListener('click', () => {
  if (languageToggle.textContent === '繁體中文') {
    languageToggle.textContent = 'English';
    elements.forEach(element => {
      if (element.hasAttribute('data-i18n-zh')) {
        element.textContent = element.getAttribute('data-i18n-zh');
      }
    });
  } else {
    languageToggle.textContent = '繁體中文';
    elements.forEach(element => {
      if (element.hasAttribute('data-i18n')) {
        element.textContent = element.getAttribute('data-i18n');
      }
    });
  }
  updateTutorialTranslation();
  updateHintModalsLanguage();
});

// If you have a function for tutorial step translation, also update it:
function updateLanguageText() {
  elements.forEach(element => {
    if (languageToggle.textContent === '繁體中文') {
      if (element.hasAttribute('data-i18n')) {
        element.textContent = element.getAttribute('data-i18n');
      }
    } else {
      if (element.hasAttribute('data-i18n-zh')) {
        element.textContent = element.getAttribute('data-i18n-zh');
      }
    }
  });
}


    function getTranslation(en, zh) {
      return languageToggle.textContent === '繁體中文' ? en : zh;
    }
    
    /*****************
     * Tutorial Functionality & Highlighting
     *****************/
    const startTutorialButton = document.getElementById('startTutorial');
    const tutorialOverlay = document.getElementById('tutorialOverlay');
    const closeTutorialButton = document.querySelector('.closeTutorial');
    const steps = document.querySelectorAll('#tutorialContent .step');
    const nextStepButton = document.getElementById('nextStep');
    const prevStepButton = document.getElementById('prevStep');
    let currentStep = 0;
    const highlightBox = document.getElementById('highlightBox');
    
    startTutorialButton.addEventListener('click', () => {
      currentStep = 0;
      showStep(currentStep);
      tutorialOverlay.style.display = 'flex';
      highlightCurrentStep();
    });
    
    closeTutorialButton.addEventListener('click', () => {
      tutorialOverlay.style.display = 'none';
      removeHighlight();
    });
    
    nextStepButton.addEventListener('click', () => {
      if (currentStep < steps.length - 1) {
        currentStep++;
        showStep(currentStep);
        highlightCurrentStep();
      } else {
        tutorialOverlay.style.display = 'none';
        removeHighlight();
      }
    });
    
    prevStepButton.addEventListener('click', () => {
      if (currentStep > 0) {
        currentStep--;
        showStep(currentStep);
        highlightCurrentStep();
      }
    });
    
    function showStep(index) {
      steps.forEach((step, i) => {
        step.classList.toggle('active', i === index);
      });
      prevStepButton.style.display = index === 0 ? 'none' : 'inline-block';
      if (index === steps.length - 1) {
        nextStepButton.setAttribute('data-i18n', 'Finish');
        nextStepButton.setAttribute('data-i18n-zh', '完成');
      } else {
        nextStepButton.setAttribute('data-i18n', 'Next');
        nextStepButton.setAttribute('data-i18n-zh', '下一頁');
      }
      if (languageToggle.textContent === '繁體中文') {
        nextStepButton.textContent = nextStepButton.getAttribute('data-i18n');
      } else {
        nextStepButton.textContent = nextStepButton.getAttribute('data-i18n-zh');
      }
    }
    
    function updateLanguageText() {
      elements.forEach(element => {
        if (languageToggle.textContent === '繁體中文') {
          if (element.hasAttribute('data-i18n')) {
            element.textContent = element.getAttribute('data-i18n');
          }
        } else {
          if (element.hasAttribute('data-i18n-zh')) {
            element.textContent = element.getAttribute('data-i18n-zh');
          }
        }
      });
    }
    
    function highlightCurrentStep() {
      const targetSelector = getTargetSelector(currentStep);
      if (targetSelector) {
        const targetElements = document.querySelectorAll(targetSelector);
        if (targetElements.length > 0) {
          let minLeft = Infinity, minTop = Infinity, maxRight = -Infinity, maxBottom = -Infinity;
          targetElements.forEach(elem => {
            const rect = elem.getBoundingClientRect();
            if (rect.left < minLeft) minLeft = rect.left;
            if (rect.top < minTop) minTop = rect.top;
            if (rect.right > maxRight) maxRight = rect.right;
            if (rect.bottom > maxBottom) maxBottom = rect.bottom;
          });
          const padding = 10;
          const width = maxRight - minLeft + padding * 2;
          const height = maxBottom - minTop + padding * 2;
          const left = minLeft - padding;
          const top = minTop - padding;
          highlightBox.style.display = 'block';
          highlightBox.style.width = `${width}px`;
          highlightBox.style.height = `${height}px`;
          highlightBox.style.left = `${left}px`;
          highlightBox.style.top = `${top}px`;
          tutorialOverlay.classList.add('active');
        } else {
          removeHighlight();
        }
      } else {
        removeHighlight();
      }
    }
    
    window.addEventListener('resize', () => {
      if (tutorialOverlay.style.display === 'flex') {
        highlightCurrentStep();
      }
    });
    
    function removeHighlight() {
      highlightBox.style.display = 'none';
      tutorialOverlay.classList.remove('active');
    }
    
    function getTargetSelector(currentStep) {
      switch (currentStep) {
        case 0: return null;
        case 1: return '#controls .aspectRatioButtons';
        case 2: return '#aov';
        case 3: return '#verticalDiagonalAOV';
        case 4: return '#altitudeFOVMeasurements';
        case 5: return '.toggle-building';
        case 6: return '#additionalControls';
        case 7: return '#viewControls';
        case 8: return '#languageToggle';
        case 9: return null;
        default: return null;
      }
    }
    
    function updateTutorialTranslation() {
      updateLanguageText();
      highlightCurrentStep();
    }


function updateAltitudeAreaCurve() {
  const canvas = document.getElementById('altitudeAreaCurve');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;

  // Use Panel 1 controls as the source of truth (so graph matches Panel 1)
  const aspectBtn = document.querySelector('#controls .aspectRatioBtn.active');
  const aspectRatio = aspectBtn ? parseFloat(aspectBtn.getAttribute('data-ratio')) : 1.5;
  const aovInput = document.getElementById('aov');
  const horizontalAOV = aovInput ? parseFloat(aovInput.value) : 70;

  // Calculate diagonal AOV to match Panel 1's method
  let verticalAOV = 0, diagonalAOV = 0;
  if (horizontalAOV > 0 && aspectRatio > 0) {
    verticalAOV = 2 * (180/Math.PI) * Math.atan(Math.tan((horizontalAOV*Math.PI/180)/2) / aspectRatio);
    const hTan = Math.tan((horizontalAOV*Math.PI/180)/2);
    const vTan = Math.tan((verticalAOV*Math.PI/180)/2);
    diagonalAOV = 2 * (180/Math.PI) * Math.atan(Math.sqrt(hTan * hTan + vTan * vTan));
  }

  document.getElementById('curveParams').textContent =
    `Diagonal AOV: ${diagonalAOV.toFixed(1)}°   Ratio: ${aspectRatio.toFixed(3)}`;

  const minAlt = 1, maxAlt = 500, steps = 100;
  let data = [], maxArea = 1;
  for (let i = 0; i <= steps; ++i) {
    const alt = minAlt + (maxAlt - minAlt) * i / steps;
    const widthAtAlt = 2 * alt * Math.tan((horizontalAOV * Math.PI/180)/2);
    const heightAtAlt = widthAtAlt / aspectRatio;
    const areaAtAlt = widthAtAlt * heightAtAlt;
    data.push({alt, area: areaAtAlt});
    if (areaAtAlt > maxArea) maxArea = areaAtAlt;
  }

  ctx.clearRect(0,0,width,height);

  const plotL = 38, plotT = 16, plotR = 14, plotB = 28;
  const plotW = width - plotL - plotR, plotH = height - plotT - plotB;

  // Axes
  ctx.save();
  ctx.strokeStyle = "#bbb"; ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(plotL, height - plotB); ctx.lineTo(width - plotR, height - plotB);
  ctx.moveTo(plotL, height - plotB); ctx.lineTo(plotL, plotT);
  ctx.stroke();

  // Y ticks and numbers
  ctx.font = "8px Arial";
  ctx.textAlign="right";
  ctx.fillStyle="#aaa";
  for (let i=0;i<=4;i++) {
    let val = maxArea*i/4;
    let y = height - plotB - plotH*(i/4);
    ctx.fillStyle="#bbb";
    ctx.fillRect(plotL-4,y-1,3,2);
    ctx.fillStyle="#aaa";
    ctx.fillText((val<10?val.toFixed(1):Math.round(val)), plotL-7, y+3);
  }

  // X ticks and numbers
  ctx.textAlign="center"; ctx.fillStyle="#bbb";
  for (let i=0;i<=5;i++) {
    let val = minAlt + (maxAlt-minAlt)*i/5;
    let x = plotL + plotW*(i/5);
    ctx.fillRect(x-1, height-plotB, 2, 5);
    ctx.fillStyle="#aaa";
    ctx.fillText(Math.round(val), x, height-plotB+17);
  }

  // Curve
  ctx.beginPath();
  data.forEach((pt,i) => {
    let x = plotL + plotW*(pt.alt-minAlt)/(maxAlt-minAlt);
    let y = height - plotB - plotH*(pt.area/maxArea);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.strokeStyle = "#FFD700";
  ctx.lineWidth = 2.1;
  ctx.shadowColor = "#664";
  ctx.shadowBlur = 2;
  ctx.stroke();
  ctx.shadowBlur = 0;

  // --- Dot and label: always matches Panel 1 ---
  const altInput = document.getElementById('droneAltitudeSlider');
  const curAlt = altInput ? parseFloat(altInput.value) : 0;
  let areaValuePanel1 = document.getElementById('areaValue') ? parseFloat(document.getElementById('areaValue').textContent) : null;

  let curArea = areaValuePanel1;
  if (!curArea && curAlt > 0 && horizontalAOV > 0) {
    const width = 2 * curAlt * Math.tan((horizontalAOV * Math.PI/180)/2);
    const height = width / aspectRatio;
    curArea = width * height;
  }

  if (curAlt > 0 && horizontalAOV > 0) {
    let x = plotL + plotW*(curAlt-minAlt)/(maxAlt-minAlt);
    let y = height-plotB - plotH*(curArea/maxArea);

    // Dot
    ctx.beginPath();
    ctx.arc(x,y,4,0,2*Math.PI);
    ctx.fillStyle="#FF4444";
    ctx.globalAlpha=0.93; ctx.fill();
    ctx.globalAlpha=1;

    // --- Improved label placement ---
    ctx.font = "bold 12px Arial";
    ctx.fillStyle="#FFD700";
    let label = `(${curAlt.toFixed(1)}m, ${curArea.toFixed(1)}m²)`;
    let labelWidth = ctx.measureText(label).width;
    let labelHeight = 14;

    // Try to place label right&below, left&above, right&above, left&below, in order
    let tryPositions = [
      {align:"left",  dx:10,  dy:18}, // right & below
      {align:"right", dx:-10, dy:-8}, // left & above
      {align:"left",  dx:10,  dy:-8}, // right & above
      {align:"right", dx:-10, dy:18}, // left & below
    ];
    let final = tryPositions[0];
    for(let pos of tryPositions) {
      let lx = x + pos.dx;
      let ly = y + pos.dy;
      let fits =
        lx - (pos.align==="right"?labelWidth:0) >= plotL &&
        lx + (pos.align==="left"?labelWidth:0) <= width - plotR &&
        ly-labelHeight >= plotT && ly+labelHeight <= height-plotB;
      if(fits) { final = pos; break; }
    }
    ctx.textAlign=final.align;
    ctx.fillText(label, x+final.dx, y+final.dy);
  }
  ctx.restore();
}

// --- Robust Graph Synchronization ---

function setupAltitudeAreaCurveRealtime() {
  // On relevant Panel 2 input changes, redraw
  ['calc1Altitude','calc1FOVWidth'].forEach(id=>{
    let el = document.getElementById(id);
    if(el) el.addEventListener('input', updateAltitudeAreaCurve);
  });
  // Aspect ratio buttons (Panel 2)
  document.querySelectorAll('#additionalControls .aspectRatioBtn').forEach(btn=>{
    btn.addEventListener('click', updateAltitudeAreaCurve);
  });

  // Panel 1: listen to all relevant changes
  ['droneAltitudeSlider','droneAltitudeValue','aov','aovValue'].forEach(id=>{
    let el = document.getElementById(id);
    if(el) el.addEventListener('input', updateAltitudeAreaCurve);
    if(el) el.addEventListener('change', updateAltitudeAreaCurve);
  });

  // Panel 1 aspect ratio
  document.querySelectorAll('#controls .aspectRatioBtn').forEach(btn=>{
    btn.addEventListener('click', updateAltitudeAreaCurve);
  });

  // Patch updateCalc1AOV and updateFOV to always update the graph
  if (typeof updateCalc1AOV === "function") {
    let origUpdateCalc1AOV = updateCalc1AOV;
    updateCalc1AOV = function() { origUpdateCalc1AOV(); updateAltitudeAreaCurve(); }
  }
  if (typeof updateFOV === "function") {
    let origUpdateFOV = updateFOV;
    updateFOV = function() { origUpdateFOV(); updateAltitudeAreaCurve(); }
  }

  // Patch syncAltitude (for dragging) to always update the graph
  if (typeof syncAltitude === "function") {
    let origSyncAltitude = syncAltitude;
    syncAltitude = function(newAltitude) {
      origSyncAltitude(newAltitude);
      updateAltitudeAreaCurve();
    };
  }

  // Initial draw
  setTimeout(updateAltitudeAreaCurve, 200);
}
setupAltitudeAreaCurveRealtime();

// --- TOUCH MANAGEMENT FOR IPAD/SAFARI/ANDROID --- //
let touchOp = null; // "drone", "building", "camera", "pinch"
let touchDragStart = null;
let dragObj = null;
let dragObjStart = null;
let cameraAngleStart = 0, cameraTiltStart = 0;
let cameraLastTouch = {x:0, y:0};
let pinchStartDist = 0, pinchStartCameraDistance = 0;
let lastTouchMovedObj = false;

// Helper for building list
const buildings = [
  {name: 'school', mesh: ()=>schoolBuilding},
  {name: 'bank', mesh: ()=>bankTower},
  {name: 'trident', mesh: ()=>tridentBlocks},
];

// Utility: get touch (canvas) coordinates and set raycaster
function setTouchRay(touch) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
}

renderer.domElement.style.touchAction = "none"; // Prevent all default scrolling

renderer.domElement.addEventListener("touchstart", function(e) {
  if (e.touches.length==1) {
    const touch = e.touches[0];
    setTouchRay(touch);

    // Check if touching a visible building
    let hitBuilding = null;
    let hitObj = null;

    for (let b of buildings) {
      const obj = b.mesh();
      if (obj.visible) {
        const hits = raycaster.intersectObject(obj, true);
        if (hits.length) {
          hitBuilding = b;
          hitObj = obj;
          break;
        }
      }
    }

    // Check if touching drone
    const droneHit = raycaster.intersectObject(drone, true);

    if (hitBuilding) {
      touchOp = "building";
      dragObj = hitObj;
      dragObjStart = dragObj.position.clone();
      touchDragStart = {x: touch.clientX, y: touch.clientY};
      lastTouchMovedObj = false;
    } else if (droneHit.length) {
      touchOp = "drone";
      touchDragStart = {x: touch.clientX, y: touch.clientY, altitude: drone.position.y};
    } else {
      touchOp = "camera";
      cameraLastTouch = {x: touch.clientX, y: touch.clientY};
      cameraAngleStart = cameraAngle;
      cameraTiltStart = cameraTilt;
    }
    if (e.cancelable) e.preventDefault();
  } else if (e.touches.length==2) {
    // Pinch zoom
    pinchStartDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    pinchStartCameraDistance = cameraDistance;
    touchOp = "pinch";
    if (e.cancelable) e.preventDefault();
  }
}, {passive:false});

renderer.domElement.addEventListener("touchmove", function(e) {
  if (touchOp === "building" && e.touches.length==1 && dragObj && dragObjStart) {
    const touch = e.touches[0];
    // Raycast to ground plane: find where finger points at y=0
    setTouchRay(touch);
    // Plane: y=0
    const planeY = 0;
    const planeNormal = new THREE.Vector3(0,1,0);
    const plane = new THREE.Plane(planeNormal, -planeY);
    const intersect = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, intersect);

    // At touchstart, record offset between building position and intersection
    if (!lastTouchMovedObj) {
      dragObj.userData.offset = intersect.clone().sub(dragObj.position);
      lastTouchMovedObj = true;
    }
    if (dragObj.userData.offset && intersect) {
      const newPos = intersect.clone().sub(dragObj.userData.offset);
      dragObj.position.x = newPos.x;
      updateFOV();
    }
    if (e.cancelable) e.preventDefault();
  }
  else if (touchOp === "drone" && e.touches.length==1 && touchDragStart) {
    const touch = e.touches[0];
    let dy = touchDragStart.y - touch.clientY;
    let newAltitude = touchDragStart.altitude + dy*0.5;
    newAltitude = Math.max(0, Math.min(500, newAltitude));
    syncAltitude(newAltitude);
    if (e.cancelable) e.preventDefault();
  }
  else if (touchOp === "camera" && e.touches.length==1) {
    const touch = e.touches[0];
    let dx = touch.clientX - cameraLastTouch.x;
    let dy = touch.clientY - cameraLastTouch.y;
    cameraAngle = cameraAngleStart - dx*0.012;
    cameraTilt = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, cameraTiltStart - dy*0.012));
    updateCamera();
    if (e.cancelable) e.preventDefault();
  }
  else if (touchOp === "pinch" && e.touches.length==2) {
    let dist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    let scale = dist / pinchStartDist;
    let newDist = pinchStartCameraDistance / scale;
    cameraDistance = Math.max(10, Math.min(1000, newDist));
    updateCamera();
    if (e.cancelable) e.preventDefault();
  }
}, {passive:false});

renderer.domElement.addEventListener("touchend", function(e) {
  if (e.touches.length===0) {
    touchOp = null;
    dragObj = null;
    dragObjStart = null;
    lastTouchMovedObj = false;
  }
  if (e.cancelable) e.preventDefault();
}, {passive:false});

  </script>
</body>
</html>

