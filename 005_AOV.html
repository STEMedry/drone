<!DOCTYPE html>
<html>
<head>
<title>Dronography AOV Simulation</title>
<style>
body {
    margin: 0;
    overflow: hidden;
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-family: Arial, sans-serif;
}

canvas { display: block; }

#title {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    z-index: 1001;
    width: 90%;
    max-width: 600px;
    text-align: center;
}

#title h1 {
    margin: 0;
    font-size: 24px;
}

    #languageToggle {
      margin-bottom: 10px;
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
    }

#controls {
    position: fixed;
    top: 40px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 10px;
    border-radius: 5px;
    z-index: 1000;
    width: 220px;
}

#controls button {
    display: block;
    width: 100%;
    margin: 5px 0;
    padding: 8px;
    background: #4CAF50;
    border: none;
    color: white;
    cursor: pointer;
    border-radius: 3px;
}

#controls button:hover {
    background: #45a049;
}

#additionalControls {
    position: fixed;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 10px;
    border-radius: 5px;
    width: 280px;
    box-sizing: border-box;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    top: 60px;
    right: 10px;
    max-height: calc(100vh - 70px);
    font-size: 14px;
}

#additionalControls h3 {
    font-size: 16px;
    margin: 0px 0 5px;
}

#additionalControls label {
    display: block;
    margin-top: 5px;
}

#additionalControls input[type="range"] {
    width: 100%;
 height: 10px;
    padding: 5px;
    margin: 2px 0 8px;
    font-size: 12px;
}

#additionalControls button {
    width: 100%;
    padding: 8px;
    margin: 5px 0;
    font-size: 14px;
}

#additionalControls p {
    margin: 5px 0;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    #additionalControls {
        width: 45%;
        max-width: none;
        font-size: 12px;
        top: 50px;
        right: 2.5%;
    }

    #additionalControls h3 {
        font-size: 14px;
    }

    #additionalControls input[type="range"],
    #additionalControls button {
        font-size: 12px;
        padding: 5px;
    }
}

button {
    background: #4CAF50;
    color: white;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.3s;
}

button:hover, button:focus {
    background: #45a049;
}

button:active {
    background: #3d8b40;
}

label {
    display: block;
    margin-top: 10px;
    font-weight: bold;
}

h3 {
    margin-top: 15px;
    margin-bottom: 5px;
    border-bottom: 1px solid #555;
    padding-bottom: 5px;
}

hr {
    border: none;
    border-bottom: 1px solid #555;
    margin: 15px 0;
}

/* Improved touch targets for range inputs */
input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 15px;
    background: #d3d3d3;
    outline: none;
    opacity: 0.7;
    transition: opacity 0.2s;
    border-radius: 12px;
    margin: 8px 0;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 35px;
    height: 35px;
    background: #4CAF50;
    cursor: pointer;
    border-radius: 50%;
}

input[type="range"]::-moz-range-thumb {
    width: 35px;
    height: 35px;
    background: #4CAF50;
    cursor: pointer;
    border-radius: 50%;
}

/* View control buttons */
#viewControls {
    position: fixed;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 90%;
}

.viewButton {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(0,0,0,0.7);
    color: white;
    border: none;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Aspect ratio buttons */
.aspectRatioButtons {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
}

#controls .aspectRatioButtons button,
#additionalControls .aspectRatioButtons button {
    flex: 1;
    margin: 0 5px;
    padding: 5px;
    font-size: 12px;
    background-color: #4CAF50; /* Default green color */
    color: white;
    border: none;
    cursor: pointer;
    transition: background-color 0.3s;
}

#controls .aspectRatioButtons button:hover,
#additionalControls .aspectRatioButtons button:hover {
    background-color: #45a049;
}

#controls .aspectRatioButtons button.active,
#additionalControls .aspectRatioButtons button.active {
    background-color: #FFA500;
}

.buildingToggle {
    background-color: #4CAF50;
    color: white;
    cursor: pointer;
    transition: background-color 0.3s;
}

.buildingToggle.active {
    background-color: #FFA500;
}

#calc1Results {
  display: flex;
  align-items: center;
}

#calc1Results label {
  margin-right: 2px;
}

#calc1Results span {
  margin-right: 2px;
}

</style>
</head>
<body>
<!-- Title -->
<div id="title">
    <h1 data-i18n="Dronography AOV Simulation" data-i18n-zh="航拍視角模擬">Dronography AOV Simulation</h1>
</div>

<!-- Information Panel -->
<div id="controls">

<button id="languageToggle">繁體中文</button><p>

    <h2 data-i18n="Main Controls" data-i18n-zh="主要控制">Main Controls</h2>

   <h3 data-i18n="Aspect Ratio" data-i18n-zh="畫幅比例">Aspect Ratio</h3>
   <div class="aspectRatioButtons">
        <button class="aspectRatioBtn" data-ratio="1.5">3:2</button>
        <button class="aspectRatioBtn" data-ratio="1.333">4:3</button>
        <button class="aspectRatioBtn" data-ratio="1.778">16:9</button>
    </div>
<div>
    <label for="aov">
        <span data-i18n="Horizontal AOV:" data-i18n-zh="水平視角:">Horizontal AOV:</span>
        <span id="aovValue">70</span>°
    </label>
    <input type="range" id="aov" min="30" max="120" value="70">
</div>
<div>
    <label>
        <span data-i18n="Vertical AOV:" data-i18n-zh="垂直視角:">Vertical AOV:</span>
        <span id="vaovValue">0.0</span>°
    </label>
</div>
<div>
    <label>
        <span data-i18n="Diagonal AOV:" data-i18n-zh="對角線視角:">Diagonal AOV:</span>
        <span id="daovValue">0.0</span>°
    </label>
</div>
<div>
    <label>
        <span data-i18n="Altitude:" data-i18n-zh="高度:">Altitude:</span>
        <span id="altitudeValue">0</span>m
    </label>
</div>
<div>
    <label>
        <span data-i18n="FOV Width:" data-i18n-zh="視野寬度:">FOV Width:</span>
        <span id="widthValue">0</span>m
    </label>
</div>
<div>
    <label>
        <span data-i18n="FOV Height:" data-i18n-zh="視野高度:">FOV Height:</span>
        <span id="heightValue">0</span>m
    </label>
</div>
<div>
    <label>
        <span data-i18n="Area Captured:" data-i18n-zh="捕捉面積:">Area Captured:</span>
        <span id="areaValue">0</span>m²
    </label>
</div>

    <hr>
    <!-- Toggle Buttons -->
<div>
	<button id="toggleSchoolBuilding">
        <span data-i18n="School Building" data-i18n-zh="學校建築">School Building</span>
    </button>
</div>
<div>
    <button id="toggleTridentBlocks">
        <span data-i18n="Trident Blocks" data-i18n-zh="Y型大厦">Trident Blocks</span>
    </button>
</div>
<div>
    <button id="toggleBankTower">
        <span data-i18n="Bank Tower" data-i18n-zh="銀行大廈">Bank Tower</span>
    </button>
</div>
</div>

<!-- Calculation Controls Panel -->
<div id="additionalControls">
    <h3 data-i18n="Calculate AOV" data-i18n-zh="計算視角">Calculate AOV</h3>
    <div class="aspectRatioButtons">
        <button class="aspectRatioBtn" data-ratio="1.5">3:2</button>
        <button class="aspectRatioBtn" data-ratio="1.333">4:3</button>
        <button class="aspectRatioBtn" data-ratio="1.778">16:9</button>
    </div>
    <div>
        <label for="calc1Altitude">
		<span data-i18n="Altitude:" data-i18n-zh="高度：">Altitude:</span>
		<span id="calc1AltitudeValue">0</span>m</label>
        <input type="range" id="calc1Altitude" min="0" max="500" value="0">
    </div>
    <div>
	  <label for="calc1FOVWidth">
 		<span data-i18n="FOV Width:" data-i18n-zh="視角寬度：">FOV Width:</span>
		<span id="calc1FOVWidthValue">0</span>m</label>
        <input type="range" id="calc1FOVWidth" min="0" max="1732" value="0">
    </div>
    <button id="calc1Button">
    <span data-i18n="Calculate AOV" data-i18n-zh="計算視角">Calculate AOV</span>
</button>

    <div id="calc1Results">
  <p><label data-i18n="Horizontal AOV:" data-i18n-zh="水平視角：">Horizontal AOV:</label>
  <span id="calc1HorizontalAOV">0.0</span>°</p>
  <p><label data-i18n="Vertical AOV:" data-i18n-zh="垂直視角：">Vertical AOV:</label><span id="calc1VerticalAOV">0.0</span>°</p>
  <p><label data-i18n="Diagonal AOV:" data-i18n-zh="對角視角：">Diagonal AOV:</label><span id="calc1DiagonalAOV">0.0</span>°</p>
    </div>

    <hr>

    <h3 data-i18n="Calculate Altitude" data-i18n-zh="計算高度">Calculate Altitude</h3>
    <div class="aspectRatioButtons">
        <button class="aspectRatioBtn" data-ratio="1.5">3:2</button>
        <button class="aspectRatioBtn" data-ratio="1.333">4:3</button>
        <button class="aspectRatioBtn" data-ratio="1.778">16:9</button>
    </div>

    <div>
        <label for="calc2DiagonalAOV">
		<span data-i18n="Diagonal AOV:" data-i18n-zh="對角線視角：">Diagonal AOV:</span>
		<span id="calc2DiagonalAOVValue">0</span><span>°</span></label>
        <input type="range" id="calc2DiagonalAOV" min="0" max="128" value="0">
    </div>

    <div>
        <label for="calc2FOVWidth">
		<span data-i18n="FOV Width:" data-i18n-zh="視角寬度：">FOV Width:</span>
		<span id="calc2FOVWidthValue">0</span><span>m</span></label>
        <input type="range" id="calc2FOVWidth" min="0" max="1732" value="0">
    </div>

<button id="calc2Button">
    <span data-i18n="Calculate Altitude" data-i18n-zh="計算高度">Calculate Altitude</span>
</button>



    <div id="calc2Results">
<label data-i18n="Required Altitude:" data-i18n-zh="所需高度：">Required Altitude:</label>
  <span id="calc2Altitude">0.0</span>m
</div>



</div>







<!-- View Control Buttons -->
<div id="viewControls">
    <button class="viewButton" id="tiltUp">↑</button>
    <button class="viewButton" id="tiltDown">↓</button>
    <button class="viewButton" id="rotateLeft">←</button>
    <button class="viewButton" id="rotateRight">→</button>
    <button class="viewButton" id="zoomIn">+</button>
    <button class="viewButton" id="zoomOut">-</button>
    <button class="viewButton" id="homeView">⌂</button>
    <button class="viewButton" id="moveUp">▲</button>
    <button class="viewButton" id="moveDown">▼</button>
    <button class="viewButton" id="moveForward">↥</button>
    <button class="viewButton" id="moveBackward">↧</button>
</div>

<!-- Three.js Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>

let scene, camera, renderer, drone, fovArea;
let isDragging = false;
let dragStartPosition = { x: 0, y: 0 };
let cameraAngle = Math.PI / 2;
let cameraTilt = 0.5;
let cameraDistance = 100;
let draggedBuilding = null;
let buildingDragStartX = 0;
let mouseStartX = 0;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

let verticalLine, fovLines, diagonals, propellers = [], blinkingLights = [];
let blinkState = true;
let lastBlinkTime = 0;
const BLINK_INTERVAL = 500;
let cornerLabels = [];
let dimensionLabels = [];
let centerLabel = null;

let schoolBuilding;
let bankTower;
let tridentBlocks;

const warnSound = new Audio('warn2.mp3');
warnSound.preload = 'auto';

function playWarnSound() {
    warnSound.currentTime = 0;
    warnSound.play().catch(function(error) {
        console.error("Error playing warning sound:", error);
    });
}

function getMaxDiagonalAOV(aspectRatio) {
    const maxHorizontalAOV = 120;
    const horizontalAOVRad = THREE.MathUtils.degToRad(maxHorizontalAOV);
    const verticalAOVRad = 2 * Math.atan(Math.tan(horizontalAOVRad / 2) / aspectRatio);
    const diagonalTan = Math.sqrt(Math.pow(Math.tan(horizontalAOVRad / 2), 2) +
    Math.pow(Math.tan(verticalAOVRad / 2), 2));
    const diagonalAOVRad = 2 * Math.atan(diagonalTan);
    const diagonalAOV = THREE.MathUtils.radToDeg(diagonalAOVRad);
    return diagonalAOV;
}

let currentMaxDiagonalAOV = getMaxDiagonalAOV(1.5);

function createDottedLine(points, color = 0x000000) {
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineDashedMaterial({
        color: color,
        dashSize: 1,
        gapSize: 2,
    });
    const line = new THREE.Line(geometry, material);
    line.computeLineDistances();
    return line;
}

function createPropeller(color) {
    const geometry = new THREE.BoxGeometry(3, 0.2, 0.4);
    const material = new THREE.MeshBasicMaterial({ color: color });
    return new THREE.Mesh(geometry, material);
}

function createBlinkingLight() {
    const geometry = new THREE.SphereGeometry(0.3, 16, 16);
    const material = new THREE.MeshBasicMaterial({
        color: 0xffff00,
        transparent: true,
        opacity: 1
    });
    return new THREE.Mesh(geometry, material);
}

function createCornerLabel(text, position) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.font = 'bold 30px Arial';
    context.fillStyle = '#00FF00';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, 128, 128);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.position.copy(position);
    sprite.scale.set(30, 30, 1);
    return sprite;
}

function createDimensionLabel(text, position, scale) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.font = 'bold 32px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.lineWidth = 2;
    context.strokeStyle = 'black';
    context.strokeText(text, 128, 128);
    context.fillStyle = 'white';
    context.fillText(text, 128, 128);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    const spriteMaterial = new THREE.SpriteMaterial({
        map: texture,
        transparent: true
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.position.copy(position);
    sprite.scale.set(scale, scale, 1);
    return sprite;
}

function createCenterLabel(text, position) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.font = 'bold 24px Arial';
    context.fillStyle = '#00FF00';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, 128, 128);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.position.copy(position);
    sprite.scale.set(30, 30, 1);
    return sprite;
}

/**
* Function to create a detailed basketball court.
*/
function createCourt() {
const courtGroup = new THREE.Group();

// Court dimensions (in feet, scaled down)
const courtLength = 94;
const courtWidth = 50;
const sideAreaWidth = 8;
const endAreaLength = 8;

// Main court (green)
const mainGeometry = new THREE.PlaneGeometry(courtWidth, courtLength);
const mainMaterial = new THREE.MeshBasicMaterial({ color: 0x2e8b57, side: THREE.DoubleSide });
const mainCourt = new THREE.Mesh(mainGeometry, mainMaterial);
mainCourt.rotation.x = -Math.PI / 2;
mainCourt.position.y = 0.01; // Slightly above ground to prevent z-fighting
courtGroup.add(mainCourt);

// Side areas (orange)
const sideGeometry = new THREE.PlaneGeometry(sideAreaWidth, courtLength + (2 * endAreaLength));
const sideMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500, side: THREE.DoubleSide });

const leftSide = new THREE.Mesh(sideGeometry, sideMaterial);
leftSide.rotation.x = -Math.PI / 2;
leftSide.position.x = -(courtWidth/2 + sideAreaWidth/2);
courtGroup.add(leftSide);

const rightSide = new THREE.Mesh(sideGeometry, sideMaterial);
rightSide.rotation.x = -Math.PI / 2;
rightSide.position.x = (courtWidth/2 + sideAreaWidth/2);
courtGroup.add(rightSide);

// End areas (orange)
const endGeometry = new THREE.PlaneGeometry(courtWidth + (2 * sideAreaWidth), endAreaLength);
const endMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500, side: THREE.DoubleSide });

const frontEnd = new THREE.Mesh(endGeometry, endMaterial);
frontEnd.rotation.x = -Math.PI / 2;
frontEnd.position.z = -(courtLength/2 + endAreaLength/2);
courtGroup.add(frontEnd);

const backEnd = new THREE.Mesh(endGeometry, endMaterial);
backEnd.rotation.x = -Math.PI / 2;
backEnd.position.z = (courtLength/2 + endAreaLength/2);
courtGroup.add(backEnd);

// Court lines
const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });

function addLine(points) {
const geometry = new THREE.BufferGeometry().setFromPoints(points);
const line = new THREE.Line(geometry, lineMaterial);
courtGroup.add(line);
}

// Outer boundary
addLine([
new THREE.Vector3(-courtWidth/2, 0.01, -courtLength/2),
new THREE.Vector3(courtWidth/2, 0.01, -courtLength/2),
new THREE.Vector3(courtWidth/2, 0.01, courtLength/2),
new THREE.Vector3(-courtWidth/2, 0.01, courtLength/2),
new THREE.Vector3(-courtWidth/2, 0.01, -courtLength/2)
]);

// Center line
addLine([
new THREE.Vector3(-courtWidth/2, 0.01, 0),
new THREE.Vector3(courtWidth/2, 0.01, 0)
]);

// Center circle
const centerCircle = new THREE.CircleGeometry(10, 32);
const circleEdges = new THREE.EdgesGeometry(centerCircle);
const centerCircleLine = new THREE.LineSegments(circleEdges, lineMaterial);
centerCircleLine.rotation.x = -Math.PI/2;
centerCircleLine.position.y = 0.01;
courtGroup.add(centerCircleLine);

// Free throw lines and key
[-courtLength/2 + 19, courtLength/2 - 19].forEach(z => {
// Free throw line
addLine([
new THREE.Vector3(-6, 0.01, z),
new THREE.Vector3(6, 0.01, z)
]);

// Key lines
addLine([
new THREE.Vector3(-6, 0.01, z),
new THREE.Vector3(-6, 0.01, z + (z < 0 ? -19 : 19))
]);
addLine([
new THREE.Vector3(6, 0.01, z),
new THREE.Vector3(6, 0.01, z + (z < 0 ? -19 : 19))
]);

// Full circle with dotted line inside rectangle
for(let i = 0; i <= 360; i++) {
const angle = (Math.PI * i / 180);
const x = 6 * Math.cos(angle);
const zOffset = 6 * Math.sin(angle);

// Outside rectangle - solid line
if (Math.abs(x) > 6 || (z < 0 && zOffset > 0) || (z > 0 && zOffset < 0)) {
addLine([
new THREE.Vector3(x, 0.01, z + zOffset),
new THREE.Vector3(6 * Math.cos((i + 1) * Math.PI / 180), 0.01,
z + 6 * Math.sin((i + 1) * Math.PI / 180))
]);
}
// Inside rectangle - dotted line
else if (i % 10 < 5) {
addLine([
new THREE.Vector3(x, 0.01, z + zOffset),
new THREE.Vector3(6 * Math.cos((i + 2) * Math.PI / 180), 0.01,
z + 6 * Math.sin((i + 2) * Math.PI / 180))
]);
}
}
});

// Three-point lines (rotated 180 degrees)
[1, -1].forEach(sign => {
const z = sign * courtLength/2;
const points = [];
for(let i = 0; i <= 180; i++) {
const angle = Math.PI + (i * Math.PI / 180); // Rotated 180 degrees
points.push(new THREE.Vector3(
Math.cos(angle) * 23.75,
0.01,
z + (sign * (Math.sin(angle) * 25.25))
));
}
addLine(points);
});

// Backboards and hoops
function createBackboardAndHoop(posZ, rotation) {
const backboardGroup = new THREE.Group();

// Stand
const standGeometry = new THREE.BoxGeometry(0.5, 12, 0.5);
const standMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
const stand = new THREE.Mesh(standGeometry, standMaterial);
stand.position.y = 6;
stand.position.z = posZ + (rotation === 0 ? -4 : 4);
backboardGroup.add(stand);

// Support beam
const beamGeometry = new THREE.BoxGeometry(0.5, 0.5, 4);
const beam = new THREE.Mesh(beamGeometry, standMaterial);
beam.position.y = 10;
beam.position.z = posZ + (rotation === 0 ? -2 : 2);
backboardGroup.add(beam);

// Backboard
const backboardGeometry = new THREE.BoxGeometry(6, 3.5, 0.2);
const backboardMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);

// Black rectangle on backboard
const blackRectGeometry = new THREE.BoxGeometry(2, 1.5, 0.21);
const blackRectMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
const blackRect = new THREE.Mesh(blackRectGeometry, blackRectMaterial);
blackRect.position.z = 0.1;
backboard.add(blackRect);

backboard.position.y = 10;
backboard.position.z = posZ;
backboard.rotation.y = rotation;
backboardGroup.add(backboard);

// Hoop
const hoopGeometry = new THREE.TorusGeometry(0.75, 0.1, 16, 100);
const hoopMaterial = new THREE.MeshBasicMaterial({ color: 0xff4500 });
const hoop = new THREE.Mesh(hoopGeometry, hoopMaterial);
hoop.position.y = 10;
hoop.position.z = posZ + (rotation === 0 ? 1 : -1);
hoop.rotation.x = Math.PI/2;
backboardGroup.add(hoop);

// Net
const netMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
for(let i = 0; i < 12; i++) {
const angle = (i / 12) * Math.PI * 2;
const netGeometry = new THREE.BufferGeometry().setFromPoints([
new THREE.Vector3(0.75 * Math.cos(angle), 0, 0.75 * Math.sin(angle)),
new THREE.Vector3(0.4 * Math.cos(angle), -1.5, 0.4 * Math.sin(angle))
]);
const netLine = new THREE.Line(netGeometry, netMaterial);
netLine.position.y = 10;
netLine.position.z = posZ + (rotation === 0 ? 1 : -1);
backboardGroup.add(netLine);
}

return backboardGroup;
}

// Create two backboards and hoops
courtGroup.add(createBackboardAndHoop(courtLength/2, Math.PI));
courtGroup.add(createBackboardAndHoop(-courtLength/2, 0));

return courtGroup;
}

// Function to create the main building and place the basketball courts
function createSchoolBuilding() {
const building = new THREE.Group();

// Main building block
const mainGeometry = new THREE.BoxGeometry(65, 31, 10);
const mainMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
const mainBlock = new THREE.Mesh(mainGeometry, mainMaterial);
// Position the main block so that its base is at y=0
mainBlock.position.y = 15.5; // Half of the original height (31/2)
building.add(mainBlock);

// Add thin black outline to mainBlock
const mainEdges = new THREE.EdgesGeometry(mainGeometry);
const mainOutline = new THREE.LineSegments(mainEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
mainBlock.add(mainOutline);

// Red vertical accents
const accentGeometry = new THREE.BoxGeometry(3, 31, 1); // Adjusted height to match standard hoop height
const accentMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

const accentPositions = [-15, -5, 5, 15];
accentPositions.forEach(xPos => {
const accent = new THREE.Mesh(accentGeometry, accentMaterial);
accent.position.set(xPos, 15.5, 5.1); // Positioned slightly above the main block
building.add(accent);

// Add thin black outline to accents
const accentEdges = new THREE.EdgesGeometry(accentGeometry);
const accentOutline = new THREE.LineSegments(accentEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
accent.add(accentOutline);
});

// Windows on mainBlock
const windowRows = 7;
const windowCols = 15;
const windowGeometry = new THREE.BoxGeometry(2, 1.5, 0.1);
const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });

for (let i = 0; i < windowRows; i++) {
for (let j = 0; j < windowCols; j++) {
const window = new THREE.Mesh(windowGeometry, windowMaterial);
window.position.x = -17 + (j * 3);
window.position.y = -6 + (i * 3) + 15; // Adjust y to match building's base
window.position.z = 5.05;
building.add(window);
}
}

// Assembly hall block
const hallGeometry = new THREE.BoxGeometry(20, 16, 24);
const hallMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
const hall = new THREE.Mesh(hallGeometry, hallMaterial);
hall.position.set(22.5, -7 + 16, 17.1); // Adjust y to match building's base
building.add(hall);

// Add thin black outline to hall
const hallEdges = new THREE.EdgesGeometry(hallGeometry);
const hallOutline = new THREE.LineSegments(hallEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
hall.add(hallOutline);

// Covered leftblock (rotated 90 degrees and moved to left side)
const leftblockGeometry = new THREE.BoxGeometry(23, 31, 20); // Dimensions swapped for rotation
const leftblockMaterial = new THREE.MeshPhongMaterial({ color: 0x1E90FF });
const leftblock = new THREE.Mesh(leftblockGeometry, leftblockMaterial);
leftblock.position.set(-21, -13.5 + 29, 5); // Moved to left side and adjusted y
building.add(leftblock);

// Add thin black outline to leftblock
const leftblockEdges = new THREE.EdgesGeometry(leftblockGeometry);
const leftblockOutline = new THREE.LineSegments(leftblockEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
leftblock.add(leftblockOutline);

// Add windows to leftblock
const leftBlockWindowRows = 7;
const leftBlockWindowCols = 8;
const leftBlockWindowGeometry = new THREE.BoxGeometry(3, 1.5, 0.3);
const leftBlockWindowMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });

for (let i = 0; i < leftBlockWindowRows; i++) {
for (let j = 0; j < leftBlockWindowCols; j++) {
const window = new THREE.Mesh(leftBlockWindowGeometry, leftBlockWindowMaterial);
window.position.x = -30 + (j * 2.5);
window.position.y = -11 + (i * 3) + 20; // Adjust y to match building's base
window.position.z = 15.05; // Front face of leftblock
building.add(window);
}
}

// Support columns for leftblock (adjusted for new position)
const columnGeometry = new THREE.BoxGeometry(0.5, 3, 0.5);
const columnMaterial = new THREE.MeshPhongMaterial({ color: 0xDDDDDD });

for (let i = 6; i < 10; i++) {
const column = new THREE.Mesh(columnGeometry, columnMaterial);
column.position.set(-20, -13.5 + 15, -18 + (i * 3)); // Adjusted positions for new leftblock orientation and y
building.add(column);
}

// Add thin black outlines to vertical accents and columns
building.children.forEach(child => {
if (child !== mainBlock && child !== hall && child !== leftblock && child.geometry) {
const edges = new THREE.EdgesGeometry(child.geometry);
const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
child.add(outline);
}
});

// Add basketball courts to the front using the detailed createCourt function
const frontCourtPositions = [
{ x: -10, z: 24 },
{ x: -10, z: 44 },
];

const desiredY = 5; // Adjust this value as needed
frontCourtPositions.forEach((pos, index) => {
const frontCourt = createCourt();
frontCourt.position.set(pos.x, 0, pos.z); // Positioning the court
building.add(frontCourt);

frontCourt.rotation.y += Math.PI / 2; // Rotate 90 degrees around Y-axis
frontCourt.scale.set(0.3, 0.3, 0.3); // Scale down courts to fit the building
});

    /*** Start of Trapezoidal Prism Addition ***/
    // Define the trapezoidal shape
    const shape = new THREE.Shape();
    shape.moveTo(0, 0);
    shape.lineTo(8, 0); // Base width: 15m
    shape.lineTo(8, 8); // Height: 5m (right angle)
    shape.lineTo(1.5, 8);  // Top width: 10m
    shape.lineTo(0, 0);

    // Extrude settings
    const extrudeSettings = {
        steps: 1,
        depth: 5, // Depth of the trapezoidal prism
        bevelEnabled: false
    };

    // Create the extruded geometry
    const trapezoidGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    const trapezoidMaterial = new THREE.MeshPhongMaterial({ color: 0xA0A0A0 }); // Orange color for visibility
    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);

    // Rotate the trapezoid to lie flat on the roof (assuming y-up)
    trapezoid.rotation.y = -Math.PI / 2; // Rotate 90 degrees around X-axis
    trapezoid.rotation.z = -Math.PI / 2; // Rotate 90 degrees around X-axis

    // Position the trapezoid on top of the leftblock
    trapezoid.position.set(-2, 20 + 0.1, -5); // Adjust x, y, z as needed
    // Explanation:
    // - x: Shifted by -5 to center the trapezoid on the leftblock's roof
    // - y: 15.5 is the top of leftblock; adding a small offset (0.1) to prevent z-fighting
    // - z: Centered

    // Optional: Add edges for better visibility
    const trapezoidEdges = new THREE.EdgesGeometry(trapezoidGeometry);
    const trapezoidOutline = new THREE.LineSegments(trapezoidEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
    trapezoid.add(trapezoidOutline);

    // Add the trapezoid to the leftblock
    leftblock.add(trapezoid);
    /*** End of Trapezoidal Prism Addition ***/




return building;
}

// Function to create grid texture for Bank Tower
function createBankGridTexture() {
const canvas = document.createElement('canvas');
canvas.width = 512;
canvas.height = 512;
const ctx = canvas.getContext('2d');

// Fill background with a light blue color
ctx.fillStyle = '#ADD8E6'; // Light Cyan background
ctx.fillRect(0, 0, canvas.width, canvas.height);

// Set grid line color to light blue
ctx.strokeStyle = '#ADD8E6'; // Light Blue
ctx.lineWidth = 5;

const majorGridSize = 64;
ctx.globalAlpha = 0.8;

// Draw major vertical grid lines
for(let i = 0; i <= canvas.width; i += majorGridSize) {
ctx.beginPath();
ctx.moveTo(i, 0);
ctx.lineTo(i, canvas.height);
ctx.stroke();
}

// Draw major horizontal grid lines
for(let i = 0; i <= canvas.height; i += majorGridSize) {
ctx.beginPath();
ctx.moveTo(0, i);
ctx.lineTo(canvas.width, i);
ctx.stroke();
}

const minorGridSize = 32;
ctx.globalAlpha = 0.4;
ctx.lineWidth = 1;

// Draw minor vertical grid lines
for(let i = 0; i <= canvas.width; i += minorGridSize) {
if (i % majorGridSize !== 0) { // Skip if it's a major grid line
ctx.beginPath();
ctx.moveTo(i, 0);
ctx.lineTo(i, canvas.height);
ctx.stroke();
}
}

// Draw minor horizontal grid lines
for(let i = 0; i <= canvas.height; i += minorGridSize) {
if (i % majorGridSize !== 0) { // Skip if it's a major grid line
ctx.beginPath();
ctx.moveTo(0, i);
ctx.lineTo(canvas.width, i);
ctx.stroke();
}
}

return new THREE.CanvasTexture(canvas);
}

// Function to create an inclined triangular prism for Bank Tower
function createBankInclinedTriangularPrism(baseSize, height) {
const group = new THREE.Group();
const gridTexture = createBankGridTexture();

// Create vertices for rectangular sides
const vertices = new Float32Array([
// Base triangle
-baseSize, 0, baseSize, // 0
baseSize, 0, baseSize, // 1
0, 0, -baseSize, // 2

// Top triangle (rectangular sides)
-baseSize * 0.7, height, baseSize * 0.7, // 3
baseSize * 0.7, height, baseSize * 0.7, // 4
0, height, -baseSize * 0.7, // 5 (now at same height)

// Additional vertices for rectangular sides
-baseSize, 0, baseSize, // 6 (same as 0)
baseSize, 0, baseSize, // 7 (same as 1)
0, 0, -baseSize, // 8 (same as 2)
-baseSize * 0.7, height, baseSize * 0.7, // 9 (same as 3)
baseSize * 0.7, height, baseSize * 0.7, // 10 (same as 4)
0, height, -baseSize * 0.7, // 11 (same as 5)
]);

const indices = new Uint16Array([
// Base triangle
0, 1, 2,

// Top triangle
3, 4, 5,

// Front rectangular face
6, 7, 10,
6, 10, 9,

// Right rectangular face
7, 8, 11,
7, 11, 10,

// Left rectangular face
8, 6, 9,
8, 9, 11
]);

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
geometry.setIndex(new THREE.BufferAttribute(indices, 1));
geometry.computeVertexNormals();

const material = new THREE.MeshPhongMaterial({
map: gridTexture,
color: 0xFFFFFF,
specular: 0x666666,
shininess: 80,
side: THREE.DoubleSide
});

const prism = new THREE.Mesh(geometry, material);
group.add(prism);

const edges = new THREE.EdgesGeometry(geometry);
const lineMaterial = new THREE.LineBasicMaterial({
color: 0x000000,
linewidth: 3,
opacity: 1
});
const lineSegments = new THREE.LineSegments(edges, lineMaterial);
group.add(lineSegments);

return group;
}

// Function to create antennas for Bank Tower
function createBankAntennas() {
const antennaGroup = new THREE.Group();

const antennaPositions = [
[-5, 0, 0],
[0, 0, 0],
[5, 0, 0]
];

antennaPositions.forEach(position => {
const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 65, 12);
const poleMaterial = new THREE.MeshPhongMaterial({
color: 0xffff00, // Bright yellow
emissive: 0xffff00, // Emissive color matching the main color
emissiveIntensity: 1, // Adjust intensity as needed
specular: 0x666666,
shininess: 60
});
const pole = new THREE.Mesh(poleGeometry, poleMaterial);

pole.position.set(position[0], position[1] + 15, position[2]);

const crossGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 50);

const cross1 = new THREE.Mesh(crossGeometry, poleMaterial);
cross1.rotation.z = Math.PI / 4;
cross1.position.y = 10;
pole.add(cross1);

const cross2 = new THREE.Mesh(crossGeometry, poleMaterial);
cross2.rotation.z = -Math.PI / 4;
cross2.position.y = 5;
pole.add(cross2);

antennaGroup.add(pole);
});

return antennaGroup;
}

// Function to create the Bank of China Tower
function createBankTower() {
const buildingGroup = new THREE.Group();
const baseSize = 60; // Adjust base size as needed for scaling
const scale = 0.28; // Scaling factor to fit the scene

const sections = [
{ height: 420, offset: [0, 0, 0] },
{ height: 680, offset: [baseSize * scale * 0.5, 0, -baseSize * scale * 0.866] },
{ height: 850, offset: [-baseSize * scale * 0.5, 0, -baseSize * scale * 0.866] },
{ height: 1130, offset: [0, 0, -baseSize * scale * 1.732] }
];

sections.forEach(section => {
const prism = createBankInclinedTriangularPrism(baseSize * scale, section.height * scale);
prism.position.set(...section.offset);
buildingGroup.add(prism);
});

const antennas = createBankAntennas();
const lastSection = sections[sections.length - 1];
const midHeight = lastSection.height * scale;
antennas.position.set(
lastSection.offset[0],
midHeight,
lastSection.offset[2]
);
buildingGroup.add(antennas);

buildingGroup.rotation.y = Math.PI / 4;

return buildingGroup;
}

// Function to create Trident Blocks
function createTridentBlocks() {
const trident = new THREE.Group();

// Create materials
const buildingMaterial = new THREE.MeshPhongMaterial({
color: 0xA3A3A3,
flatShading: true
});
const windowMaterial = new THREE.MeshPhongMaterial({
color: 0x2266aa,
opacity: 0.7,
transparent: true
});
const centroidMaterial = new THREE.MeshPhongMaterial({
color: 0xff0000
});

// Create single wing (similar to School Building's wing)
function createWing() {
const wing = new THREE.Group();

// Main building block
const mainGeometry = new THREE.BoxGeometry(23, 110, 55);
const mainBlock = new THREE.Mesh(mainGeometry, buildingMaterial);
// Move the wing forward so it connects at one end
mainBlock.position.z = 27.5;
wing.add(mainBlock);

// Add windows
const windowRows = 35;
const windowCols = 8;
const windowHeight = 2;
const windowWidth = 4;

for (let row = 0; row < windowRows; row++) {
for (let col = 0; col < windowCols; col++) {
// Front windows
const windowGeometry = new THREE.BoxGeometry(0.5, windowHeight, windowWidth);
const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
windowMesh.position.set(11.6,
-50 + row * 3,
7.5 + col * 6);
wing.add(windowMesh);

// Back windows
const backWindow = windowMesh.clone();
backWindow.position.set(-11.6,
-50 + row * 3,
7.5 + col * 6);
wing.add(backWindow);
}
}

// Add roof structures
const roofGeometry = new THREE.BoxGeometry(23, 10, 20);
const roofStructure = new THREE.Mesh(roofGeometry, buildingMaterial);
roofStructure.position.y = 60;
roofStructure.position.z = 27.5;
wing.add(roofStructure);

return wing;
}

// Create centroid marker
function createCentroidMarker() {
const geometry = new THREE.SphereGeometry(2, 32, 32);
const sphere = new THREE.Mesh(geometry, centroidMaterial);
sphere.position.y = 55;
return sphere;
}

// Create full Trident Blocks building
function createBuilding() {
const building = new THREE.Group();

// Create three wings arranged in Y-shape
const angles = [0, 120, 240]; // 120° apart for Y-shape

for (let i = 0; i < 3; i++) {
const wing = createWing();
const angle = angles[i] * Math.PI / 180;

// Rotate wings around center point
wing.rotation.y = -angle;

building.add(wing);
}

// Add centroid marker
const centroidMarker = createCentroidMarker();
building.add(centroidMarker);

return building;
}

const building = createBuilding();

    // Add outlines to each wing
    building.children.forEach(wing => {
        wing.children.forEach(child => {
            if (child instanceof THREE.Mesh) {
                const edges = new THREE.EdgesGeometry(child.geometry);
                const outline = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 })
                );
                child.add(outline);
            }
        });
    });
    
    // Add centroid marker outline
    building.children.forEach(child => {
        if (child instanceof THREE.Mesh && child.material.color.getHex() === 0xff0000) { // Assuming centroid is red
            const edges = new THREE.EdgesGeometry(child.geometry);
            const outline = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 })
            );
            child.add(outline);
        }
    });
    
trident.add(building);

// Position the Trident Blocks 200m to the left of the ground center
trident.position.set(-150, 55, -10); // Adjust as needed based on your scene's scale

return trident;
}

function init() {

    initAspectRatioButtons();

    // Set initial aspect ratio
    document.querySelector('#controls .aspectRatioBtn[data-ratio="1.5"]').click();

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const gridHelper = new THREE.GridHelper(1000, 100);
    scene.add(gridHelper);

    const axesLength = 200;
    const axesGeometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
        -axesLength, 0, 0,
        axesLength, 0, 0,
        0, 0, -axesLength,
        0, 0, axesLength
    ]);
    axesGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    const axesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
    const axes = new THREE.LineSegments(axesGeometry, axesMaterial);
    scene.add(axes);

    const labelDirections = [
        { text: "REAR", position: new THREE.Vector3(0, 0, axesLength + 5) },
        { text: "FRONT", position: new THREE.Vector3(0, 0, -axesLength - 5) },
        { text: "LEFT", position: new THREE.Vector3(-axesLength - 5, 0, 0) },
        { text: "RIGHT", position: new THREE.Vector3(axesLength + 5, 0, 0) }
    ];

    labelDirections.forEach(label => {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 256;

        context.clearRect(0, 0, canvas.width, canvas.height);
        context.font = 'bold 72px Arial';
        context.fillStyle = 'white';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(label.text, 128, 128);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(label.position);
        sprite.scale.set(30, 30, 1);
        scene.add(sprite);
    });

    const droneGeometry = new THREE.BoxGeometry(4, 1, 4);
    const droneMaterial = new THREE.MeshBasicMaterial({
        color: 0x87CEFA,
        transparent: true,
        opacity: 0.5
    });
    drone = new THREE.Mesh(droneGeometry, droneMaterial);
    drone.position.y = 0;
    scene.add(drone);

    const edges = new THREE.EdgesGeometry(droneGeometry);
    const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
    const edgeLines = new THREE.LineSegments(edges, edgesMaterial);
    drone.add(edgeLines);

    const propellerPositions = [
        { x: 2.5, y: 0.5, z: 2.5, color: 0x00ff00, clockwise: false },
        { x: -2.5, y: 0.5, z: 2.5, color: 0x00ff00, clockwise: true },
        { x: 2.5, y: 0.5, z: -2.5, color: 0xff0000, clockwise: true },
        { x: -2.5, y: 0.5, z: -2.5, color: 0xff0000, clockwise: false }
    ];

    propellerPositions.forEach(pos => {
        const propeller = createPropeller(pos.color);
        propeller.position.set(pos.x, pos.y, pos.z);
        propeller.userData.clockwise = pos.clockwise;
        drone.add(propeller);
        propellers.push(propeller);

        const light = createBlinkingLight();
        light.position.set(pos.x, pos.y + 0.2, pos.z);
        drone.add(light);
        blinkingLights.push(light);
    });

    const fovGeometry = new THREE.PlaneGeometry(1, 1);
    const fovMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    fovArea = new THREE.Mesh(fovGeometry, fovMaterial);
    fovArea.rotation.x = -Math.PI / 2;
    scene.add(fovArea);

    verticalLine = new THREE.Group();
    fovLines = new THREE.Group();
    diagonals = new THREE.Group();
    scene.add(verticalLine);
    scene.add(fovLines);
    scene.add(diagonals);

    updateCamera();

    schoolBuilding = createSchoolBuilding();
    schoolBuilding.position.set(-50, 0, -20);
    schoolBuilding.visible = false;
    scene.add(schoolBuilding);

    bankTower = createBankTower();
    bankTower.position.set(50, 0, 10);
    bankTower.visible = false;
    scene.add(bankTower);

    tridentBlocks = createTridentBlocks();
    tridentBlocks.visible = false;
    scene.add(tridentBlocks);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 50, 50);
    scene.add(directionalLight);

    window.addEventListener('resize', onWindowResize, false);
    renderer.domElement.addEventListener('mousedown', onMouseDown, false);
    renderer.domElement.addEventListener('mousemove', onMouseMove, false);
    renderer.domElement.addEventListener('mouseup', onMouseUp, false);
    renderer.domElement.addEventListener('wheel', onWheel, false);
    renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault(), false);


function initBuildingButtons() {
    document.getElementById('toggleSchoolBuilding').classList.toggle('active', schoolBuilding.visible);
    document.getElementById('toggleBankTower').classList.toggle('active', bankTower.visible);
    document.getElementById('toggleTridentBlocks').classList.toggle('active', tridentBlocks.visible);
}

// Call this function in your init() or after you've created the buildings
initBuildingButtons();


 // Add this new function to your JavaScript code
function initAspectRatioButtons() {
    document.querySelectorAll('#controls .aspectRatioBtn, #additionalControls .aspectRatioBtn').forEach(button => {
        button.addEventListener('click', function() {
            const aspectRatio = parseFloat(this.getAttribute('data-ratio'));
            currentMaxDiagonalAOV = getMaxDiagonalAOV(aspectRatio);
            console.log("Updated Max Diagonal AOV:", currentMaxDiagonalAOV.toFixed(1), "degrees");

            // Update all aspect ratio buttons in all panels
            document.querySelectorAll('#controls .aspectRatioBtn, #additionalControls .aspectRatioBtn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Add active class to clicked button and its counterparts
            document.querySelectorAll(`#controls .aspectRatioBtn[data-ratio="${aspectRatio}"], #additionalControls .aspectRatioBtn[data-ratio="${aspectRatio}"]`).forEach(btn => {
                btn.classList.add('active');
            });

            updateFOV();
        });
    });
}

function init() {
    // ... existing code ...

    initAspectRatioButtons();

    // Set initial aspect ratio
    document.querySelector('#controls .aspectRatioBtn[data-ratio="1.5"]').click();

    // ... rest of the init function ...
}

    document.getElementById('aov').addEventListener('input', updateFOV);

    document.getElementById('calc1Button').addEventListener('click', calculateAOV);
    document.getElementById('calc2Button').addEventListener('click', calculateAltitude);

    document.getElementById('calc1Altitude').addEventListener('input', function() {
        document.getElementById('calc1AltitudeValue').textContent = this.value;
    });
    document.getElementById('calc1FOVWidth').addEventListener('input', function() {
        document.getElementById('calc1FOVWidthValue').textContent = this.value;
    });
    document.getElementById('calc2DiagonalAOV').addEventListener('input', function() {
        document.getElementById('calc2DiagonalAOVValue').textContent = this.value;
    });
    document.getElementById('calc2FOVWidth').addEventListener('input', function() {
        document.getElementById('calc2FOVWidthValue').textContent = this.value;
    });


    // Set initial aspect ratio
    document.querySelector('.aspectRatioBtn[data-ratio="1.5"]').click();

    updateFOV();
}

function toggleBuilding(buildingType) {
    let building, button;
    
    switch(buildingType) {
        case 'school':
            building = schoolBuilding;
            button = document.getElementById('toggleSchoolBuilding');
            break;
        case 'bank':
            building = bankTower;
            button = document.getElementById('toggleBankTower');
            break;
        case 'trident':
            building = tridentBlocks;
            button = document.getElementById('toggleTridentBlocks');
            break;
    }
    
    if (building) {
        building.visible = !building.visible;
        if (building.visible) {
            button.classList.add('active');
        } else {
            button.classList.remove('active');
        }
    }
}

document.getElementById('toggleSchoolBuilding').addEventListener('click', () => toggleBuilding('school'));
document.getElementById('toggleBankTower').addEventListener('click', () => toggleBuilding('bank'));
document.getElementById('toggleTridentBlocks').addEventListener('click', () => toggleBuilding('trident'));

function updateCamera() {
    const x = cameraDistance * Math.cos(cameraAngle) * Math.cos(cameraTilt);
    const y = cameraDistance * Math.sin(cameraTilt);
    const z = cameraDistance * Math.sin(cameraAngle) * Math.cos(cameraTilt);
    camera.position.set(
        drone.position.x + x,
        drone.position.y + y,
        drone.position.z + z
    );
    camera.lookAt(drone.position);
}

function updateBlinkingLights() {
    const currentTime = Date.now();
    if (currentTime - lastBlinkTime > BLINK_INTERVAL) {
        blinkState = !blinkState;
        blinkingLights.forEach(light => {
            light.material.opacity = blinkState ? 1 : 0.3;
        });
        lastBlinkTime = currentTime;
    }
}

function onWheel(event) {
    event.preventDefault();
    cameraDistance += event.deltaY * 0.1;
    cameraDistance = Math.max(10, Math.min(1000, cameraDistance));
    updateCamera();
}

function onMouseDown(event) {
    isDragging = true;
    dragStartPosition.x = event.clientX;
    dragStartPosition.y = event.clientY;
    const button = event.button;

    if (button === 0) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const intersectsSchool = schoolBuilding.visible ? raycaster.intersectObject(schoolBuilding, true) : [];
        const intersectsBank = bankTower.visible ? raycaster.intersectObject(bankTower, true) : [];
        const intersectsTrident = tridentBlocks.visible ? raycaster.intersectObject(tridentBlocks, true) : [];

        if (intersectsSchool.length > 0) {
            draggedBuilding = 'school';
            buildingDragStartX = schoolBuilding.position.x;
            mouseStartX = event.clientX;
        } else if (intersectsBank.length > 0) {
            draggedBuilding = 'bank';
            buildingDragStartX = bankTower.position.x;
            mouseStartX = event.clientX;
        } else if (intersectsTrident.length > 0) {
            draggedBuilding = 'trident';
            buildingDragStartX = tridentBlocks.position.x;
            mouseStartX = event.clientX;
        } else {
            draggedBuilding = null;
        }
    }
}

function onMouseMove(event) {
    if (isDragging) {
        const deltaX = event.clientX - dragStartPosition.x;
        const deltaY = event.clientY - dragStartPosition.y;

        if (draggedBuilding) {
            const movementX = (event.clientX - mouseStartX) * 0.5;
            if (draggedBuilding === 'school') {
                schoolBuilding.position.x = buildingDragStartX + movementX;
            } else if (draggedBuilding === 'bank') {
                bankTower.position.x = buildingDragStartX + movementX;
            } else if (draggedBuilding === 'trident') {
                tridentBlocks.position.x = buildingDragStartX + movementX;
            }
        } else {
            if (event.buttons & 1) {
                const newAltitude = parseFloat(drone.position.y) - deltaY * 0.5;
                drone.position.y = Math.max(0, Math.min(500, newAltitude));
                updateFOV();
            } else if (event.buttons & 2) {
                if (event.shiftKey) {
                    drone.position.x += deltaX * 0.5;
                    drone.position.z += deltaY * 0.5;
                    updateFOV();
                } else {
                    cameraAngle -= deltaX * 0.01;
                    cameraTilt += deltaY * 0.01;
                    cameraTilt = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraTilt));
                    updateCamera();
                }
            }
        }

        dragStartPosition.x = event.clientX;
        dragStartPosition.y = event.clientY;
    }
}

function onMouseUp(event) {
    isDragging = false;
    draggedBuilding = null;
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function calculateAOV() {
    const aspectRatio = parseFloat(document.querySelector('#additionalControls .aspectRatioBtn.active').getAttribute('data-ratio'));
    const altitude = parseFloat(document.getElementById('calc1Altitude').value);
    const fovWidth = parseFloat(document.getElementById('calc1FOVWidth').value);

    if (isNaN(aspectRatio) || isNaN(altitude) || isNaN(fovWidth)) {
        playWarnSound();
        alert("Please enter valid numerical values.");
        return;
    }

    if (altitude <= 0 || fovWidth <= 0) {
        playWarnSound();
        alert("Altitude and FOV Width must be greater than zero.");
        return;
    }

    if (altitude > 500) {
        playWarnSound();
        alert("Altitude exceeds the maximum allowed range of 500m.");
        return;
    }

    const horizontalAOVRad = 2 * Math.atan(fovWidth / (2 * altitude));
    const horizontalAOV = THREE.MathUtils.radToDeg(horizontalAOVRad);

    if (horizontalAOV < 30 || horizontalAOV > 120) {
        playWarnSound();
        alert("Calculated Horizontal AOV is out of the allowed range (30-120°).");
        return;
    }

    const verticalAOVRad = 2 * Math.atan(Math.tan(horizontalAOVRad / 2) / aspectRatio);
    const verticalAOV = THREE.MathUtils.radToDeg(verticalAOVRad);

    const diagonalTan = Math.sqrt(Math.pow(Math.tan(horizontalAOVRad / 2), 2) + Math.pow(Math.tan(verticalAOVRad / 2), 2));
    const diagonalAOVRad = 2 * Math.atan(diagonalTan);
    const diagonalAOV = THREE.MathUtils.radToDeg(diagonalAOVRad);

    const maxDiagonalAOV = getMaxDiagonalAOV(aspectRatio);

    if (diagonalAOV > maxDiagonalAOV) {
        playWarnSound();
        alert(`Calculated Diagonal AOV (${diagonalAOV.toFixed(1)}°) exceeds the maximum allowed (${maxDiagonalAOV.toFixed(1)}°) for the selected aspect ratio.`);
        return;
    }

    document.getElementById('calc1HorizontalAOV').textContent = horizontalAOV.toFixed(1);
    document.getElementById('calc1VerticalAOV').textContent = verticalAOV.toFixed(1);
    document.getElementById('calc1DiagonalAOV').textContent = diagonalAOV.toFixed(1);

    document.getElementById('aov').value = horizontalAOV.toFixed(1);
    document.getElementById('altitudeValue').textContent = altitude.toFixed(1);
    document.getElementById('widthValue').textContent = fovWidth.toFixed(1);

    drone.position.y = altitude;
    fovArea.scale.set(fovWidth, fovWidth / aspectRatio, 1);

    updateFOV();
}

function calculateAltitude() {
    const aspectRatio = parseFloat(document.querySelector('#additionalControls .aspectRatioBtn.active').getAttribute('data-ratio'));
    const diagonalAOVDegrees = parseFloat(document.getElementById('calc2DiagonalAOV').value);
    const fovWidth = parseFloat(document.getElementById('calc2FOVWidth').value);

    if (isNaN(aspectRatio) || isNaN(diagonalAOVDegrees) || isNaN(fovWidth)) {
        playWarnSound();
        alert("Please enter valid numerical values.");
        return;
    }

    if (diagonalAOVDegrees <= 0 || fovWidth <= 0) {
        playWarnSound();
        alert("Diagonal AOV and FOV Width must be greater than zero.");
        return;
    }

    const maxDiagonalAOV = getMaxDiagonalAOV(aspectRatio);

    if (diagonalAOVDegrees > maxDiagonalAOV) {
        playWarnSound();
        alert(`Input Diagonal AOV (${diagonalAOVDegrees.toFixed(1)}°) exceeds the maximum allowed (${maxDiagonalAOV.toFixed(1)}°) for the selected aspect ratio.`);
        return;
    }

    const diagonalAOVRad = THREE.MathUtils.degToRad(diagonalAOVDegrees);
    const altitude = (fovWidth / 2) * Math.sqrt(1 + 1 / Math.pow(aspectRatio, 2)) / Math.tan(diagonalAOVRad / 2);

    if (altitude < 0 || altitude > 500) {
        playWarnSound();
        alert("Calculated altitude is out of the allowed range (0-500m).");
        return;
    }

    const horizontalAOVRad = 2 * Math.atan(fovWidth / (2 * altitude));
    const horizontalAOV = THREE.MathUtils.radToDeg(horizontalAOVRad);

    if (horizontalAOV < 30 || horizontalAOV > 120) {
        playWarnSound();
        alert("Calculated Horizontal AOV is out of the allowed range (30-120°).");
        return;
    }

    const verticalAOVRad = 2 * Math.atan(Math.tan(horizontalAOVRad / 2) / aspectRatio);
    const verticalAOV = THREE.MathUtils.radToDeg(verticalAOVRad);

    const diagonalTan = Math.sqrt(Math.pow(Math.tan(horizontalAOVRad / 2), 2) + Math.pow(Math.tan(verticalAOVRad / 2), 2));
    const diagonalAOVCalcRad = 2 * Math.atan(diagonalTan);
    const diagonalAOVCalc = THREE.MathUtils.radToDeg(diagonalAOVCalcRad);

    document.getElementById('calc2Altitude').textContent = altitude.toFixed(1);

    document.getElementById('calc1Altitude').value = altitude.toFixed(1);
    document.getElementById('calc1AltitudeValue').textContent = altitude.toFixed(1);
    document.getElementById('calc1FOVWidth').value = fovWidth.toFixed(1);
    document.getElementById('calc1FOVWidthValue').textContent = fovWidth.toFixed(1);
    document.getElementById('calc1HorizontalAOV').textContent = horizontalAOV.toFixed(1);
    document.getElementById('calc1VerticalAOV').textContent = verticalAOV.toFixed(1);
    document.getElementById('calc1DiagonalAOV').textContent = diagonalAOVCalc.toFixed(1);

    document.getElementById('aov').value = horizontalAOV.toFixed(1);
    document.getElementById('altitudeValue').textContent = altitude.toFixed(1);
    document.getElementById('widthValue').textContent = fovWidth.toFixed(1);

    drone.position.y = altitude;

    fovArea.scale.set(fovWidth, fovWidth / aspectRatio, 1);

    updateFOV();
}

function updateFOV() {
    const altitude = drone.position.y;
    const aov = parseFloat(document.getElementById('aov').value);
    const aspectRatio = parseFloat(document.querySelector('.aspectRatioBtn.active').getAttribute('data-ratio'));

    let width = 0;
    let height = 0;
    let area = 0;
    let verticalAOV = 0;
    let diagonalAOV = 0;

    if (altitude > 0) {
        width = 2 * altitude * Math.tan(THREE.MathUtils.degToRad(aov) / 2);
        height = width / aspectRatio;
        area = width * height;

        verticalAOV = 2 * THREE.MathUtils.radToDeg(Math.atan(Math.tan(THREE.MathUtils.degToRad(aov) / 2) / aspectRatio));

        const diagonalTan = Math.sqrt(Math.pow(Math.tan(THREE.MathUtils.degToRad(aov) / 2), 2) + Math.pow(Math.tan(THREE.MathUtils.degToRad(verticalAOV) / 2), 2));
        diagonalAOV = 2 * THREE.MathUtils.radToDeg(Math.atan(diagonalTan));

        if (diagonalAOV > currentMaxDiagonalAOV) {
            playWarnSound();
            alert(`Calculated Diagonal AOV (${diagonalAOV.toFixed(1)}°) exceeds the maximum allowed (${currentMaxDiagonalAOV.toFixed(1)}°) for the selected aspect ratio.`);
        }
    }

    fovArea.scale.set(width, height, 1);
    fovArea.position.copy(drone.position);
    fovArea.position.y = 0;

    verticalLine.clear();
    const centerPoint = new THREE.Vector3(drone.position.x, 0, drone.position.z);
    const verticalLineGeometry = createDottedLine([
        drone.position.clone(),
        centerPoint
    ], 0xFFFFFF);
    verticalLine.add(verticalLineGeometry);

    fovLines.clear();

    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const corners = [
        new THREE.Vector3(drone.position.x + halfWidth, 0, drone.position.z + halfHeight),
        new THREE.Vector3(drone.position.x - halfWidth, 0, drone.position.z + halfHeight),
        new THREE.Vector3(drone.position.x - halfWidth, 0, drone.position.z - halfHeight),
        new THREE.Vector3(drone.position.x + halfWidth, 0, drone.position.z - halfHeight)
    ];

    corners.forEach(corner => {
        const line = createDottedLine([drone.position.clone(), corner], 0xFFFFFF);
        fovLines.add(line);
    });

    diagonals.clear();

    if (altitude > 0) {
        const diagonalAC = createDottedLine([corners[0], corners[2]], 0xFFFF00);
        const diagonalBD = createDottedLine([corners[1], corners[3]], 0xFFFF00);
        diagonals.add(diagonalAC);
        diagonals.add(diagonalBD);
    }

    cornerLabels.forEach(label => scene.remove(label));
    cornerLabels = [];

    const labels = ['A', 'B', 'C', 'D'];
    corners.forEach((corner, index) => {
        const label = createCornerLabel(labels[index], corner);
        scene.add(label);
        cornerLabels.push(label);
    });

    dimensionLabels.forEach(label => scene.remove(label));
    dimensionLabels = [];

    if (altitude > 0) {
        const midpointAB = new THREE.Vector3(
            (corners[0].x + corners[1].x) / 2,
            0,
            (corners[0].z + corners[1].z) / 2
        );
        const midpointBC = new THREE.Vector3(
            (corners[1].x + corners[2].x) / 2,
            0,
            (corners[1].z + corners[2].z) / 2
        );

        const offsetDistance = -5;
        const directionAB = new THREE.Vector3(corners[1].x - corners[0].x, 0, corners[1].z - corners[0].z).normalize();
        const perpendicularAB = new THREE.Vector3(-directionAB.z, 0, directionAB.x);
        const directionBC = new THREE.Vector3(corners[2].x - corners[1].x, 0, corners[2].z - corners[1].z).normalize();
        const perpendicularBC = new THREE.Vector3(-directionBC.z, 0, directionBC.x);

        const offsetMidpointAB = midpointAB.clone().add(perpendicularAB.multiplyScalar(offsetDistance));
        const offsetMidpointBC = midpointBC.clone().add(perpendicularBC.multiplyScalar(offsetDistance));

        const baseAltitude = 100;
        const minScale = 20;
        const maxScale = 120;
        let scaleFactor = 20;
        if (altitude <= baseAltitude) {
            scaleFactor = minScale;
        } else if (altitude >= 500) {
            scaleFactor = maxScale;
        } else {
            scaleFactor = minScale + ((altitude - baseAltitude) / (500 - baseAltitude)) * (maxScale - minScale);
        }

        const abLength = Math.sqrt(
            Math.pow(corners[1].x - corners[0].x, 2) +
            Math.pow(corners[1].z - corners[0].z, 2)
        );
        const abLabel = createDimensionLabel(`AB: ${abLength.toFixed(1)}m`, offsetMidpointAB, scaleFactor);
        scene.add(abLabel);
        dimensionLabels.push(abLabel);

        const bcLength = Math.sqrt(
            Math.pow(corners[2].x - corners[1].x, 2) +
            Math.pow(corners[2].z - corners[1].z, 2)
        );
        const bcLabel = createDimensionLabel(`BC: ${bcLength.toFixed(1)}m`, offsetMidpointBC, scaleFactor);
        scene.add(bcLabel);
        dimensionLabels.push(bcLabel);
    }

    if (centerLabel) {
        scene.remove(centerLabel);
    }

    const centerPosition = new THREE.Vector3(
        drone.position.x,
        0,
        drone.position.z
    );
    centerLabel = createCenterLabel('O', centerPosition);
    scene.add(centerLabel);

    document.getElementById('aovValue').textContent = aov.toFixed(1);

    let verticalAOVDisplay = altitude > 0 ? verticalAOV.toFixed(1) : '0.0';
    let diagonalAOVDisplay = altitude > 0 ? diagonalAOV.toFixed(1) : '0.0';
    document.getElementById('vaovValue').textContent = verticalAOVDisplay;
    document.getElementById('daovValue').textContent = diagonalAOVDisplay;

    document.getElementById('altitudeValue').textContent = altitude.toFixed(1);
    document.getElementById('widthValue').textContent = width.toFixed(1);
    document.getElementById('heightValue').textContent = height.toFixed(1);
    document.getElementById('areaValue').textContent = area.toFixed(1);
}

function animate() {
    requestAnimationFrame(animate);

    propellers.forEach(propeller => {
        propeller.rotation.y += propeller.userData.clockwise ? 0.3 : -0.3;
    });

    updateBlinkingLights();

    renderer.render(scene, camera);
}

init();
animate();

let isTouchMoving = false;

document.body.addEventListener('touchstart', function(event) {
    isTouchMoving = false;
}, { passive: false });

document.body.addEventListener('touchmove', function(event) {
    isTouchMoving = true;
}, { passive: false });

document.body.addEventListener('touchend', function(event) {
    if (!isTouchMoving) {
        event.preventDefault();
    }
}, { passive: false });

function getTouchPos(touchEvent) {
    const rect = renderer.domElement.getBoundingClientRect();
    return {
        x: ((touchEvent.touches[0].clientX - rect.left) / rect.width) * 2 - 1,
        y: -((touchEvent.touches[0].clientY - rect.top) / rect.height) * 2 + 1
    };
}

renderer.domElement.addEventListener('touchstart', function(event) {
    event.preventDefault();
    if (event.touches.length === 1) {
        onMouseDown({
            clientX: event.touches[0].clientX,
            clientY: event.touches[0].clientY,
            button: 0
        });
    }
}, { passive: false });

renderer.domElement.addEventListener('touchmove', function(event) {
    event.preventDefault();
    if (event.touches.length === 1) {
        onMouseMove({
            clientX: event.touches[0].clientX,
            clientY: event.touches[0].clientY,
            buttons: 1
        });
    }
}, { passive: false });

renderer.domElement.addEventListener('touchend', function(event) {
    event.preventDefault();
    onMouseUp(event);
}, { passive: false });

document.querySelectorAll('button').forEach(button => {
    button.addEventListener('touchstart', function(e) {
        e.preventDefault();
        this.click();
    });
});

document.querySelectorAll('input[type="range"]').forEach(range => {
    range.addEventListener('touchstart', function(e) {
        e.preventDefault();
    });
    range.addEventListener('touchmove', function(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const min = parseFloat(this.min);
        const max = parseFloat(this.max);
        const rect = this.getBoundingClientRect();
        const ratio = (touch.clientX - rect.left) / rect.width;
        const value = min + ratio * (max - min);
        this.value = value;
        this.dispatchEvent(new Event('input'));
    });
});

let lastTouchEnd = 0;
document.addEventListener('touchend', function(event) {
    const now = (new Date()).getTime();
    if (now - lastTouchEnd <= 300) {
        event.preventDefault();
    }
    lastTouchEnd = now;
}, false);

function tiltUp() {
    cameraTilt = Math.min(cameraTilt + 0.1, Math.PI / 2 - 0.1);
    updateCamera();
}

function tiltDown() {
    cameraTilt = Math.max(cameraTilt - 0.1, -Math.PI / 2 + 0.1);
    updateCamera();
}

function rotateLeft() {
    cameraAngle += 0.1;
    updateCamera();
}

function rotateRight() {
    cameraAngle -= 0.1;
    updateCamera();
}

function zoomIn() {
    cameraDistance = Math.max(cameraDistance - 2, 10);
    updateCamera();
}

function zoomOut() {
    cameraDistance = Math.min(cameraDistance + 2, 1000);
    updateCamera();
}

function resetView() {
    // Reset camera parameters
    cameraAngle = Math.PI / 2;
    cameraTilt = 0.5;
    cameraDistance = 100;

    // Reset drone position
    drone.position.set(0, 0, 0);

    // Update FOV and camera
    updateFOV();
    updateCamera();

    // Reset AOV slider to default value (70 degrees)
    document.getElementById('aov').value = 70;
    
    // Trigger the input event to update the display
    document.getElementById('aov').dispatchEvent(new Event('input'));}

function moveUp() {
    drone.position.y = Math.min(500, drone.position.y + 0.5);
    updateFOV();
    updateCamera();
}

function moveDown() {
    drone.position.y = Math.max(0, drone.position.y - 0.5);
    updateFOV();
    updateCamera();
}

function moveForward() {
    const moveDistance = 1;
    drone.position.z -= moveDistance;
    updateFOV();
    updateCamera();
}

function moveBackward() {
    const moveDistance = 1;
    drone.position.z += moveDistance;
    updateFOV();
    updateCamera();
}

document.getElementById('tiltUp').addEventListener('click', tiltUp);
document.getElementById('tiltDown').addEventListener('click', tiltDown);
document.getElementById('rotateLeft').addEventListener('click', rotateLeft);
document.getElementById('rotateRight').addEventListener('click', rotateRight);
document.getElementById('zoomIn').addEventListener('click', zoomIn);
document.getElementById('zoomOut').addEventListener('click', zoomOut);
document.getElementById('homeView').addEventListener('click', resetView);
document.getElementById('moveUp').addEventListener('click', moveUp);
document.getElementById('moveDown').addEventListener('click', moveDown);
document.getElementById('moveForward').addEventListener('click', moveForward);
document.getElementById('moveBackward').addEventListener('click', moveBackward);

renderer.domElement.addEventListener('touchstart', function(event) {
    event.preventDefault();
    if (event.touches.length === 1) {
        onMouseDown({
            clientX: event.touches[0].clientX,
            clientY: event.touches[0].clientY,
            button: 0
        });
    } else if (event.touches.length === 2) {
        const touch1 = event.touches[0];
        const touch2 = event.touches[1];
        const dist = Math.hypot(
            touch1.pageX - touch2.pageX,
            touch1.pageY - touch2.pageY);
        this.pinchStartDistance = dist;
    }
}, { passive: false });

renderer.domElement.addEventListener('touchmove', function(event) {
    event.preventDefault();
    if (event.touches.length === 1) {
        onMouseMove({
            clientX: event.touches[0].clientX,
            clientY: event.touches[0].clientY,
            buttons: 1
        });
    } else if (event.touches.length === 2) {
        const touch1 = event.touches[0];
        const touch2 = event.touches[1];
        const dist = Math.hypot(
            touch1.pageX - touch2.pageX,
            touch1.pageY - touch2.pageY);
        const delta = dist - this.pinchStartDistance;
        if (delta > 0) {
            zoomIn();
        } else {
            zoomOut();
        }
        this.pinchStartDistance = dist;
    }
}, { passive: false });

  // Language switching
  const languageToggle = document.getElementById('languageToggle');
  const elements = document.querySelectorAll('[data-i18n]');

  languageToggle.addEventListener('click', () => {
    if (languageToggle.textContent === '繁體中文') {
      languageToggle.textContent = 'English';
      elements.forEach(element => {
        element.textContent = element.getAttribute('data-i18n-zh');
      });
    } else {
      languageToggle.textContent = '繁體中文';
      elements.forEach(element => {
        element.textContent = element.getAttribute('data-i18n');
      });
    }
  });

</script>
</body>
</html>
